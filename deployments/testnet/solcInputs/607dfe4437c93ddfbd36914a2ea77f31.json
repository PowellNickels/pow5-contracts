{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {ERC165Upgradeable} from \"../utils/introspection/ERC165Upgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControl, ERC165Upgradeable {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.AccessControl\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.AccessControl\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport {IERC1155MetadataURI} from \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport {ERC1155Utils} from \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Utils.sol\";\nimport {ContextUpgradeable} from \"../../utils/ContextUpgradeable.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {ERC165Upgradeable} from \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport {Arrays} from \"@openzeppelin/contracts/utils/Arrays.sol\";\nimport {IERC1155Errors} from \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n */\nabstract contract ERC1155Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC1155, IERC1155MetadataURI, IERC1155Errors {\n    using Arrays for uint256[];\n    using Arrays for address[];\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC1155\n    struct ERC1155Storage {\n        mapping(uint256 id => mapping(address account => uint256)) _balances;\n\n        mapping(address account => mapping(address operator => bool)) _operatorApprovals;\n\n        // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n        string _uri;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC1155\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC1155StorageLocation = 0x88be536d5240c274a3b1d3a1be54482fd9caa294f08c62a7cde569f49a3c4500;\n\n    function _getERC1155Storage() private pure returns (ERC1155Storage storage $) {\n        assembly {\n            $.slot := ERC1155StorageLocation\n        }\n    }\n\n    /**\n     * @dev See {_setURI}.\n     */\n    function __ERC1155_init(string memory uri_) internal onlyInitializing {\n        __ERC1155_init_unchained(uri_);\n    }\n\n    function __ERC1155_init_unchained(string memory uri_) internal onlyInitializing {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the ERC].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256 /* id */) public view virtual returns (string memory) {\n        ERC1155Storage storage $ = _getERC1155Storage();\n        return $._uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     */\n    function balanceOf(address account, uint256 id) public view virtual returns (uint256) {\n        ERC1155Storage storage $ = _getERC1155Storage();\n        return $._balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] memory accounts,\n        uint256[] memory ids\n    ) public view virtual returns (uint256[] memory) {\n        if (accounts.length != ids.length) {\n            revert ERC1155InvalidArrayLength(ids.length, accounts.length);\n        }\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts.unsafeMemoryAccess(i), ids.unsafeMemoryAccess(i));\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual returns (bool) {\n        ERC1155Storage storage $ = _getERC1155Storage();\n        return $._operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes memory data) public virtual {\n        address sender = _msgSender();\n        if (from != sender && !isApprovedForAll(from, sender)) {\n            revert ERC1155MissingApprovalForAll(sender, from);\n        }\n        _safeTransferFrom(from, to, id, value, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) public virtual {\n        address sender = _msgSender();\n        if (from != sender && !isApprovedForAll(from, sender)) {\n            revert ERC1155MissingApprovalForAll(sender, from);\n        }\n        _safeBatchTransferFrom(from, to, ids, values, data);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`. Will mint (or burn) if `from`\n     * (or `to`) is the zero address.\n     *\n     * Emits a {TransferSingle} event if the arrays contain one element, and {TransferBatch} otherwise.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement either {IERC1155Receiver-onERC1155Received}\n     *   or {IERC1155Receiver-onERC1155BatchReceived} and return the acceptance magic value.\n     * - `ids` and `values` must have the same length.\n     *\n     * NOTE: The ERC-1155 acceptance check is not performed in this function. See {_updateWithAcceptanceCheck} instead.\n     */\n    function _update(address from, address to, uint256[] memory ids, uint256[] memory values) internal virtual {\n        ERC1155Storage storage $ = _getERC1155Storage();\n        if (ids.length != values.length) {\n            revert ERC1155InvalidArrayLength(ids.length, values.length);\n        }\n\n        address operator = _msgSender();\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids.unsafeMemoryAccess(i);\n            uint256 value = values.unsafeMemoryAccess(i);\n\n            if (from != address(0)) {\n                uint256 fromBalance = $._balances[id][from];\n                if (fromBalance < value) {\n                    revert ERC1155InsufficientBalance(from, fromBalance, value, id);\n                }\n                unchecked {\n                    // Overflow not possible: value <= fromBalance\n                    $._balances[id][from] = fromBalance - value;\n                }\n            }\n\n            if (to != address(0)) {\n                $._balances[id][to] += value;\n            }\n        }\n\n        if (ids.length == 1) {\n            uint256 id = ids.unsafeMemoryAccess(0);\n            uint256 value = values.unsafeMemoryAccess(0);\n            emit TransferSingle(operator, from, to, id, value);\n        } else {\n            emit TransferBatch(operator, from, to, ids, values);\n        }\n    }\n\n    /**\n     * @dev Version of {_update} that performs the token acceptance check by calling\n     * {IERC1155Receiver-onERC1155Received} or {IERC1155Receiver-onERC1155BatchReceived} on the receiver address if it\n     * contains code (eg. is a smart contract at the moment of execution).\n     *\n     * IMPORTANT: Overriding this function is discouraged because it poses a reentrancy risk from the receiver. So any\n     * update to the contract state after this function would break the check-effect-interaction pattern. Consider\n     * overriding {_update} instead.\n     */\n    function _updateWithAcceptanceCheck(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) internal virtual {\n        _update(from, to, ids, values);\n        if (to != address(0)) {\n            address operator = _msgSender();\n            if (ids.length == 1) {\n                uint256 id = ids.unsafeMemoryAccess(0);\n                uint256 value = values.unsafeMemoryAccess(0);\n                ERC1155Utils.checkOnERC1155Received(operator, from, to, id, value, data);\n            } else {\n                ERC1155Utils.checkOnERC1155BatchReceived(operator, from, to, ids, values, data);\n            }\n        }\n    }\n\n    /**\n     * @dev Transfers a `value` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes memory data) internal {\n        if (to == address(0)) {\n            revert ERC1155InvalidReceiver(address(0));\n        }\n        if (from == address(0)) {\n            revert ERC1155InvalidSender(address(0));\n        }\n        (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);\n        _updateWithAcceptanceCheck(from, to, ids, values, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     * - `ids` and `values` must have the same length.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) internal {\n        if (to == address(0)) {\n            revert ERC1155InvalidReceiver(address(0));\n        }\n        if (from == address(0)) {\n            revert ERC1155InvalidSender(address(0));\n        }\n        _updateWithAcceptanceCheck(from, to, ids, values, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the ERC].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the values in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        ERC1155Storage storage $ = _getERC1155Storage();\n        $._uri = newuri;\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens of type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(address to, uint256 id, uint256 value, bytes memory data) internal {\n        if (to == address(0)) {\n            revert ERC1155InvalidReceiver(address(0));\n        }\n        (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);\n        _updateWithAcceptanceCheck(address(0), to, ids, values, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `values` must have the same length.\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory values, bytes memory data) internal {\n        if (to == address(0)) {\n            revert ERC1155InvalidReceiver(address(0));\n        }\n        _updateWithAcceptanceCheck(address(0), to, ids, values, data);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens of type `id` from `from`\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `value` amount of tokens of type `id`.\n     */\n    function _burn(address from, uint256 id, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC1155InvalidSender(address(0));\n        }\n        (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);\n        _updateWithAcceptanceCheck(from, address(0), ids, values, \"\");\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `value` amount of tokens of type `id`.\n     * - `ids` and `values` must have the same length.\n     */\n    function _burnBatch(address from, uint256[] memory ids, uint256[] memory values) internal {\n        if (from == address(0)) {\n            revert ERC1155InvalidSender(address(0));\n        }\n        _updateWithAcceptanceCheck(from, address(0), ids, values, \"\");\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the zero address.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC1155Storage storage $ = _getERC1155Storage();\n        if (operator == address(0)) {\n            revert ERC1155InvalidOperator(address(0));\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Creates an array in memory with only one value for each of the elements provided.\n     */\n    function _asSingletonArrays(\n        uint256 element1,\n        uint256 element2\n    ) private pure returns (uint256[] memory array1, uint256[] memory array2) {\n        assembly (\"memory-safe\") {\n            // Load the free memory pointer\n            array1 := mload(0x40)\n            // Set array length to 1\n            mstore(array1, 1)\n            // Store the single element at the next word after the length (where content starts)\n            mstore(add(array1, 0x20), element1)\n\n            // Repeat for next array locating it right after the first array\n            array2 := add(array1, 0x40)\n            mstore(array2, 1)\n            mstore(add(array2, 0x20), element2)\n\n            // Update the free memory pointer by pointing after the second array\n            mstore(0x40, add(array2, 0x40))\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {ContextUpgradeable} from \"../../utils/ContextUpgradeable.sol\";\nimport {IERC20Errors} from \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC-20\n * applications.\n */\nabstract contract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20, IERC20Metadata, IERC20Errors {\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC20\n    struct ERC20Storage {\n        mapping(address account => uint256) _balances;\n\n        mapping(address account => mapping(address spender => uint256)) _allowances;\n\n        uint256 _totalSupply;\n\n        string _name;\n        string _symbol;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC20\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC20StorageLocation = 0x52c63247e1f47db19d5ce0460030c497f067ca4cebf71ba98eeadabe20bace00;\n\n    function _getERC20Storage() private pure returns (ERC20Storage storage $) {\n        assembly {\n            $.slot := ERC20StorageLocation\n        }\n    }\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC20Storage storage $ = _getERC20Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Skips emitting an {Approval} event indicating an allowance update. This is not\n     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        ERC20Storage storage $ = _getERC20Storage();\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            $._totalSupply += value;\n        } else {\n            uint256 fromBalance = $._balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                $._balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                $._totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                $._balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     *\n     * ```solidity\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        ERC20Storage storage $ = _getERC20Storage();\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        $._allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165 {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"./IAccessControl.sol\";\nimport {Context} from \"../utils/Context.sol\";\nimport {ERC165} from \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (access/IAccessControl.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev External interface of AccessControl declared to support ERC-165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call. This account bears the admin role (for the granted role).\n     * Expected in cases where the role was granted using the internal {AccessControl-_grantRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC-20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC-721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC-1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1363.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/IERC1363.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"../utils/Errors.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[ERC-1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        return clone(implementation, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Clones-clone-address-}[clone], but with a `value` parameter to send native currency\n     * to the new contract.\n     *\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\n     */\n    function clone(address implementation, uint256 value) internal returns (address instance) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        assembly (\"memory-safe\") {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(value, 0x09, 0x37)\n        }\n        if (instance == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        return cloneDeterministic(implementation, salt, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Clones-cloneDeterministic-address-bytes32-}[cloneDeterministic], but with\n     * a `value` parameter to send native currency to the new contract.\n     *\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\n     */\n    function cloneDeterministic(\n        address implementation,\n        bytes32 salt,\n        uint256 value\n    ) internal returns (address instance) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        assembly (\"memory-safe\") {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(value, 0x09, 0x37, salt)\n        }\n        if (instance == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := and(keccak256(add(ptr, 0x43), 0x55), 0xffffffffffffffffffffffffffffffffffffffff)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC1155} from \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[ERC].\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC-1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[ERC].\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the value of tokens of token type `id` owned by `account`.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the zero address.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.\n     *\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\n     * to an untrusted contract, when invoking {onERC1155Received} on the receiver.\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\n     * reentrancy guards when interacting with untrusted contracts.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\n     * to an untrusted contract, when invoking {onERC1155BatchReceived} on the receiver.\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\n     * reentrancy guards when interacting with untrusted contracts.\n     *\n     * Emits either a {TransferSingle} or a {TransferBatch} event, depending on the length of the array arguments.\n     *\n     * Requirements:\n     *\n     * - `ids` and `values` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface that must be implemented by smart contracts in order to receive\n * ERC-1155 token transfers.\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC-1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC-1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC1155/utils/ERC1155Holder.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165, ERC165} from \"../../../utils/introspection/ERC165.sol\";\nimport {IERC1155Receiver} from \"../IERC1155Receiver.sol\";\n\n/**\n * @dev Simple implementation of `IERC1155Receiver` that will allow a contract to hold ERC-1155 tokens.\n *\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\n * stuck.\n */\nabstract contract ERC1155Holder is ERC165, IERC1155Receiver {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC1155/utils/ERC1155Utils.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC1155Receiver} from \"../IERC1155Receiver.sol\";\nimport {IERC1155Errors} from \"../../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Library that provide common ERC-1155 utility functions.\n *\n * See https://eips.ethereum.org/EIPS/eip-1155[ERC-1155].\n *\n * _Available since v5.1._\n */\nlibrary ERC1155Utils {\n    /**\n     * @dev Performs an acceptance check for the provided `operator` by calling {IERC1155-onERC1155Received}\n     * on the `to` address. The `operator` is generally the address that initiated the token transfer (i.e. `msg.sender`).\n     *\n     * The acceptance call is not executed and treated as a no-op if the target address doesn't contain code (i.e. an EOA).\n     * Otherwise, the recipient must implement {IERC1155Receiver-onERC1155Received} and return the acceptance magic value to accept\n     * the transfer.\n     */\n    function checkOnERC1155Received(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length > 0) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, value, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    // Tokens rejected\n                    revert IERC1155Errors.ERC1155InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    // non-IERC1155Receiver implementer\n                    revert IERC1155Errors.ERC1155InvalidReceiver(to);\n                } else {\n                    assembly (\"memory-safe\") {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Performs a batch acceptance check for the provided `operator` by calling {IERC1155-onERC1155BatchReceived}\n     * on the `to` address. The `operator` is generally the address that initiated the token transfer (i.e. `msg.sender`).\n     *\n     * The acceptance call is not executed and treated as a no-op if the target address doesn't contain code (i.e. an EOA).\n     * Otherwise, the recipient must implement {IERC1155Receiver-onERC1155Received} and return the acceptance magic value to accept\n     * the transfer.\n     */\n    function checkOnERC1155BatchReceived(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) internal {\n        if (to.code.length > 0) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, values, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    // Tokens rejected\n                    revert IERC1155Errors.ERC1155InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    // non-IERC1155Receiver implementer\n                    revert IERC1155Errors.ERC1155InvalidReceiver(to);\n                } else {\n                    assembly (\"memory-safe\") {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC-20\n * applications.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Skips emitting an {Approval} event indicating an allowance update. This is not\n     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     *\n     * ```solidity\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC-721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC-721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC-721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @title ERC-721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC-721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\n     * reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/utils/ERC721Holder.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721Receiver} from \"../IERC721Receiver.sol\";\n\n/**\n * @dev Implementation of the {IERC721Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or\n * {IERC721-setApprovalForAll}.\n */\nabstract contract ERC721Holder is IERC721Receiver {\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(address, address, uint256, bytes memory) public virtual returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert Errors.FailedCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            assembly (\"memory-safe\") {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Arrays.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Arrays.sol)\n// This file was procedurally generated from scripts/generate/templates/Arrays.js.\n\npragma solidity ^0.8.20;\n\nimport {Comparators} from \"./Comparators.sol\";\nimport {SlotDerivation} from \"./SlotDerivation.sol\";\nimport {StorageSlot} from \"./StorageSlot.sol\";\nimport {Math} from \"./math/Math.sol\";\n\n/**\n * @dev Collection of functions related to array types.\n */\nlibrary Arrays {\n    using SlotDerivation for bytes32;\n    using StorageSlot for bytes32;\n\n    /**\n     * @dev Sort an array of uint256 (in memory) following the provided comparator function.\n     *\n     * This function does the sorting \"in place\", meaning that it overrides the input. The object is returned for\n     * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.\n     *\n     * NOTE: this function's cost is `O(n · log(n))` in average and `O(n²)` in the worst case, with n the length of the\n     * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful\n     * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may\n     * consume more gas than is available in a block, leading to potential DoS.\n     *\n     * IMPORTANT: Consider memory side-effects when using custom comparator functions that access memory in an unsafe way.\n     */\n    function sort(\n        uint256[] memory array,\n        function(uint256, uint256) pure returns (bool) comp\n    ) internal pure returns (uint256[] memory) {\n        _quickSort(_begin(array), _end(array), comp);\n        return array;\n    }\n\n    /**\n     * @dev Variant of {sort} that sorts an array of uint256 in increasing order.\n     */\n    function sort(uint256[] memory array) internal pure returns (uint256[] memory) {\n        sort(array, Comparators.lt);\n        return array;\n    }\n\n    /**\n     * @dev Sort an array of address (in memory) following the provided comparator function.\n     *\n     * This function does the sorting \"in place\", meaning that it overrides the input. The object is returned for\n     * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.\n     *\n     * NOTE: this function's cost is `O(n · log(n))` in average and `O(n²)` in the worst case, with n the length of the\n     * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful\n     * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may\n     * consume more gas than is available in a block, leading to potential DoS.\n     *\n     * IMPORTANT: Consider memory side-effects when using custom comparator functions that access memory in an unsafe way.\n     */\n    function sort(\n        address[] memory array,\n        function(address, address) pure returns (bool) comp\n    ) internal pure returns (address[] memory) {\n        sort(_castToUint256Array(array), _castToUint256Comp(comp));\n        return array;\n    }\n\n    /**\n     * @dev Variant of {sort} that sorts an array of address in increasing order.\n     */\n    function sort(address[] memory array) internal pure returns (address[] memory) {\n        sort(_castToUint256Array(array), Comparators.lt);\n        return array;\n    }\n\n    /**\n     * @dev Sort an array of bytes32 (in memory) following the provided comparator function.\n     *\n     * This function does the sorting \"in place\", meaning that it overrides the input. The object is returned for\n     * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.\n     *\n     * NOTE: this function's cost is `O(n · log(n))` in average and `O(n²)` in the worst case, with n the length of the\n     * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful\n     * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may\n     * consume more gas than is available in a block, leading to potential DoS.\n     *\n     * IMPORTANT: Consider memory side-effects when using custom comparator functions that access memory in an unsafe way.\n     */\n    function sort(\n        bytes32[] memory array,\n        function(bytes32, bytes32) pure returns (bool) comp\n    ) internal pure returns (bytes32[] memory) {\n        sort(_castToUint256Array(array), _castToUint256Comp(comp));\n        return array;\n    }\n\n    /**\n     * @dev Variant of {sort} that sorts an array of bytes32 in increasing order.\n     */\n    function sort(bytes32[] memory array) internal pure returns (bytes32[] memory) {\n        sort(_castToUint256Array(array), Comparators.lt);\n        return array;\n    }\n\n    /**\n     * @dev Performs a quick sort of a segment of memory. The segment sorted starts at `begin` (inclusive), and stops\n     * at end (exclusive). Sorting follows the `comp` comparator.\n     *\n     * Invariant: `begin <= end`. This is the case when initially called by {sort} and is preserved in subcalls.\n     *\n     * IMPORTANT: Memory locations between `begin` and `end` are not validated/zeroed. This function should\n     * be used only if the limits are within a memory array.\n     */\n    function _quickSort(uint256 begin, uint256 end, function(uint256, uint256) pure returns (bool) comp) private pure {\n        unchecked {\n            if (end - begin < 0x40) return;\n\n            // Use first element as pivot\n            uint256 pivot = _mload(begin);\n            // Position where the pivot should be at the end of the loop\n            uint256 pos = begin;\n\n            for (uint256 it = begin + 0x20; it < end; it += 0x20) {\n                if (comp(_mload(it), pivot)) {\n                    // If the value stored at the iterator's position comes before the pivot, we increment the\n                    // position of the pivot and move the value there.\n                    pos += 0x20;\n                    _swap(pos, it);\n                }\n            }\n\n            _swap(begin, pos); // Swap pivot into place\n            _quickSort(begin, pos, comp); // Sort the left side of the pivot\n            _quickSort(pos + 0x20, end, comp); // Sort the right side of the pivot\n        }\n    }\n\n    /**\n     * @dev Pointer to the memory location of the first element of `array`.\n     */\n    function _begin(uint256[] memory array) private pure returns (uint256 ptr) {\n        assembly (\"memory-safe\") {\n            ptr := add(array, 0x20)\n        }\n    }\n\n    /**\n     * @dev Pointer to the memory location of the first memory word (32bytes) after `array`. This is the memory word\n     * that comes just after the last element of the array.\n     */\n    function _end(uint256[] memory array) private pure returns (uint256 ptr) {\n        unchecked {\n            return _begin(array) + array.length * 0x20;\n        }\n    }\n\n    /**\n     * @dev Load memory word (as a uint256) at location `ptr`.\n     */\n    function _mload(uint256 ptr) private pure returns (uint256 value) {\n        assembly {\n            value := mload(ptr)\n        }\n    }\n\n    /**\n     * @dev Swaps the elements memory location `ptr1` and `ptr2`.\n     */\n    function _swap(uint256 ptr1, uint256 ptr2) private pure {\n        assembly {\n            let value1 := mload(ptr1)\n            let value2 := mload(ptr2)\n            mstore(ptr1, value2)\n            mstore(ptr2, value1)\n        }\n    }\n\n    /// @dev Helper: low level cast address memory array to uint256 memory array\n    function _castToUint256Array(address[] memory input) private pure returns (uint256[] memory output) {\n        assembly {\n            output := input\n        }\n    }\n\n    /// @dev Helper: low level cast bytes32 memory array to uint256 memory array\n    function _castToUint256Array(bytes32[] memory input) private pure returns (uint256[] memory output) {\n        assembly {\n            output := input\n        }\n    }\n\n    /// @dev Helper: low level cast address comp function to uint256 comp function\n    function _castToUint256Comp(\n        function(address, address) pure returns (bool) input\n    ) private pure returns (function(uint256, uint256) pure returns (bool) output) {\n        assembly {\n            output := input\n        }\n    }\n\n    /// @dev Helper: low level cast bytes32 comp function to uint256 comp function\n    function _castToUint256Comp(\n        function(bytes32, bytes32) pure returns (bool) input\n    ) private pure returns (function(uint256, uint256) pure returns (bool) output) {\n        assembly {\n            output := input\n        }\n    }\n\n    /**\n     * @dev Searches a sorted `array` and returns the first index that contains\n     * a value greater or equal to `element`. If no such index exists (i.e. all\n     * values in the array are strictly less than `element`), the array length is\n     * returned. Time complexity O(log n).\n     *\n     * NOTE: The `array` is expected to be sorted in ascending order, and to\n     * contain no repeated elements.\n     *\n     * IMPORTANT: Deprecated. This implementation behaves as {lowerBound} but lacks\n     * support for repeated elements in the array. The {lowerBound} function should\n     * be used instead.\n     */\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeAccess(array, mid).value > element) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\n        if (low > 0 && unsafeAccess(array, low - 1).value == element) {\n            return low - 1;\n        } else {\n            return low;\n        }\n    }\n\n    /**\n     * @dev Searches an `array` sorted in ascending order and returns the first\n     * index that contains a value greater or equal than `element`. If no such index\n     * exists (i.e. all values in the array are strictly less than `element`), the array\n     * length is returned. Time complexity O(log n).\n     *\n     * See C++'s https://en.cppreference.com/w/cpp/algorithm/lower_bound[lower_bound].\n     */\n    function lowerBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeAccess(array, mid).value < element) {\n                // this cannot overflow because mid < high\n                unchecked {\n                    low = mid + 1;\n                }\n            } else {\n                high = mid;\n            }\n        }\n\n        return low;\n    }\n\n    /**\n     * @dev Searches an `array` sorted in ascending order and returns the first\n     * index that contains a value strictly greater than `element`. If no such index\n     * exists (i.e. all values in the array are strictly less than `element`), the array\n     * length is returned. Time complexity O(log n).\n     *\n     * See C++'s https://en.cppreference.com/w/cpp/algorithm/upper_bound[upper_bound].\n     */\n    function upperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeAccess(array, mid).value > element) {\n                high = mid;\n            } else {\n                // this cannot overflow because mid < high\n                unchecked {\n                    low = mid + 1;\n                }\n            }\n        }\n\n        return low;\n    }\n\n    /**\n     * @dev Same as {lowerBound}, but with an array in memory.\n     */\n    function lowerBoundMemory(uint256[] memory array, uint256 element) internal pure returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeMemoryAccess(array, mid) < element) {\n                // this cannot overflow because mid < high\n                unchecked {\n                    low = mid + 1;\n                }\n            } else {\n                high = mid;\n            }\n        }\n\n        return low;\n    }\n\n    /**\n     * @dev Same as {upperBound}, but with an array in memory.\n     */\n    function upperBoundMemory(uint256[] memory array, uint256 element) internal pure returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeMemoryAccess(array, mid) > element) {\n                high = mid;\n            } else {\n                // this cannot overflow because mid < high\n                unchecked {\n                    low = mid + 1;\n                }\n            }\n        }\n\n        return low;\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(address[] storage arr, uint256 pos) internal pure returns (StorageSlot.AddressSlot storage) {\n        bytes32 slot;\n        assembly (\"memory-safe\") {\n            slot := arr.slot\n        }\n        return slot.deriveArray().offset(pos).getAddressSlot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(bytes32[] storage arr, uint256 pos) internal pure returns (StorageSlot.Bytes32Slot storage) {\n        bytes32 slot;\n        assembly (\"memory-safe\") {\n            slot := arr.slot\n        }\n        return slot.deriveArray().offset(pos).getBytes32Slot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(uint256[] storage arr, uint256 pos) internal pure returns (StorageSlot.Uint256Slot storage) {\n        bytes32 slot;\n        assembly (\"memory-safe\") {\n            slot := arr.slot\n        }\n        return slot.deriveArray().offset(pos).getUint256Slot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(address[] memory arr, uint256 pos) internal pure returns (address res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(bytes32[] memory arr, uint256 pos) internal pure returns (bytes32 res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(uint256[] memory arr, uint256 pos) internal pure returns (uint256 res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n\n    /**\n     * @dev Helper to set the length of an dynamic array. Directly writing to `.length` is forbidden.\n     *\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\n     */\n    function unsafeSetLength(address[] storage array, uint256 len) internal {\n        assembly (\"memory-safe\") {\n            sstore(array.slot, len)\n        }\n    }\n\n    /**\n     * @dev Helper to set the length of an dynamic array. Directly writing to `.length` is forbidden.\n     *\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\n     */\n    function unsafeSetLength(bytes32[] storage array, uint256 len) internal {\n        assembly (\"memory-safe\") {\n            sstore(array.slot, len)\n        }\n    }\n\n    /**\n     * @dev Helper to set the length of an dynamic array. Directly writing to `.length` is forbidden.\n     *\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\n     */\n    function unsafeSetLength(uint256[] storage array, uint256 len) internal {\n        assembly (\"memory-safe\") {\n            sstore(array.slot, len)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Comparators.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Comparators.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides a set of functions to compare values.\n *\n * _Available since v5.1._\n */\nlibrary Comparators {\n    function lt(uint256 a, uint256 b) internal pure returns (bool) {\n        return a < b;\n    }\n\n    function gt(uint256 a, uint256 b) internal pure returns (bool) {\n        return a > b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n *\n * _Available since v5.1._\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n\n    /**\n     * @dev A necessary precompile is missing.\n     */\n    error MissingPrecompile(address);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\nimport {Panic} from \"../Panic.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an success flag (no overflow).\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an success flag (no overflow).\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an success flag (no overflow).\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * SafeCast.toUint(condition));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        // The following calculation ensures accurate ceiling division without overflow.\n        // Since a is non-zero, (a - 1) / b will not overflow.\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\n        // when a = type(uint256).max and b = 1.\n        unchecked {\n            return SafeCast.toUint(a > 0) * ((a - 1) / b + 1);\n        }\n    }\n\n    /**\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     *\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2²⁵⁶ and mod 2²⁵⁶ - 1, then use\n            // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2²⁵⁶ + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2²⁵⁶. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2²⁵⁶ / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2²⁵⁶. Now that denominator is an odd number, it has an inverse modulo 2²⁵⁶ such\n            // that denominator * inv ≡ 1 mod 2²⁵⁶. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv ≡ 1 mod 2⁴.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹⁶\n            inverse *= 2 - denominator * inverse; // inverse mod 2³²\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁶⁴\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹²⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2²⁵⁶\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2²⁵⁶. Since the preconditions guarantee that the outcome is\n            // less than 2²⁵⁶, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\n    }\n\n    /**\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\n     *\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\n     *\n     * If the input value is not inversible, 0 is returned.\n     *\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the\n     * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.\n     */\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\n        unchecked {\n            if (n == 0) return 0;\n\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\n            // ax + ny = 1\n            // ax = 1 + (-y)n\n            // ax ≡ 1 (mod n) # x is the inverse of a modulo n\n\n            // If the remainder is 0 the gcd is n right away.\n            uint256 remainder = a % n;\n            uint256 gcd = n;\n\n            // Therefore the initial coefficients are:\n            // ax + ny = gcd(a, n) = n\n            // 0a + 1n = n\n            int256 x = 0;\n            int256 y = 1;\n\n            while (remainder != 0) {\n                uint256 quotient = gcd / remainder;\n\n                (gcd, remainder) = (\n                    // The old remainder is the next gcd to try.\n                    remainder,\n                    // Compute the next remainder.\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\n                    // where gcd is at most n (capped to type(uint256).max)\n                    gcd - remainder * quotient\n                );\n\n                (x, y) = (\n                    // Increment the coefficient of a.\n                    y,\n                    // Decrement the coefficient of n.\n                    // Can overflow, but the result is casted to uint256 so that the\n                    // next value of y is \"wrapped around\" to a value between 0 and n - 1.\n                    x - y * int256(quotient)\n                );\n            }\n\n            if (gcd != 1) return 0; // No inverse exists.\n            return ternary(x < 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.\n        }\n    }\n\n    /**\n     * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.\n     *\n     * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is\n     * prime, then `a**(p-1) ≡ 1 mod p`. As a consequence, we have `a * a**(p-2) ≡ 1 mod p`, which means that\n     * `a**(p-2)` is the modular multiplicative inverse of a in Fp.\n     *\n     * NOTE: this function does NOT check that `p` is a prime greater than `2`.\n     */\n    function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {\n        unchecked {\n            return Math.modExp(a, p - 2, p);\n        }\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\n     *\n     * Requirements:\n     * - modulus can't be zero\n     * - underlying staticcall to precompile must succeed\n     *\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\n     * interpreted as 0.\n     */\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        (bool success, uint256 result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying\n     * to operate modulo 0 or if the underlying precompile reverted.\n     *\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\n     * of a revert, but the result may be incorrectly interpreted as 0.\n     */\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\n        if (m == 0) return (false, 0);\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            // | Offset    | Content    | Content (Hex)                                                      |\n            // |-----------|------------|--------------------------------------------------------------------|\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\n            mstore(ptr, 0x20)\n            mstore(add(ptr, 0x20), 0x20)\n            mstore(add(ptr, 0x40), 0x20)\n            mstore(add(ptr, 0x60), b)\n            mstore(add(ptr, 0x80), e)\n            mstore(add(ptr, 0xa0), m)\n\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\n            // so we can use the memory scratch space located at offset 0.\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /**\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\n     */\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\n        (bool success, bytes memory result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\n     */\n    function tryModExp(\n        bytes memory b,\n        bytes memory e,\n        bytes memory m\n    ) internal view returns (bool success, bytes memory result) {\n        if (_zeroBytes(m)) return (false, new bytes(0));\n\n        uint256 mLen = m.length;\n\n        // Encode call args in result and move the free memory pointer\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\n\n        assembly (\"memory-safe\") {\n            let dataPtr := add(result, 0x20)\n            // Write result on top of args to avoid allocating extra memory.\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\n            // Overwrite the length.\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\n            mstore(result, mLen)\n            // Set the memory pointer after the returned data.\n            mstore(0x40, add(dataPtr, mLen))\n        }\n    }\n\n    /**\n     * @dev Returns whether the provided byte array is zero.\n     */\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\n        for (uint256 i = 0; i < byteArray.length; ++i) {\n            if (byteArray[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\n     * using integer operations.\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        unchecked {\n            // Take care of easy edge cases when a == 0 or a == 1\n            if (a <= 1) {\n                return a;\n            }\n\n            // In this function, we use Newton's method to get a root of `f(x) := x² - a`. It involves building a\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\n            // the current value as `ε_n = | x_n - sqrt(a) |`.\n            //\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\n            // of the target. (i.e. `2**(e-1) ≤ sqrt(a) < 2**e`). We know that `e ≤ 128` because `(2¹²⁸)² = 2²⁵⁶` is\n            // bigger than any uint256.\n            //\n            // By noticing that\n            // `2**(e-1) ≤ sqrt(a) < 2**e → (2**(e-1))² ≤ a < (2**e)² → 2**(2*e-2) ≤ a < 2**(2*e)`\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\n            // to the msb function.\n            uint256 aa = a;\n            uint256 xn = 1;\n\n            if (aa >= (1 << 128)) {\n                aa >>= 128;\n                xn <<= 64;\n            }\n            if (aa >= (1 << 64)) {\n                aa >>= 64;\n                xn <<= 32;\n            }\n            if (aa >= (1 << 32)) {\n                aa >>= 32;\n                xn <<= 16;\n            }\n            if (aa >= (1 << 16)) {\n                aa >>= 16;\n                xn <<= 8;\n            }\n            if (aa >= (1 << 8)) {\n                aa >>= 8;\n                xn <<= 4;\n            }\n            if (aa >= (1 << 4)) {\n                aa >>= 4;\n                xn <<= 2;\n            }\n            if (aa >= (1 << 2)) {\n                xn <<= 1;\n            }\n\n            // We now have x_n such that `x_n = 2**(e-1) ≤ sqrt(a) < 2**e = 2 * x_n`. This implies ε_n ≤ 2**(e-1).\n            //\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to ε_n ≤ 2**(e-2).\n            // This is going to be our x_0 (and ε_0)\n            xn = (3 * xn) >> 1; // ε_0 := | x_0 - sqrt(a) | ≤ 2**(e-2)\n\n            // From here, Newton's method give us:\n            // x_{n+1} = (x_n + a / x_n) / 2\n            //\n            // One should note that:\n            // x_{n+1}² - a = ((x_n + a / x_n) / 2)² - a\n            //              = ((x_n² + a) / (2 * x_n))² - a\n            //              = (x_n⁴ + 2 * a * x_n² + a²) / (4 * x_n²) - a\n            //              = (x_n⁴ + 2 * a * x_n² + a² - 4 * a * x_n²) / (4 * x_n²)\n            //              = (x_n⁴ - 2 * a * x_n² + a²) / (4 * x_n²)\n            //              = (x_n² - a)² / (2 * x_n)²\n            //              = ((x_n² - a) / (2 * x_n))²\n            //              ≥ 0\n            // Which proves that for all n ≥ 1, sqrt(a) ≤ x_n\n            //\n            // This gives us the proof of quadratic convergence of the sequence:\n            // ε_{n+1} = | x_{n+1} - sqrt(a) |\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\n            //         = | (x_n² + a - 2*x_n*sqrt(a)) / (2 * x_n) |\n            //         = | (x_n - sqrt(a))² / (2 * x_n) |\n            //         = | ε_n² / (2 * x_n) |\n            //         = ε_n² / | (2 * x_n) |\n            //\n            // For the first iteration, we have a special case where x_0 is known:\n            // ε_1 = ε_0² / | (2 * x_0) |\n            //     ≤ (2**(e-2))² / (2 * (2**(e-1) + 2**(e-2)))\n            //     ≤ 2**(2*e-4) / (3 * 2**(e-1))\n            //     ≤ 2**(e-3) / 3\n            //     ≤ 2**(e-3-log2(3))\n            //     ≤ 2**(e-4.5)\n            //\n            // For the following iterations, we use the fact that, 2**(e-1) ≤ sqrt(a) ≤ x_n:\n            // ε_{n+1} = ε_n² / | (2 * x_n) |\n            //         ≤ (2**(e-k))² / (2 * 2**(e-1))\n            //         ≤ 2**(2*e-2*k) / 2**e\n            //         ≤ 2**(e-2*k)\n            xn = (xn + a / xn) >> 1; // ε_1 := | x_1 - sqrt(a) | ≤ 2**(e-4.5)  -- special case, see above\n            xn = (xn + a / xn) >> 1; // ε_2 := | x_2 - sqrt(a) | ≤ 2**(e-9)    -- general case with k = 4.5\n            xn = (xn + a / xn) >> 1; // ε_3 := | x_3 - sqrt(a) | ≤ 2**(e-18)   -- general case with k = 9\n            xn = (xn + a / xn) >> 1; // ε_4 := | x_4 - sqrt(a) | ≤ 2**(e-36)   -- general case with k = 18\n            xn = (xn + a / xn) >> 1; // ε_5 := | x_5 - sqrt(a) | ≤ 2**(e-72)   -- general case with k = 36\n            xn = (xn + a / xn) >> 1; // ε_6 := | x_6 - sqrt(a) | ≤ 2**(e-144)  -- general case with k = 72\n\n            // Because e ≤ 128 (as discussed during the first estimation phase), we know have reached a precision\n            // ε_6 ≤ 2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\n            // sqrt(a) or sqrt(a) + 1.\n            return xn - SafeCast.toUint(xn > a / xn);\n        }\n    }\n\n    /**\n     * @dev Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        uint256 exp;\n        unchecked {\n            exp = 128 * SafeCast.toUint(value > (1 << 128) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 64 * SafeCast.toUint(value > (1 << 64) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 32 * SafeCast.toUint(value > (1 << 32) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 16 * SafeCast.toUint(value > (1 << 16) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 8 * SafeCast.toUint(value > (1 << 8) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 4 * SafeCast.toUint(value > (1 << 4) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 2 * SafeCast.toUint(value > (1 << 2) - 1);\n            value >>= exp;\n            result += exp;\n\n            result += SafeCast.toUint(value > 1);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        uint256 isGt;\n        unchecked {\n            isGt = SafeCast.toUint(value > (1 << 128) - 1);\n            value >>= isGt * 128;\n            result += isGt * 16;\n\n            isGt = SafeCast.toUint(value > (1 << 64) - 1);\n            value >>= isGt * 64;\n            result += isGt * 8;\n\n            isGt = SafeCast.toUint(value > (1 << 32) - 1);\n            value >>= isGt * 32;\n            result += isGt * 4;\n\n            isGt = SafeCast.toUint(value > (1 << 16) - 1);\n            value >>= isGt * 16;\n            result += isGt * 2;\n\n            result += SafeCast.toUint(value > (1 << 8) - 1);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        assembly (\"memory-safe\") {\n            u := iszero(iszero(b))\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Panic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library for emitting standardized panic codes.\n *\n * ```solidity\n * contract Example {\n *      using Panic for uint256;\n *\n *      // Use any of the declared internal constants\n *      function foo() { Panic.GENERIC.panic(); }\n *\n *      // Alternatively\n *      function foo() { Panic.panic(Panic.GENERIC); }\n * }\n * ```\n *\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\n *\n * _Available since v5.1._\n */\n// slither-disable-next-line unused-state\nlibrary Panic {\n    /// @dev generic / unspecified error\n    uint256 internal constant GENERIC = 0x00;\n    /// @dev used by the assert() builtin\n    uint256 internal constant ASSERT = 0x01;\n    /// @dev arithmetic underflow or overflow\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\n    /// @dev division or modulo by zero\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\n    /// @dev enum conversion error\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\n    /// @dev invalid encoding in storage\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\n    /// @dev empty array pop\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\n    /// @dev array out of bounds access\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    /// @dev resource error (too large allocation or too large array)\n    uint256 internal constant RESOURCE_ERROR = 0x41;\n    /// @dev calling invalid internal function\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\n\n    /// @dev Reverts with a panic code. Recommended to use with\n    /// the internal constants with predefined codes.\n    function panic(uint256 code) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0x4e487b71)\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/SlotDerivation.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/SlotDerivation.sol)\n// This file was procedurally generated from scripts/generate/templates/SlotDerivation.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for computing storage (and transient storage) locations from namespaces and deriving slots\n * corresponding to standard patterns. The derivation method for array and mapping matches the storage layout used by\n * the solidity language / compiler.\n *\n * See https://docs.soliditylang.org/en/v0.8.20/internals/layout_in_storage.html#mappings-and-dynamic-arrays[Solidity docs for mappings and dynamic arrays.].\n *\n * Example usage:\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using StorageSlot for bytes32;\n *     using SlotDerivation for bytes32;\n *\n *     // Declare a namespace\n *     string private constant _NAMESPACE = \"<namespace>\" // eg. OpenZeppelin.Slot\n *\n *     function setValueInNamespace(uint256 key, address newValue) internal {\n *         _NAMESPACE.erc7201Slot().deriveMapping(key).getAddressSlot().value = newValue;\n *     }\n *\n *     function getValueInNamespace(uint256 key) internal view returns (address) {\n *         return _NAMESPACE.erc7201Slot().deriveMapping(key).getAddressSlot().value;\n *     }\n * }\n * ```\n *\n * TIP: Consider using this library along with {StorageSlot}.\n *\n * NOTE: This library provides a way to manipulate storage locations in a non-standard way. Tooling for checking\n * upgrade safety will ignore the slots accessed through this library.\n *\n * _Available since v5.1._\n */\nlibrary SlotDerivation {\n    /**\n     * @dev Derive an ERC-7201 slot from a string (namespace).\n     */\n    function erc7201Slot(string memory namespace) internal pure returns (bytes32 slot) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, sub(keccak256(add(namespace, 0x20), mload(namespace)), 1))\n            slot := and(keccak256(0x00, 0x20), not(0xff))\n        }\n    }\n\n    /**\n     * @dev Add an offset to a slot to get the n-th element of a structure or an array.\n     */\n    function offset(bytes32 slot, uint256 pos) internal pure returns (bytes32 result) {\n        unchecked {\n            return bytes32(uint256(slot) + pos);\n        }\n    }\n\n    /**\n     * @dev Derive the location of the first element in an array from the slot where the length is stored.\n     */\n    function deriveArray(bytes32 slot) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, slot)\n            result := keccak256(0x00, 0x20)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, address key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, and(key, shr(96, not(0))))\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, bool key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, iszero(iszero(key)))\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, bytes32 key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, key)\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, uint256 key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, key)\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, int256 key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, key)\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, string memory key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            let length := mload(key)\n            let begin := add(key, 0x20)\n            let end := add(begin, length)\n            let cache := mload(end)\n            mstore(end, slot)\n            result := keccak256(begin, add(length, 0x20))\n            mstore(end, cache)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, bytes memory key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            let length := mload(key)\n            let begin := add(key, 0x20)\n            let end := add(begin, length)\n            let cache := mload(end)\n            mstore(end, slot)\n            result := keccak256(begin, add(length, 0x20))\n            mstore(end, cache)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC-1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     // Define the slot. Alternatively, use the SlotDerivation library to derive the slot.\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * TIP: Consider using this library along with {SlotDerivation}.\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct Int256Slot {\n        int256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Int256Slot` with member `value` located at `slot`.\n     */\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns a `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "base64-sol/base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n/// @title Base64\n/// @author Brecht Devos - <brecht@loopring.org>\n/// @notice Provides functions for encoding/decoding base64\nlibrary Base64 {\n    string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    bytes  internal constant TABLE_DECODE = hex\"0000000000000000000000000000000000000000000000000000000000000000\"\n                                            hex\"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000\"\n                                            hex\"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000\"\n                                            hex\"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000\";\n\n    function encode(bytes memory data) internal pure returns (string memory) {\n        if (data.length == 0) return '';\n\n        // load the table into memory\n        string memory table = TABLE_ENCODE;\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n\n        // add some extra buffer at the end required for the writing\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            // set the actual output length\n            mstore(result, encodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 3 bytes at a time\n            for {} lt(dataPtr, endPtr) {}\n            {\n                // read 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // write 4 characters\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))\n                resultPtr := add(resultPtr, 1)\n            }\n\n            // padding with '='\n            switch mod(mload(data), 3)\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\n        }\n\n        return result;\n    }\n\n    function decode(string memory _data) internal pure returns (bytes memory) {\n        bytes memory data = bytes(_data);\n\n        if (data.length == 0) return new bytes(0);\n        require(data.length % 4 == 0, \"invalid base64 decoder input\");\n\n        // load the table into memory\n        bytes memory table = TABLE_DECODE;\n\n        // every 4 characters represent 3 bytes\n        uint256 decodedLen = (data.length / 4) * 3;\n\n        // add some extra buffer at the end required for the writing\n        bytes memory result = new bytes(decodedLen + 32);\n\n        assembly {\n            // padding with '='\n            let lastBytes := mload(add(data, mload(data)))\n            if eq(and(lastBytes, 0xFF), 0x3d) {\n                decodedLen := sub(decodedLen, 1)\n                if eq(and(lastBytes, 0xFFFF), 0x3d3d) {\n                    decodedLen := sub(decodedLen, 1)\n                }\n            }\n\n            // set the actual output length\n            mstore(result, decodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 4 characters at a time\n            for {} lt(dataPtr, endPtr) {}\n            {\n               // read 4 characters\n               dataPtr := add(dataPtr, 4)\n               let input := mload(dataPtr)\n\n               // write 3 bytes\n               let output := add(\n                   add(\n                       shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\n                       shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),\n                   add(\n                       shl( 6, and(mload(add(tablePtr, and(shr( 8, input), 0xFF))), 0xFF)),\n                               and(mload(add(tablePtr, and(        input , 0xFF))), 0xFF)\n                    )\n                )\n                mstore(resultPtr, shl(232, output))\n                resultPtr := add(resultPtr, 3)\n            }\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/depends/canonical-weth/WETH9.sol": {
      "content": "// Copyright (C) 2015, 2016, 2017 Dapphub\n// SPDX-License-Identifier: GPL-3.0-or-later\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.4.22;\n\ncontract WETH9 {\n    string public name     = \"Wrapped Ether\";\n    string public symbol   = \"WETH\";\n    uint8  public decimals = 18;\n\n    event  Approval(address indexed src, address indexed guy, uint wad);\n    event  Transfer(address indexed src, address indexed dst, uint wad);\n    event  Deposit(address indexed dst, uint wad);\n    event  Withdrawal(address indexed src, uint wad);\n\n    mapping (address => uint)                       public  balanceOf;\n    mapping (address => mapping (address => uint))  public  allowance;\n\n    receive() external payable {\n        deposit();\n    }\n    function deposit() public payable {\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n    function withdraw(uint wad) public {\n        require(balanceOf[msg.sender] >= wad);\n        balanceOf[msg.sender] -= wad;\n        payable(msg.sender).transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    }\n\n    function totalSupply() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function approve(address guy, uint wad) public returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    }\n\n    function transfer(address dst, uint wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(address src, address dst, uint wad)\n        public\n        returns (bool)\n    {\n        require(balanceOf[src] >= wad);\n\n        if (src != msg.sender && allowance[src][msg.sender] != type(uint256).max) {\n            require(allowance[src][msg.sender] >= wad);\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n}\n\n\n/*\n                    GNU GENERAL PUBLIC LICENSE\n                       Version 3, 29 June 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The GNU General Public License is a free, copyleft license for\nsoftware and other kinds of works.\n\n  The licenses for most software and other practical works are designed\nto take away your freedom to share and change the works.  By contrast,\nthe GNU General Public License is intended to guarantee your freedom to\nshare and change all versions of a program--to make sure it remains free\nsoftware for all its users.  We, the Free Software Foundation, use the\nGNU General Public License for most of our software; it applies also to\nany other work released this way by its authors.  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthem if you wish), that you receive source code or can get it if you\nwant it, that you can change the software or use pieces of it in new\nfree programs, and that you know you can do these things.\n\n  To protect your rights, we need to prevent others from denying you\nthese rights or asking you to surrender the rights.  Therefore, you have\ncertain responsibilities if you distribute copies of the software, or if\nyou modify it: responsibilities to respect the freedom of others.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must pass on to the recipients the same\nfreedoms that you received.  You must make sure that they, too, receive\nor can get the source code.  And you must show them these terms so they\nknow their rights.\n\n  Developers that use the GNU GPL protect your rights with two steps:\n(1) assert copyright on the software, and (2) offer you this License\ngiving you legal permission to copy, distribute and/or modify it.\n\n  For the developers' and authors' protection, the GPL clearly explains\nthat there is no warranty for this free software.  For both users' and\nauthors' sake, the GPL requires that modified versions be marked as\nchanged, so that their problems will not be attributed erroneously to\nauthors of previous versions.\n\n  Some devices are designed to deny users access to install or run\nmodified versions of the software inside them, although the manufacturer\ncan do so.  This is fundamentally incompatible with the aim of\nprotecting users' freedom to change the software.  The systematic\npattern of such abuse occurs in the area of products for individuals to\nuse, which is precisely where it is most unacceptable.  Therefore, we\nhave designed this version of the GPL to prohibit the practice for those\nproducts.  If such problems arise substantially in other domains, we\nstand ready to extend this provision to those domains in future versions\nof the GPL, as needed to protect the freedom of users.\n\n  Finally, every program is threatened constantly by software patents.\nStates should not allow patents to restrict development and use of\nsoftware on general-purpose computers, but in those that do, we wish to\navoid the special danger that patents applied to a free program could\nmake it effectively proprietary.  To prevent this, the GPL assures that\npatents cannot be used to render the program non-free.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                       TERMS AND CONDITIONS\n\n  0. Definitions.\n\n  \"This License\" refers to version 3 of the GNU General Public License.\n\n  \"Copyright\" also means copyright-like laws that apply to other kinds of\nworks, such as semiconductor masks.\n\n  \"The Program\" refers to any copyrightable work licensed under this\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\n\"recipients\" may be individuals or organizations.\n\n  To \"modify\" a work means to copy from or adapt all or part of the work\nin a fashion requiring copyright permission, other than the making of an\nexact copy.  The resulting work is called a \"modified version\" of the\nearlier work or a work \"based on\" the earlier work.\n\n  A \"covered work\" means either the unmodified Program or a work based\non the Program.\n\n  To \"propagate\" a work means to do anything with it that, without\npermission, would make you directly or secondarily liable for\ninfringement under applicable copyright law, except executing it on a\ncomputer or modifying a private copy.  Propagation includes copying,\ndistribution (with or without modification), making available to the\npublic, and in some countries other activities as well.\n\n  To \"convey\" a work means any kind of propagation that enables other\nparties to make or receive copies.  Mere interaction with a user through\na computer network, with no transfer of a copy, is not conveying.\n\n  An interactive user interface displays \"Appropriate Legal Notices\"\nto the extent that it includes a convenient and prominently visible\nfeature that (1) displays an appropriate copyright notice, and (2)\ntells the user that there is no warranty for the work (except to the\nextent that warranties are provided), that licensees may convey the\nwork under this License, and how to view a copy of this License.  If\nthe interface presents a list of user commands or options, such as a\nmenu, a prominent item in the list meets this criterion.\n\n  1. Source Code.\n\n  The \"source code\" for a work means the preferred form of the work\nfor making modifications to it.  \"Object code\" means any non-source\nform of a work.\n\n  A \"Standard Interface\" means an interface that either is an official\nstandard defined by a recognized standards body, or, in the case of\ninterfaces specified for a particular programming language, one that\nis widely used among developers working in that language.\n\n  The \"System Libraries\" of an executable work include anything, other\nthan the work as a whole, that (a) is included in the normal form of\npackaging a Major Component, but which is not part of that Major\nComponent, and (b) serves only to enable use of the work with that\nMajor Component, or to implement a Standard Interface for which an\nimplementation is available to the public in source code form.  A\n\"Major Component\", in this context, means a major essential component\n(kernel, window system, and so on) of the specific operating system\n(if any) on which the executable work runs, or a compiler used to\nproduce the work, or an object code interpreter used to run it.\n\n  The \"Corresponding Source\" for a work in object code form means all\nthe source code needed to generate, install, and (for an executable\nwork) run the object code and to modify the work, including scripts to\ncontrol those activities.  However, it does not include the work's\nSystem Libraries, or general-purpose tools or generally available free\nprograms which are used unmodified in performing those activities but\nwhich are not part of the work.  For example, Corresponding Source\nincludes interface definition files associated with source files for\nthe work, and the source code for shared libraries and dynamically\nlinked subprograms that the work is specifically designed to require,\nsuch as by intimate data communication or control flow between those\nsubprograms and other parts of the work.\n\n  The Corresponding Source need not include anything that users\ncan regenerate automatically from other parts of the Corresponding\nSource.\n\n  The Corresponding Source for a work in source code form is that\nsame work.\n\n  2. Basic Permissions.\n\n  All rights granted under this License are granted for the term of\ncopyright on the Program, and are irrevocable provided the stated\nconditions are met.  This License explicitly affirms your unlimited\npermission to run the unmodified Program.  The output from running a\ncovered work is covered by this License only if the output, given its\ncontent, constitutes a covered work.  This License acknowledges your\nrights of fair use or other equivalent, as provided by copyright law.\n\n  You may make, run and propagate covered works that you do not\nconvey, without conditions so long as your license otherwise remains\nin force.  You may convey covered works to others for the sole purpose\nof having them make modifications exclusively for you, or provide you\nwith facilities for running those works, provided that you comply with\nthe terms of this License in conveying all material for which you do\nnot control copyright.  Those thus making or running the covered works\nfor you must do so exclusively on your behalf, under your direction\nand control, on terms that prohibit them from making any copies of\nyour copyrighted material outside their relationship with you.\n\n  Conveying under any other circumstances is permitted solely under\nthe conditions stated below.  Sublicensing is not allowed; section 10\nmakes it unnecessary.\n\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\n\n  No covered work shall be deemed part of an effective technological\nmeasure under any applicable law fulfilling obligations under article\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\nsimilar laws prohibiting or restricting circumvention of such\nmeasures.\n\n  When you convey a covered work, you waive any legal power to forbid\ncircumvention of technological measures to the extent such circumvention\nis effected by exercising rights under this License with respect to\nthe covered work, and you disclaim any intention to limit operation or\nmodification of the work as a means of enforcing, against the work's\nusers, your or third parties' legal rights to forbid circumvention of\ntechnological measures.\n\n  4. Conveying Verbatim Copies.\n\n  You may convey verbatim copies of the Program's source code as you\nreceive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice;\nkeep intact all notices stating that this License and any\nnon-permissive terms added in accord with section 7 apply to the code;\nkeep intact all notices of the absence of any warranty; and give all\nrecipients a copy of this License along with the Program.\n\n  You may charge any price or no price for each copy that you convey,\nand you may offer support or warranty protection for a fee.\n\n  5. Conveying Modified Source Versions.\n\n  You may convey a work based on the Program, or the modifications to\nproduce it from the Program, in the form of source code under the\nterms of section 4, provided that you also meet all of these conditions:\n\n    a) The work must carry prominent notices stating that you modified\n    it, and giving a relevant date.\n\n    b) The work must carry prominent notices stating that it is\n    released under this License and any conditions added under section\n    7.  This requirement modifies the requirement in section 4 to\n    \"keep intact all notices\".\n\n    c) You must license the entire work, as a whole, under this\n    License to anyone who comes into possession of a copy.  This\n    License will therefore apply, along with any applicable section 7\n    additional terms, to the whole of the work, and all its parts,\n    regardless of how they are packaged.  This License gives no\n    permission to license the work in any other way, but it does not\n    invalidate such permission if you have separately received it.\n\n    d) If the work has interactive user interfaces, each must display\n    Appropriate Legal Notices; however, if the Program has interactive\n    interfaces that do not display Appropriate Legal Notices, your\n    work need not make them do so.\n\n  A compilation of a covered work with other separate and independent\nworks, which are not by their nature extensions of the covered work,\nand which are not combined with it such as to form a larger program,\nin or on a volume of a storage or distribution medium, is called an\n\"aggregate\" if the compilation and its resulting copyright are not\nused to limit the access or legal rights of the compilation's users\nbeyond what the individual works permit.  Inclusion of a covered work\nin an aggregate does not cause this License to apply to the other\nparts of the aggregate.\n\n  6. Conveying Non-Source Forms.\n\n  You may convey a covered work in object code form under the terms\nof sections 4 and 5, provided that you also convey the\nmachine-readable Corresponding Source under the terms of this License,\nin one of these ways:\n\n    a) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by the\n    Corresponding Source fixed on a durable physical medium\n    customarily used for software interchange.\n\n    b) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by a\n    written offer, valid for at least three years and valid for as\n    long as you offer spare parts or customer support for that product\n    model, to give anyone who possesses the object code either (1) a\n    copy of the Corresponding Source for all the software in the\n    product that is covered by this License, on a durable physical\n    medium customarily used for software interchange, for a price no\n    more than your reasonable cost of physically performing this\n    conveying of source, or (2) access to copy the\n    Corresponding Source from a network server at no charge.\n\n    c) Convey individual copies of the object code with a copy of the\n    written offer to provide the Corresponding Source.  This\n    alternative is allowed only occasionally and noncommercially, and\n    only if you received the object code with such an offer, in accord\n    with subsection 6b.\n\n    d) Convey the object code by offering access from a designated\n    place (gratis or for a charge), and offer equivalent access to the\n    Corresponding Source in the same way through the same place at no\n    further charge.  You need not require recipients to copy the\n    Corresponding Source along with the object code.  If the place to\n    copy the object code is a network server, the Corresponding Source\n    may be on a different server (operated by you or a third party)\n    that supports equivalent copying facilities, provided you maintain\n    clear directions next to the object code saying where to find the\n    Corresponding Source.  Regardless of what server hosts the\n    Corresponding Source, you remain obligated to ensure that it is\n    available for as long as needed to satisfy these requirements.\n\n    e) Convey the object code using peer-to-peer transmission, provided\n    you inform other peers where the object code and Corresponding\n    Source of the work are being offered to the general public at no\n    charge under subsection 6d.\n\n  A separable portion of the object code, whose source code is excluded\nfrom the Corresponding Source as a System Library, need not be\nincluded in conveying the object code work.\n\n  A \"User Product\" is either (1) a \"consumer product\", which means any\ntangible personal property which is normally used for personal, family,\nor household purposes, or (2) anything designed or sold for incorporation\ninto a dwelling.  In determining whether a product is a consumer product,\ndoubtful cases shall be resolved in favor of coverage.  For a particular\nproduct received by a particular user, \"normally used\" refers to a\ntypical or common use of that class of product, regardless of the status\nof the particular user or of the way in which the particular user\nactually uses, or expects or is expected to use, the product.  A product\nis a consumer product regardless of whether the product has substantial\ncommercial, industrial or non-consumer uses, unless such uses represent\nthe only significant mode of use of the product.\n\n  \"Installation Information\" for a User Product means any methods,\nprocedures, authorization keys, or other information required to install\nand execute modified versions of a covered work in that User Product from\na modified version of its Corresponding Source.  The information must\nsuffice to ensure that the continued functioning of the modified object\ncode is in no case prevented or interfered with solely because\nmodification has been made.\n\n  If you convey an object code work under this section in, or with, or\nspecifically for use in, a User Product, and the conveying occurs as\npart of a transaction in which the right of possession and use of the\nUser Product is transferred to the recipient in perpetuity or for a\nfixed term (regardless of how the transaction is characterized), the\nCorresponding Source conveyed under this section must be accompanied\nby the Installation Information.  But this requirement does not apply\nif neither you nor any third party retains the ability to install\nmodified object code on the User Product (for example, the work has\nbeen installed in ROM).\n\n  The requirement to provide Installation Information does not include a\nrequirement to continue to provide support service, warranty, or updates\nfor a work that has been modified or installed by the recipient, or for\nthe User Product in which it has been modified or installed.  Access to a\nnetwork may be denied when the modification itself materially and\nadversely affects the operation of the network or violates the rules and\nprotocols for communication across the network.\n\n  Corresponding Source conveyed, and Installation Information provided,\nin accord with this section must be in a format that is publicly\ndocumented (and with an implementation available to the public in\nsource code form), and must require no special password or key for\nunpacking, reading or copying.\n\n  7. Additional Terms.\n\n  \"Additional permissions\" are terms that supplement the terms of this\nLicense by making exceptions from one or more of its conditions.\nAdditional permissions that are applicable to the entire Program shall\nbe treated as though they were included in this License, to the extent\nthat they are valid under applicable law.  If additional permissions\napply only to part of the Program, that part may be used separately\nunder those permissions, but the entire Program remains governed by\nthis License without regard to the additional permissions.\n\n  When you convey a copy of a covered work, you may at your option\nremove any additional permissions from that copy, or from any part of\nit.  (Additional permissions may be written to require their own\nremoval in certain cases when you modify the work.)  You may place\nadditional permissions on material, added by you to a covered work,\nfor which you have or can give appropriate copyright permission.\n\n  Notwithstanding any other provision of this License, for material you\nadd to a covered work, you may (if authorized by the copyright holders of\nthat material) supplement the terms of this License with terms:\n\n    a) Disclaiming warranty or limiting liability differently from the\n    terms of sections 15 and 16 of this License; or\n\n    b) Requiring preservation of specified reasonable legal notices or\n    author attributions in that material or in the Appropriate Legal\n    Notices displayed by works containing it; or\n\n    c) Prohibiting misrepresentation of the origin of that material, or\n    requiring that modified versions of such material be marked in\n    reasonable ways as different from the original version; or\n\n    d) Limiting the use for publicity purposes of names of licensors or\n    authors of the material; or\n\n    e) Declining to grant rights under trademark law for use of some\n    trade names, trademarks, or service marks; or\n\n    f) Requiring indemnification of licensors and authors of that\n    material by anyone who conveys the material (or modified versions of\n    it) with contractual assumptions of liability to the recipient, for\n    any liability that these contractual assumptions directly impose on\n    those licensors and authors.\n\n  All other non-permissive additional terms are considered \"further\nrestrictions\" within the meaning of section 10.  If the Program as you\nreceived it, or any part of it, contains a notice stating that it is\ngoverned by this License along with a term that is a further\nrestriction, you may remove that term.  If a license document contains\na further restriction but permits relicensing or conveying under this\nLicense, you may add to a covered work material governed by the terms\nof that license document, provided that the further restriction does\nnot survive such relicensing or conveying.\n\n  If you add terms to a covered work in accord with this section, you\nmust place, in the relevant source files, a statement of the\nadditional terms that apply to those files, or a notice indicating\nwhere to find the applicable terms.\n\n  Additional terms, permissive or non-permissive, may be stated in the\nform of a separately written license, or stated as exceptions;\nthe above requirements apply either way.\n\n  8. Termination.\n\n  You may not propagate or modify a covered work except as expressly\nprovided under this License.  Any attempt otherwise to propagate or\nmodify it is void, and will automatically terminate your rights under\nthis License (including any patent licenses granted under the third\nparagraph of section 11).\n\n  However, if you cease all violation of this License, then your\nlicense from a particular copyright holder is reinstated (a)\nprovisionally, unless and until the copyright holder explicitly and\nfinally terminates your license, and (b) permanently, if the copyright\nholder fails to notify you of the violation by some reasonable means\nprior to 60 days after the cessation.\n\n  Moreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.\n\n  Termination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License.  If your rights have been terminated and not permanently\nreinstated, you do not qualify to receive new licenses for the same\nmaterial under section 10.\n\n  9. Acceptance Not Required for Having Copies.\n\n  You are not required to accept this License in order to receive or\nrun a copy of the Program.  Ancillary propagation of a covered work\noccurring solely as a consequence of using peer-to-peer transmission\nto receive a copy likewise does not require acceptance.  However,\nnothing other than this License grants you permission to propagate or\nmodify any covered work.  These actions infringe copyright if you do\nnot accept this License.  Therefore, by modifying or propagating a\ncovered work, you indicate your acceptance of this License to do so.\n\n  10. Automatic Licensing of Downstream Recipients.\n\n  Each time you convey a covered work, the recipient automatically\nreceives a license from the original licensors, to run, modify and\npropagate that work, subject to this License.  You are not responsible\nfor enforcing compliance by third parties with this License.\n\n  An \"entity transaction\" is a transaction transferring control of an\norganization, or substantially all assets of one, or subdividing an\norganization, or merging organizations.  If propagation of a covered\nwork results from an entity transaction, each party to that\ntransaction who receives a copy of the work also receives whatever\nlicenses to the work the party's predecessor in interest had or could\ngive under the previous paragraph, plus a right to possession of the\nCorresponding Source of the work from the predecessor in interest, if\nthe predecessor has it or can get it with reasonable efforts.\n\n  You may not impose any further restrictions on the exercise of the\nrights granted or affirmed under this License.  For example, you may\nnot impose a license fee, royalty, or other charge for exercise of\nrights granted under this License, and you may not initiate litigation\n(including a cross-claim or counterclaim in a lawsuit) alleging that\nany patent claim is infringed by making, using, selling, offering for\nsale, or importing the Program or any portion of it.\n\n  11. Patents.\n\n  A \"contributor\" is a copyright holder who authorizes use under this\nLicense of the Program or a work on which the Program is based.  The\nwork thus licensed is called the contributor's \"contributor version\".\n\n  A contributor's \"essential patent claims\" are all patent claims\nowned or controlled by the contributor, whether already acquired or\nhereafter acquired, that would be infringed by some manner, permitted\nby this License, of making, using, or selling its contributor version,\nbut do not include claims that would be infringed only as a\nconsequence of further modification of the contributor version.  For\npurposes of this definition, \"control\" includes the right to grant\npatent sublicenses in a manner consistent with the requirements of\nthis License.\n\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\npatent license under the contributor's essential patent claims, to\nmake, use, sell, offer for sale, import and otherwise run, modify and\npropagate the contents of its contributor version.\n\n  In the following three paragraphs, a \"patent license\" is any express\nagreement or commitment, however denominated, not to enforce a patent\n(such as an express permission to practice a patent or covenant not to\nsue for patent infringement).  To \"grant\" such a patent license to a\nparty means to make such an agreement or commitment not to enforce a\npatent against the party.\n\n  If you convey a covered work, knowingly relying on a patent license,\nand the Corresponding Source of the work is not available for anyone\nto copy, free of charge and under the terms of this License, through a\npublicly available network server or other readily accessible means,\nthen you must either (1) cause the Corresponding Source to be so\navailable, or (2) arrange to deprive yourself of the benefit of the\npatent license for this particular work, or (3) arrange, in a manner\nconsistent with the requirements of this License, to extend the patent\nlicense to downstream recipients.  \"Knowingly relying\" means you have\nactual knowledge that, but for the patent license, your conveying the\ncovered work in a country, or your recipient's use of the covered work\nin a country, would infringe one or more identifiable patents in that\ncountry that you have reason to believe are valid.\n\n  If, pursuant to or in connection with a single transaction or\narrangement, you convey, or propagate by procuring conveyance of, a\ncovered work, and grant a patent license to some of the parties\nreceiving the covered work authorizing them to use, propagate, modify\nor convey a specific copy of the covered work, then the patent license\nyou grant is automatically extended to all recipients of the covered\nwork and works based on it.\n\n  A patent license is \"discriminatory\" if it does not include within\nthe scope of its coverage, prohibits the exercise of, or is\nconditioned on the non-exercise of one or more of the rights that are\nspecifically granted under this License.  You may not convey a covered\nwork if you are a party to an arrangement with a third party that is\nin the business of distributing software, under which you make payment\nto the third party based on the extent of your activity of conveying\nthe work, and under which the third party grants, to any of the\nparties who would receive the covered work from you, a discriminatory\npatent license (a) in connection with copies of the covered work\nconveyed by you (or copies made from those copies), or (b) primarily\nfor and in connection with specific products or compilations that\ncontain the covered work, unless you entered into that arrangement,\nor that patent license was granted, prior to 28 March 2007.\n\n  Nothing in this License shall be construed as excluding or limiting\nany implied license or other defenses to infringement that may\notherwise be available to you under applicable patent law.\n\n  12. No Surrender of Others' Freedom.\n\n  If conditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot convey a\ncovered work so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you may\nnot convey it at all.  For example, if you agree to terms that obligate you\nto collect a royalty for further conveying from those to whom you convey\nthe Program, the only way you could satisfy both those terms and this\nLicense would be to refrain entirely from conveying the Program.\n\n  13. Use with the GNU Affero General Public License.\n\n  Notwithstanding any other provision of this License, you have\npermission to link or combine any covered work with a work licensed\nunder version 3 of the GNU Affero General Public License into a single\ncombined work, and to convey the resulting work.  The terms of this\nLicense will continue to apply to the part which is the covered work,\nbut the special requirements of the GNU Affero General Public License,\nsection 13, concerning interaction through a network will apply to the\ncombination as such.\n\n  14. Revised Versions of this License.\n\n  The Free Software Foundation may publish revised and/or new versions of\nthe GNU General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\n  Each version is given a distinguishing version number.  If the\nProgram specifies that a certain numbered version of the GNU General\nPublic License \"or any later version\" applies to it, you have the\noption of following the terms and conditions either of that numbered\nversion or of any later version published by the Free Software\nFoundation.  If the Program does not specify a version number of the\nGNU General Public License, you may choose any version ever published\nby the Free Software Foundation.\n\n  If the Program specifies that a proxy can decide which future\nversions of the GNU General Public License can be used, that proxy's\npublic statement of acceptance of a version permanently authorizes you\nto choose that version for the Program.\n\n  Later license versions may give you additional or different\npermissions.  However, no additional obligations are imposed on any\nauthor or copyright holder as a result of your choosing to follow a\nlater version.\n\n  15. Disclaimer of Warranty.\n\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. Limitation of Liability.\n\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGES.\n\n  17. Interpretation of Sections 15 and 16.\n\n  If the disclaimer of warranty and limitation of liability provided\nabove cannot be given local legal effect according to their terms,\nreviewing courts shall apply local law that most closely approximates\nan absolute waiver of all civil liability in connection with the\nProgram, unless a warranty or assumption of liability accompanies a\ncopy of the Program in return for a fee.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nstate the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nAlso add information on how to contact you by electronic and paper mail.\n\n  If the program does terminal interaction, make it output a short\nnotice like this when it starts in an interactive mode:\n\n    <program>  Copyright (C) <year>  <name of author>\n    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, your program's commands\nmight be different; for a GUI interface, you would use an \"about box\".\n\n  You should also get your employer (if you work as a programmer) or school,\nif any, to sign a \"copyright disclaimer\" for the program, if necessary.\nFor more information on this, and how to apply and follow the GNU GPL, see\n<http://www.gnu.org/licenses/>.\n\n  The GNU General Public License does not permit incorporating your program\ninto proprietary programs.  If your program is a subroutine library, you\nmay consider it more useful to permit linking proprietary applications with\nthe library.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.  But first, please read\n<http://www.gnu.org/philosophy/why-not-lgpl.html>.\n\n*/"
    },
    "contracts/depends/uniswap-lib/libraries/AddressStringUtil.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.5.0;\n\nlibrary AddressStringUtil {\n    // converts an address to the uppercase hex string, extracting only len bytes (up to 20, multiple of 2)\n    function toAsciiString(address addr, uint256 len) internal pure returns (string memory) {\n        require(len % 2 == 0 && len > 0 && len <= 40, 'AddressStringUtil: INVALID_LEN');\n\n        bytes memory s = new bytes(len);\n        uint256 addrNum = uint256(uint160(addr));\n        for (uint256 i = 0; i < len / 2; i++) {\n            // shift right and truncate all but the least significant byte to extract the byte at position 19-i\n            uint8 b = uint8(addrNum >> (8 * (19 - i)));\n            // first hex character is the most significant 4 bits\n            uint8 hi = b >> 4;\n            // second hex character is the least significant 4 bits\n            uint8 lo = b - (hi << 4);\n            s[2 * i] = char(hi);\n            s[2 * i + 1] = char(lo);\n        }\n        return string(s);\n    }\n\n    // hi and lo are only 4 bits and between 0 and 16\n    // this method converts those values to the unicode/ascii code point for the hex representation\n    // uses upper case for the characters\n    function char(uint8 b) private pure returns (bytes1 c) {\n        if (b < 10) {\n            return bytes1(b + 0x30);\n        } else {\n            return bytes1(b + 0x37);\n        }\n    }\n}\n"
    },
    "contracts/depends/uniswap-lib/libraries/Babylonian.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.4.0;\n\n// computes square roots using the babylonian method\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\nlibrary Babylonian {\n    // credit for this implementation goes to\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n    function sqrt(uint256 x) internal pure returns (uint256) {\n        if (x == 0) return 0;\n        // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\n        // however that code costs significantly more gas\n        uint256 xx = x;\n        uint256 r = 1;\n        if (xx >= 0x100000000000000000000000000000000) {\n            xx >>= 128;\n            r <<= 64;\n        }\n        if (xx >= 0x10000000000000000) {\n            xx >>= 64;\n            r <<= 32;\n        }\n        if (xx >= 0x100000000) {\n            xx >>= 32;\n            r <<= 16;\n        }\n        if (xx >= 0x10000) {\n            xx >>= 16;\n            r <<= 8;\n        }\n        if (xx >= 0x100) {\n            xx >>= 8;\n            r <<= 4;\n        }\n        if (xx >= 0x10) {\n            xx >>= 4;\n            r <<= 2;\n        }\n        if (xx >= 0x8) {\n            r <<= 1;\n        }\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1; // Seven iterations should be enough\n        uint256 r1 = x / r;\n        return (r < r1 ? r : r1);\n    }\n}\n"
    },
    "contracts/depends/uniswap-lib/libraries/SafeERC20Namer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.5.0;\n\nimport './AddressStringUtil.sol';\n\n// produces token descriptors from inconsistent or absent ERC20 symbol implementations that can return string or bytes32\n// this library will always produce a string symbol to represent the token\nlibrary SafeERC20Namer {\n    function bytes32ToString(bytes32 x) private pure returns (string memory) {\n        bytes memory bytesString = new bytes(32);\n        uint256 charCount = 0;\n        for (uint256 j = 0; j < 32; j++) {\n            bytes1 char = x[j];\n            if (char != 0) {\n                bytesString[charCount] = char;\n                charCount++;\n            }\n        }\n        bytes memory bytesStringTrimmed = new bytes(charCount);\n        for (uint256 j = 0; j < charCount; j++) {\n            bytesStringTrimmed[j] = bytesString[j];\n        }\n        return string(bytesStringTrimmed);\n    }\n\n    // assumes the data is in position 2\n    function parseStringData(bytes memory b) private pure returns (string memory) {\n        uint256 charCount = 0;\n        // first parse the charCount out of the data\n        for (uint256 i = 32; i < 64; i++) {\n            charCount <<= 8;\n            charCount += uint8(b[i]);\n        }\n\n        bytes memory bytesStringTrimmed = new bytes(charCount);\n        for (uint256 i = 0; i < charCount; i++) {\n            bytesStringTrimmed[i] = b[i + 64];\n        }\n\n        return string(bytesStringTrimmed);\n    }\n\n    // uses a heuristic to produce a token name from the address\n    // the heuristic returns the full hex of the address string in upper case\n    function addressToName(address token) private pure returns (string memory) {\n        return AddressStringUtil.toAsciiString(token, 40);\n    }\n\n    // uses a heuristic to produce a token symbol from the address\n    // the heuristic returns the first 6 hex of the address string in upper case\n    function addressToSymbol(address token) private pure returns (string memory) {\n        return AddressStringUtil.toAsciiString(token, 6);\n    }\n\n    // calls an external view token contract method that returns a symbol or name, and parses the output into a string\n    function callAndParseStringReturn(address token, bytes4 selector) private view returns (string memory) {\n        (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(selector));\n        // if not implemented, or returns empty data, return empty string\n        if (!success || data.length == 0) {\n            return '';\n        }\n        // bytes32 data always has length 32\n        if (data.length == 32) {\n            bytes32 decoded = abi.decode(data, (bytes32));\n            return bytes32ToString(decoded);\n        } else if (data.length > 64) {\n            return abi.decode(data, (string));\n        }\n        return '';\n    }\n\n    // attempts to extract the token symbol. if it does not implement symbol, returns a symbol derived from the address\n    function tokenSymbol(address token) internal view returns (string memory) {\n        // 0x95d89b41 = bytes4(keccak256(\"symbol()\"))\n        string memory symbol = callAndParseStringReturn(token, 0x95d89b41);\n        if (bytes(symbol).length == 0) {\n            // fallback to 6 uppercase hex of address\n            return addressToSymbol(token);\n        }\n        return symbol;\n    }\n\n    // attempts to extract the token name. if it does not implement name, returns a name derived from the address\n    function tokenName(address token) internal view returns (string memory) {\n        // 0x06fdde03 = bytes4(keccak256(\"name()\"))\n        string memory name = callAndParseStringReturn(token, 0x06fdde03);\n        if (bytes(name).length == 0) {\n            // fallback to full hex of address\n            return addressToName(token);\n        }\n        return name;\n    }\n}\n"
    },
    "contracts/depends/uniswap-lib/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.6.0;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeApprove: approve failed'\n        );\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeTransfer: transfer failed'\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::transferFrom: transferFrom failed'\n        );\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\n    }\n}\n"
    },
    "contracts/depends/uniswap-v3-core/interfaces/callback/IUniswapV3FlashCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#flash\n/// @notice Any contract that calls IUniswapV3PoolActions#flash must implement this interface\ninterface IUniswapV3FlashCallback {\n    /// @notice Called to `msg.sender` after transferring to the recipient from IUniswapV3Pool#flash.\n    /// @dev In the implementation you must repay the pool the tokens sent by flash plus the computed fee amounts.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// @param fee0 The fee amount in token0 due to the pool by the end of the flash\n    /// @param fee1 The fee amount in token1 due to the pool by the end of the flash\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#flash call\n    function uniswapV3FlashCallback(\n        uint256 fee0,\n        uint256 fee1,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/depends/uniswap-v3-core/interfaces/callback/IUniswapV3MintCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#mint\n/// @notice Any contract that calls IUniswapV3PoolActions#mint must implement this interface\ninterface IUniswapV3MintCallback {\n    /// @notice Called to `msg.sender` after minting liquidity to a position from IUniswapV3Pool#mint.\n    /// @dev In the implementation you must pay the pool tokens owed for the minted liquidity.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// @param amount0Owed The amount of token0 due to the pool for the minted liquidity\n    /// @param amount1Owed The amount of token1 due to the pool for the minted liquidity\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#mint call\n    function uniswapV3MintCallback(\n        uint256 amount0Owed,\n        uint256 amount1Owed,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/depends/uniswap-v3-core/interfaces/callback/IUniswapV3SwapCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/depends/uniswap-v3-core/interfaces/IERC20Minimal.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Minimal ERC20 interface for Uniswap\n/// @notice Contains a subset of the full ERC20 interface that is used in Uniswap V3\ninterface IERC20Minimal {\n    /// @notice Returns the balance of a token\n    /// @param account The account for which to look up the number of tokens it has, i.e. its balance\n    /// @return The number of tokens held by the account\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Transfers the amount of token from the `msg.sender` to the recipient\n    /// @param recipient The account that will receive the amount transferred\n    /// @param amount The number of tokens to send from the sender to the recipient\n    /// @return Returns true for a successful transfer, false for an unsuccessful transfer\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /// @notice Returns the current allowance given to a spender by an owner\n    /// @param owner The account of the token owner\n    /// @param spender The account of the token spender\n    /// @return The current allowance granted by `owner` to `spender`\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /// @notice Sets the allowance of a spender from the `msg.sender` to the value `amount`\n    /// @param spender The account which will be allowed to spend a given amount of the owners tokens\n    /// @param amount The amount of tokens allowed to be used by `spender`\n    /// @return Returns true for a successful approval, false for unsuccessful\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /// @notice Transfers `amount` tokens from `sender` to `recipient` up to the allowance given to the `msg.sender`\n    /// @param sender The account from which the transfer will be initiated\n    /// @param recipient The recipient of the transfer\n    /// @param amount The amount of the transfer\n    /// @return Returns true for a successful transfer, false for unsuccessful\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /// @notice Event emitted when tokens are transferred from one address to another, either via `#transfer` or `#transferFrom`.\n    /// @param from The account from which the tokens were sent, i.e. the balance decreased\n    /// @param to The account to which the tokens were sent, i.e. the balance increased\n    /// @param value The amount of tokens that were transferred\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @notice Event emitted when the approval amount for the spender of a given owner's tokens changes.\n    /// @param owner The account that approved spending of its tokens\n    /// @param spender The account for which the spending allowance was modified\n    /// @param value The new allowance from the owner to the spender\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/depends/uniswap-v3-core/interfaces/IUniswapV3Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title The interface for the Uniswap V3 Factory\n/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees\ninterface IUniswapV3Factory {\n    /// @notice Emitted when the owner of the factory is changed\n    /// @param oldOwner The owner before the owner was changed\n    /// @param newOwner The owner after the owner was changed\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\n\n    /// @notice Emitted when a pool is created\n    /// @param token0 The first token of the pool by address sort order\n    /// @param token1 The second token of the pool by address sort order\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\n    /// @param pool The address of the created pool\n    event PoolCreated(\n        address indexed token0,\n        address indexed token1,\n        uint24 indexed fee,\n        int24 tickSpacing,\n        address pool\n    );\n\n    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory\n    /// @param fee The enabled fee, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee\n    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\n\n    /// @notice Returns the LP pool init code hash\n    /// @return The LP pool init code hash\n    function poolCodeHash() external pure returns (bytes32);\n\n    /// @notice Returns the current owner of the factory\n    /// @dev Can be changed by the current owner via setOwner\n    /// @return The address of the factory owner\n    function owner() external view returns (address);\n\n    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled\n    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\n    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\n    /// @return The tick spacing\n    function feeAmountTickSpacing(uint24 fee) external view returns (int24);\n\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\n    /// @param tokenA The contract address of either token0 or token1\n    /// @param tokenB The contract address of the other token\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @return pool The pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external view returns (address pool);\n\n    /// @notice Creates a pool for the given two tokens and fee\n    /// @param tokenA One of the two tokens in the desired pool\n    /// @param tokenB The other of the two tokens in the desired pool\n    /// @param fee The desired fee for the pool\n    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\n    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\n    /// are invalid.\n    /// @return pool The address of the newly created pool\n    function createPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external returns (address pool);\n\n    /// @notice Updates the owner of the factory\n    /// @dev Must be called by the current owner\n    /// @param _owner The new owner of the factory\n    function setOwner(address _owner) external;\n\n    /// @notice Enables a fee amount with the given tickSpacing\n    /// @dev Fee amounts may never be removed once enabled\n    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)\n    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount\n    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\n}\n"
    },
    "contracts/depends/uniswap-v3-core/interfaces/IUniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nimport './pool/IUniswapV3PoolImmutables.sol';\nimport './pool/IUniswapV3PoolState.sol';\nimport './pool/IUniswapV3PoolDerivedState.sol';\nimport './pool/IUniswapV3PoolActions.sol';\nimport './pool/IUniswapV3PoolOwnerActions.sol';\nimport './pool/IUniswapV3PoolEvents.sol';\n\n/// @title The interface for a Uniswap V3 Pool\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface IUniswapV3Pool is\n    IUniswapV3PoolImmutables,\n    IUniswapV3PoolState,\n    IUniswapV3PoolDerivedState,\n    IUniswapV3PoolActions,\n    IUniswapV3PoolOwnerActions,\n    IUniswapV3PoolEvents\n{\n\n}\n"
    },
    "contracts/depends/uniswap-v3-core/interfaces/IUniswapV3PoolDeployer.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title An interface for a contract that is capable of deploying Uniswap V3 Pools\n/// @notice A contract that constructs a pool must implement this to pass arguments to the pool\n/// @dev This is used to avoid having constructor arguments in the pool contract, which results in the init code hash\n/// of the pool being constant allowing the CREATE2 address of the pool to be cheaply computed on-chain\ninterface IUniswapV3PoolDeployer {\n    /// @notice Get the parameters to be used in constructing the pool, set transiently during pool creation.\n    /// @dev Called by the pool constructor to fetch the parameters of the pool\n    /// Returns factory The factory address\n    /// Returns token0 The first token of the pool by address sort order\n    /// Returns token1 The second token of the pool by address sort order\n    /// Returns fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// Returns tickSpacing The minimum number of ticks between initialized ticks\n    function parameters()\n        external\n        view\n        returns (\n            address factory,\n            address token0,\n            address token1,\n            uint24 fee,\n            int24 tickSpacing\n        );\n}\n"
    },
    "contracts/depends/uniswap-v3-core/interfaces/pool/IUniswapV3PoolActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissionless pool actions\n/// @notice Contains pool methods that can be called by anyone\ninterface IUniswapV3PoolActions {\n    /// @notice Sets the initial price for the pool\n    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\n    function initialize(uint160 sqrtPriceX96) external;\n\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n    /// @param recipient The address for which the liquidity will be created\n    /// @param tickLower The lower tick of the position in which to add liquidity\n    /// @param tickUpper The upper tick of the position in which to add liquidity\n    /// @param amount The amount of liquidity to mint\n    /// @param data Any data that should be passed through to the callback\n    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Collects tokens owed to a position\n    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n    /// @param recipient The address which should receive the fees collected\n    /// @param tickLower The lower tick of the position for which to collect fees\n    /// @param tickUpper The upper tick of the position for which to collect fees\n    /// @param amount0Requested How much token0 should be withdrawn from the fees owed\n    /// @param amount1Requested How much token1 should be withdrawn from the fees owed\n    /// @return amount0 The amount of fees collected in token0\n    /// @return amount1 The amount of fees collected in token1\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n\n    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n    /// @dev Fees must be collected separately via a call to #collect\n    /// @param tickLower The lower tick of the position for which to burn liquidity\n    /// @param tickUpper The upper tick of the position for which to burn liquidity\n    /// @param amount How much liquidity to burn\n    /// @return amount0 The amount of token0 sent to the recipient\n    /// @return amount1 The amount of token1 sent to the recipient\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Swap token0 for token1, or token1 for token0\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n    /// @param recipient The address to receive the output of the swap\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n    /// @param data Any data to be passed through to the callback\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n\n    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\n    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\n    /// with 0 amount{0,1} and sending the donation amount(s) from the callback\n    /// @param recipient The address which will receive the token0 and token1 amounts\n    /// @param amount0 The amount of token0 to send\n    /// @param amount1 The amount of token1 to send\n    /// @param data Any data to be passed through to the callback\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n\n    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\n    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n    /// the input observationCardinalityNext.\n    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}\n"
    },
    "contracts/depends/uniswap-v3-core/interfaces/pool/IUniswapV3PoolDerivedState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that is not stored\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n/// blockchain. The functions here may have variable gas costs.\ninterface IUniswapV3PoolDerivedState {\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n    /// you must call it with secondsAgos = [3600, 0].\n    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n    /// timestamp\n    function observe(uint32[] calldata secondsAgos)\n        external\n        view\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n\n    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n    /// snapshot is taken and the second snapshot is taken.\n    /// @param tickLower The lower tick of the range\n    /// @param tickUpper The upper tick of the range\n    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n    /// @return secondsInside The snapshot of seconds per liquidity for the range\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n        external\n        view\n        returns (\n            int56 tickCumulativeInside,\n            uint160 secondsPerLiquidityInsideX128,\n            uint32 secondsInside\n        );\n}\n"
    },
    "contracts/depends/uniswap-v3-core/interfaces/pool/IUniswapV3PoolEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Events emitted by a pool\n/// @notice Contains all events emitted by the pool\ninterface IUniswapV3PoolEvents {\n    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\n    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\n    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\n    event Initialize(uint160 sqrtPriceX96, int24 tick);\n\n    /// @notice Emitted when liquidity is minted for a given position\n    /// @param sender The address that minted the liquidity\n    /// @param owner The owner of the position and recipient of any minted liquidity\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity minted to the position range\n    /// @param amount0 How much token0 was required for the minted liquidity\n    /// @param amount1 How much token1 was required for the minted liquidity\n    event Mint(\n        address sender,\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted when fees are collected by the owner of a position\n    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\n    /// @param owner The owner of the position for which fees are collected\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount0 The amount of token0 fees collected\n    /// @param amount1 The amount of token1 fees collected\n    event Collect(\n        address indexed owner,\n        address recipient,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount0,\n        uint128 amount1\n    );\n\n    /// @notice Emitted when a position's liquidity is removed\n    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\n    /// @param owner The owner of the position for which liquidity is removed\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity to remove\n    /// @param amount0 The amount of token0 withdrawn\n    /// @param amount1 The amount of token1 withdrawn\n    event Burn(\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted by the pool for any swaps between token0 and token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the output of the swap\n    /// @param amount0 The delta of the token0 balance of the pool\n    /// @param amount1 The delta of the token1 balance of the pool\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n    /// @param liquidity The liquidity of the pool after the swap\n    /// @param tick The log base 1.0001 of price of the pool after the swap\n    event Swap(\n        address indexed sender,\n        address indexed recipient,\n        int256 amount0,\n        int256 amount1,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        int24 tick\n    );\n\n    /// @notice Emitted by the pool for any flashes of token0/token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the tokens from flash\n    /// @param amount0 The amount of token0 that was flashed\n    /// @param amount1 The amount of token1 that was flashed\n    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\n    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\n    event Flash(\n        address indexed sender,\n        address indexed recipient,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 paid0,\n        uint256 paid1\n    );\n\n    /// @notice Emitted by the pool for increases to the number of observations that can be stored\n    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n    /// just before a mint/swap/burn.\n    /// @param observationCardinalityNextOld The previous value of the next observation cardinality\n    /// @param observationCardinalityNextNew The updated value of the next observation cardinality\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld,\n        uint16 observationCardinalityNextNew\n    );\n\n    /// @notice Emitted when the protocol fee is changed by the pool\n    /// @param feeProtocol0Old The previous value of the token0 protocol fee\n    /// @param feeProtocol1Old The previous value of the token1 protocol fee\n    /// @param feeProtocol0New The updated value of the token0 protocol fee\n    /// @param feeProtocol1New The updated value of the token1 protocol fee\n    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\n\n    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\n    /// @param sender The address that collects the protocol fees\n    /// @param recipient The address that receives the collected protocol fees\n    /// @param amount0 The amount of token0 protocol fees that is withdrawn\n    /// @param amount0 The amount of token1 protocol fees that is withdrawn\n    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\n}\n"
    },
    "contracts/depends/uniswap-v3-core/interfaces/pool/IUniswapV3PoolImmutables.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that never changes\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\ninterface IUniswapV3PoolImmutables {\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n    /// @return The contract address\n    function factory() external view returns (address);\n\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n    /// @return The fee\n    function fee() external view returns (uint24);\n\n    /// @notice The pool tick spacing\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n    /// This value is an int24 to avoid casting even though it is always positive.\n    /// @return The tick spacing\n    function tickSpacing() external view returns (int24);\n\n    /// @notice The maximum amount of position liquidity that can use any tick in the range\n    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n    /// @return The max amount of liquidity per tick\n    function maxLiquidityPerTick() external view returns (uint128);\n}\n"
    },
    "contracts/depends/uniswap-v3-core/interfaces/pool/IUniswapV3PoolOwnerActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissioned pool actions\n/// @notice Contains pool methods that may only be called by the factory owner\ninterface IUniswapV3PoolOwnerActions {\n    /// @notice Set the denominator of the protocol's % share of the fees\n    /// @param feeProtocol0 new protocol fee for token0 of the pool\n    /// @param feeProtocol1 new protocol fee for token1 of the pool\n    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\n\n    /// @notice Collect the protocol fee accrued to the pool\n    /// @param recipient The address to which collected protocol fees should be sent\n    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\n    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\n    /// @return amount0 The protocol fee collected in token0\n    /// @return amount1 The protocol fee collected in token1\n    function collectProtocol(\n        address recipient,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n}\n"
    },
    "contracts/depends/uniswap-v3-core/interfaces/pool/IUniswapV3PoolState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that can change\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\n/// per transaction\ninterface IUniswapV3PoolState {\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n    /// when accessed externally.\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n    /// boundary.\n    /// observationIndex The index of the last oracle observation that was written,\n    /// observationCardinality The current maximum number of observations stored in the pool,\n    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n    /// feeProtocol The protocol fee for both tokens of the pool.\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n    /// unlocked Whether the pool is currently locked to reentrancy\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal0X128() external view returns (uint256);\n\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal1X128() external view returns (uint256);\n\n    /// @notice The amounts of token0 and token1 that are owed to the protocol\n    /// @dev Protocol fees will never exceed uint128 max in either token\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n\n    /// @notice The currently in range liquidity available to the pool\n    /// @dev This value has no relationship to the total liquidity across all ticks\n    function liquidity() external view returns (uint128);\n\n    /// @notice Look up information about a specific tick in the pool\n    /// @param tick The tick to look up\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n    /// tick upper,\n    /// liquidityNet how much liquidity changes when the pool price crosses the tick,\n    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n    /// secondsOutside the seconds spent on the other side of the tick from the current tick,\n    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n    /// a specific position.\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n\n    /// @notice Returns the information about a position by the position's key\n    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\n    /// @return _liquidity The amount of liquidity in the position,\n    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\n    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\n    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\n    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    /// @notice Returns data about a specific observation index\n    /// @param index The element of the observations array to fetch\n    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n    /// ago, rather than at a specific index in the array.\n    /// @return blockTimestamp The timestamp of the observation,\n    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n    /// Returns initialized whether the observation has been initialized and the values are safe to use\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}\n"
    },
    "contracts/depends/uniswap-v3-core/libraries/BitMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title BitMath\n/// @dev This library provides functionality for computing bit properties of an unsigned integer\nlibrary BitMath {\n    /// @notice Returns the index of the most significant bit of the number,\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n    /// @dev The function satisfies the property:\n    ///     x >= 2**mostSignificantBit(x) and x < 2**(mostSignificantBit(x)+1)\n    /// @param x the value for which to compute the most significant bit, must be greater than 0\n    /// @return r the index of the most significant bit\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0);\n\n        if (x >= 0x100000000000000000000000000000000) {\n            x >>= 128;\n            r += 128;\n        }\n        if (x >= 0x10000000000000000) {\n            x >>= 64;\n            r += 64;\n        }\n        if (x >= 0x100000000) {\n            x >>= 32;\n            r += 32;\n        }\n        if (x >= 0x10000) {\n            x >>= 16;\n            r += 16;\n        }\n        if (x >= 0x100) {\n            x >>= 8;\n            r += 8;\n        }\n        if (x >= 0x10) {\n            x >>= 4;\n            r += 4;\n        }\n        if (x >= 0x4) {\n            x >>= 2;\n            r += 2;\n        }\n        if (x >= 0x2) r += 1;\n    }\n\n    /// @notice Returns the index of the least significant bit of the number,\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n    /// @dev The function satisfies the property:\n    ///     (x & 2**leastSignificantBit(x)) != 0 and (x & (2**(leastSignificantBit(x)) - 1)) == 0)\n    /// @param x the value for which to compute the least significant bit, must be greater than 0\n    /// @return r the index of the least significant bit\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0);\n\n        r = 255;\n        if (x & type(uint128).max > 0) {\n            r -= 128;\n        } else {\n            x >>= 128;\n        }\n        if (x & type(uint64).max > 0) {\n            r -= 64;\n        } else {\n            x >>= 64;\n        }\n        if (x & type(uint32).max > 0) {\n            r -= 32;\n        } else {\n            x >>= 32;\n        }\n        if (x & type(uint16).max > 0) {\n            r -= 16;\n        } else {\n            x >>= 16;\n        }\n        if (x & type(uint8).max > 0) {\n            r -= 8;\n        } else {\n            x >>= 8;\n        }\n        if (x & 0xf > 0) {\n            r -= 4;\n        } else {\n            x >>= 4;\n        }\n        if (x & 0x3 > 0) {\n            r -= 2;\n        } else {\n            x >>= 2;\n        }\n        if (x & 0x1 > 0) r -= 1;\n    }\n}\n"
    },
    "contracts/depends/uniswap-v3-core/libraries/FixedPoint128.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.4.0;\n\n/// @title FixedPoint128\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\nlibrary FixedPoint128 {\n    uint256 internal constant Q128 = 0x100000000000000000000000000000000;\n}\n"
    },
    "contracts/depends/uniswap-v3-core/libraries/FixedPoint96.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.4.0;\n\n/// @title FixedPoint96\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\n/// @dev Used in SqrtPriceMath.sol\nlibrary FixedPoint96 {\n    uint8 internal constant RESOLUTION = 96;\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\n}\n"
    },
    "contracts/depends/uniswap-v3-core/libraries/LiquidityMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Math library for liquidity\nlibrary LiquidityMath {\n    /// @notice Add a signed liquidity delta to liquidity and revert if it overflows or underflows\n    /// @param x The liquidity before change\n    /// @param y The delta by which liquidity should be changed\n    /// @return z The liquidity delta\n    function addDelta(uint128 x, int128 y) internal pure returns (uint128 z) {\n        if (y < 0) {\n            require((z = x - uint128(-y)) < x, 'LS');\n        } else {\n            require((z = x + uint128(y)) >= x, 'LA');\n        }\n    }\n}\n"
    },
    "contracts/depends/uniswap-v3-core/libraries/LowGasSafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.0;\n\n/// @title Optimized overflow and underflow safe math operations\n/// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost\nlibrary LowGasSafeMath {\n    /// @notice Returns x + y, reverts if sum overflows uint256\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x);\n    }\n\n    /// @notice Returns x - y, reverts if underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x);\n    }\n\n    /// @notice Returns x * y, reverts if overflows\n    /// @param x The multiplicand\n    /// @param y The multiplier\n    /// @return z The product of x and y\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(x == 0 || (z = x * y) / x == y);\n    }\n\n    /// @notice Returns x + y, reverts if overflows or underflows\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(int256 x, int256 y) internal pure returns (int256 z) {\n        require((z = x + y) >= x == (y >= 0));\n    }\n\n    /// @notice Returns x - y, reverts if overflows or underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(int256 x, int256 y) internal pure returns (int256 z) {\n        require((z = x - y) <= x == (y >= 0));\n    }\n}\n"
    },
    "contracts/depends/uniswap-v3-core/libraries/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Safe casting methods\n/// @notice Contains methods for safely casting between types\nlibrary SafeCast {\n    /// @notice Cast a uint256 to a uint160, revert on overflow\n    /// @param y The uint256 to be downcasted\n    /// @return z The downcasted integer, now type uint160\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\n        require((z = uint160(y)) == y);\n    }\n\n    /// @notice Cast a int256 to a int128, revert on overflow or underflow\n    /// @param y The int256 to be downcasted\n    /// @return z The downcasted integer, now type int128\n    function toInt128(int256 y) internal pure returns (int128 z) {\n        require((z = int128(y)) == y);\n    }\n\n    /// @notice Cast a uint256 to a int256, revert on overflow\n    /// @param y The uint256 to be casted\n    /// @return z The casted integer, now type int256\n    function toInt256(uint256 y) internal pure returns (int256 z) {\n        require(y < 2**255);\n        z = int256(y);\n    }\n}\n"
    },
    "contracts/depends/uniswap-v3-core/libraries/TickBitmap.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\nimport './BitMath.sol';\n\n/// @title Packed tick initialized state library\n/// @notice Stores a packed mapping of tick index to its initialized state\n/// @dev The mapping uses int16 for keys since ticks are represented as int24 and there are 256 (2^8) values per word.\nlibrary TickBitmap {\n    /// @notice Computes the position in the mapping where the initialized bit for a tick lives\n    /// @param tick The tick for which to compute the position\n    /// @return wordPos The key in the mapping containing the word in which the bit is stored\n    /// @return bitPos The bit position in the word where the flag is stored\n    function position(int24 tick) private pure returns (int16 wordPos, uint8 bitPos) {\n        wordPos = int16(tick >> 8);\n        bitPos = uint8(uint24(tick % 256));\n    }\n\n    /// @notice Flips the initialized state for a given tick from false to true, or vice versa\n    /// @param self The mapping in which to flip the tick\n    /// @param tick The tick to flip\n    /// @param tickSpacing The spacing between usable ticks\n    function flipTick(\n        mapping(int16 => uint256) storage self,\n        int24 tick,\n        int24 tickSpacing\n    ) internal {\n        require(tick % tickSpacing == 0); // ensure that the tick is spaced\n        (int16 wordPos, uint8 bitPos) = position(tick / tickSpacing);\n        uint256 mask = 1 << bitPos;\n        self[wordPos] ^= mask;\n    }\n\n    /// @notice Returns the next initialized tick contained in the same word (or adjacent word) as the tick that is either\n    /// to the left (less than or equal to) or right (greater than) of the given tick\n    /// @param self The mapping in which to compute the next initialized tick\n    /// @param tick The starting tick\n    /// @param tickSpacing The spacing between usable ticks\n    /// @param lte Whether to search for the next initialized tick to the left (less than or equal to the starting tick)\n    /// @return next The next initialized or uninitialized tick up to 256 ticks away from the current tick\n    /// @return initialized Whether the next tick is initialized, as the function only searches within up to 256 ticks\n    function nextInitializedTickWithinOneWord(\n        mapping(int16 => uint256) storage self,\n        int24 tick,\n        int24 tickSpacing,\n        bool lte\n    ) internal view returns (int24 next, bool initialized) {\n        int24 compressed = tick / tickSpacing;\n        if (tick < 0 && tick % tickSpacing != 0) compressed--; // round towards negative infinity\n\n        if (lte) {\n            (int16 wordPos, uint8 bitPos) = position(compressed);\n            // all the 1s at or to the right of the current bitPos\n            uint256 mask = (1 << bitPos) - 1 + (1 << bitPos);\n            uint256 masked = self[wordPos] & mask;\n\n            // if there are no initialized ticks to the right of or at the current tick, return rightmost in the word\n            initialized = masked != 0;\n            // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick\n            next = initialized\n                ? (compressed - int24(uint24(bitPos - BitMath.mostSignificantBit(masked)))) * tickSpacing\n                : (compressed - int24(uint24(bitPos))) * tickSpacing;\n        } else {\n            // start from the word of the next tick, since the current tick state doesn't matter\n            (int16 wordPos, uint8 bitPos) = position(compressed + 1);\n            // all the 1s at or to the left of the bitPos\n            uint256 mask = ~((1 << bitPos) - 1);\n            uint256 masked = self[wordPos] & mask;\n\n            // if there are no initialized ticks to the left of the current tick, return leftmost in the word\n            initialized = masked != 0;\n            // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick\n            next = initialized\n                ? (compressed + 1 + int24(uint24(BitMath.leastSignificantBit(masked) - bitPos))) * tickSpacing\n                : (compressed + 1 + int24(uint24(type(uint8).max - bitPos))) * tickSpacing;\n        }\n    }\n}\n"
    },
    "contracts/depends/uniswap-v3-core/libraries/TickMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0 <0.9.0;\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\nlibrary TickMath {\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n    int24 internal constant MIN_TICK = -887272;\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n    int24 internal constant MAX_TICK = -MIN_TICK;\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n    /// at the given tick\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n        require(absTick <= uint256(int256(MAX_TICK)), 'T');\n\n        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\n        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n        if (tick > 0) ratio = type(uint256).max / ratio;\n\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\n    }\n\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n    /// ever return.\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n        // second inequality must be < because the price can never reach the price at the max tick\n        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');\n        uint256 ratio = uint256(sqrtPriceX96) << 32;\n\n        uint256 r = ratio;\n        uint256 msb = 0;\n\n        assembly {\n            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(5, gt(r, 0xFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(4, gt(r, 0xFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(3, gt(r, 0xFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(2, gt(r, 0xF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(1, gt(r, 0x3))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := gt(r, 0x1)\n            msb := or(msb, f)\n        }\n\n        if (msb >= 128) r = ratio >> (msb - 127);\n        else r = ratio << (127 - msb);\n\n        int256 log_2 = (int256(msb) - 128) << 64;\n\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(63, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(62, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(61, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(60, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(59, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(58, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(57, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(56, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(55, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(54, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(53, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(52, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(51, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(50, f))\n        }\n\n        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\n\n        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\n    }\n}\n"
    },
    "contracts/depends/uniswap-v3-core/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.6.0;\n\nimport '../interfaces/IERC20Minimal.sol';\n\n/// @title TransferHelper\n/// @notice Contains helper methods for interacting with ERC20 tokens that do not consistently return true/false\nlibrary TransferHelper {\n    /// @notice Transfers tokens from msg.sender to a recipient\n    /// @dev Calls transfer on token contract, errors with TF if transfer fails\n    /// @param token The contract address of the token which will be transferred\n    /// @param to The recipient of the transfer\n    /// @param value The value of the transfer\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) =\n            token.call(abi.encodeWithSelector(IERC20Minimal.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TF');\n    }\n}\n"
    },
    "contracts/depends/uniswap-v3-core/libraries/UnsafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Math functions that do not check inputs or outputs\n/// @notice Contains methods that perform common math functions but do not do any overflow or underflow checks\nlibrary UnsafeMath {\n    /// @notice Returns ceil(x / y)\n    /// @dev division by 0 has unspecified behavior, and must be checked externally\n    /// @param x The dividend\n    /// @param y The divisor\n    /// @return z The quotient, ceil(x / y)\n    function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assembly {\n            z := add(div(x, y), gt(mod(x, y), 0))\n        }\n    }\n}\n"
    },
    "contracts/depends/uniswap-v3-periphery/interfaces/external/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Interface for verifying contract-based account signatures\n/// @notice Interface that verifies provided signature for the data\n/// @dev Interface defined by EIP-1271\ninterface IERC1271 {\n    /// @notice Returns whether the provided signature is valid for the provided data\n    /// @dev MUST return the bytes4 magic value 0x1626ba7e when function passes.\n    /// MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5).\n    /// MUST allow external calls.\n    /// @param hash Hash of the data to be signed\n    /// @param signature Signature byte array associated with _data\n    /// @return magicValue The bytes4 magic value 0x1626ba7e\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "contracts/depends/uniswap-v3-periphery/interfaces/external/IERC20PermitAllowed.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Interface for permit\n/// @notice Interface used by DAI/CHAI for permit\ninterface IERC20PermitAllowed {\n    /// @notice Approve the spender to spend some tokens via the holder signature\n    /// @dev This is the permit interface used by DAI and CHAI\n    /// @param holder The address of the token holder, the token owner\n    /// @param spender The address of the token spender\n    /// @param nonce The holder's nonce, increases at each call to permit\n    /// @param expiry The timestamp at which the permit is no longer valid\n    /// @param allowed Boolean that sets approval amount, true for type(uint256).max and false for 0\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n    function permit(\n        address holder,\n        address spender,\n        uint256 nonce,\n        uint256 expiry,\n        bool allowed,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "contracts/depends/uniswap-v3-periphery/interfaces/IMulticall.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\n/// @title Multicall interface\n/// @notice Enables calling multiple methods in a single call to the contract\ninterface IMulticall {\n    /// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n    /// @dev The `msg.value` should not be trusted for any method callable from multicall.\n    /// @param data The encoded function data for each of the calls to make to this contract\n    /// @return results The results from each of the calls passed in via data\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\n}\n"
    },
    "contracts/depends/uniswap-v3-periphery/interfaces/IPeripheryImmutableState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Immutable state\n/// @notice Functions that return immutable state of the router\ninterface IPeripheryImmutableState {\n    /// @return Returns the address of the Uniswap V3 factory\n    function factory() external view returns (address);\n\n    /// @return Returns the address of WETH9\n    function WETH9() external view returns (address);\n}\n"
    },
    "contracts/depends/uniswap-v3-periphery/interfaces/IPeripheryPayments.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\n\n/// @title Periphery Payments\n/// @notice Functions to ease deposits and withdrawals of ETH\ninterface IPeripheryPayments {\n    /// @notice Unwraps the contract's WETH9 balance and sends it to recipient as ETH.\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.\n    /// @param amountMinimum The minimum amount of WETH9 to unwrap\n    /// @param recipient The address receiving ETH\n    function unwrapWETH9(uint256 amountMinimum, address recipient) external payable;\n\n    /// @notice Refunds any ETH balance held by this contract to the `msg.sender`\n    /// @dev Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps\n    /// that use ether for the input amount\n    function refundETH() external payable;\n\n    /// @notice Transfers the full amount of a token held by this contract to recipient\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing the token from users\n    /// @param token The contract address of the token which will be transferred to `recipient`\n    /// @param amountMinimum The minimum amount of token required for a transfer\n    /// @param recipient The destination address of the token\n    function sweepToken(\n        address token,\n        uint256 amountMinimum,\n        address recipient\n    ) external payable;\n}\n"
    },
    "contracts/depends/uniswap-v3-periphery/interfaces/IPeripheryPaymentsWithFee.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\n\nimport './IPeripheryPayments.sol';\n\n/// @title Periphery Payments\n/// @notice Functions to ease deposits and withdrawals of ETH\ninterface IPeripheryPaymentsWithFee is IPeripheryPayments {\n    /// @notice Unwraps the contract's WETH9 balance and sends it to recipient as ETH, with a percentage between\n    /// 0 (exclusive), and 1 (inclusive) going to feeRecipient\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.\n    function unwrapWETH9WithFee(\n        uint256 amountMinimum,\n        address recipient,\n        uint256 feeBips,\n        address feeRecipient\n    ) external payable;\n\n    /// @notice Transfers the full amount of a token held by this contract to recipient, with a percentage between\n    /// 0 (exclusive) and 1 (inclusive) going to feeRecipient\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing the token from users\n    function sweepTokenWithFee(\n        address token,\n        uint256 amountMinimum,\n        address recipient,\n        uint256 feeBips,\n        address feeRecipient\n    ) external payable;\n}\n"
    },
    "contracts/depends/uniswap-v3-periphery/interfaces/IPoolInitializer.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\n/// @title Creates and initializes V3 Pools\n/// @notice Provides a method for creating and initializing a pool, if necessary, for bundling with other methods that\n/// require the pool to exist.\ninterface IPoolInitializer {\n    /// @notice Creates a new pool if it does not exist, then initializes if not initialized\n    /// @dev This method can be bundled with others via IMulticall for the first action (e.g. mint) performed against a pool\n    /// @param token0 The contract address of token0 of the pool\n    /// @param token1 The contract address of token1 of the pool\n    /// @param fee The fee amount of the v3 pool for the specified token pair\n    /// @param sqrtPriceX96 The initial square root price of the pool as a Q64.96 value\n    /// @return pool Returns the pool address based on the pair of tokens and fee, will return the newly created pool address if necessary\n    function createAndInitializePoolIfNecessary(\n        address token0,\n        address token1,\n        uint24 fee,\n        uint160 sqrtPriceX96\n    ) external payable returns (address pool);\n}\n"
    },
    "contracts/depends/uniswap-v3-periphery/interfaces/IQuoter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\n/// @title Quoter Interface\n/// @notice Supports quoting the calculated amounts from exact input or exact output swaps\n/// @dev These functions are not marked view because they rely on calling non-view functions and reverting\n/// to compute the result. They are also not gas efficient and should not be called on-chain.\ninterface IQuoter {\n    /// @notice Returns the amount out received for a given exact input swap without executing the swap\n    /// @param path The path of the swap, i.e. each token pair and the pool fee\n    /// @param amountIn The amount of the first token to swap\n    /// @return amountOut The amount of the last token that would be received\n    function quoteExactInput(bytes memory path, uint256 amountIn) external returns (uint256 amountOut);\n\n    /// @notice Returns the amount out received for a given exact input but for a swap of a single pool\n    /// @param tokenIn The token being swapped in\n    /// @param tokenOut The token being swapped out\n    /// @param fee The fee of the token pool to consider for the pair\n    /// @param amountIn The desired input amount\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n    /// @return amountOut The amount of `tokenOut` that would be received\n    function quoteExactInputSingle(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountIn,\n        uint160 sqrtPriceLimitX96\n    ) external returns (uint256 amountOut);\n\n    /// @notice Returns the amount in required for a given exact output swap without executing the swap\n    /// @param path The path of the swap, i.e. each token pair and the pool fee. Path must be provided in reverse order\n    /// @param amountOut The amount of the last token to receive\n    /// @return amountIn The amount of first token required to be paid\n    function quoteExactOutput(bytes memory path, uint256 amountOut) external returns (uint256 amountIn);\n\n    /// @notice Returns the amount in required to receive the given exact output amount but for a swap of a single pool\n    /// @param tokenIn The token being swapped in\n    /// @param tokenOut The token being swapped out\n    /// @param fee The fee of the token pool to consider for the pair\n    /// @param amountOut The desired output amount\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n    /// @return amountIn The amount required as the input for the swap in order to receive `amountOut`\n    function quoteExactOutputSingle(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountOut,\n        uint160 sqrtPriceLimitX96\n    ) external returns (uint256 amountIn);\n}\n"
    },
    "contracts/depends/uniswap-v3-periphery/interfaces/IQuoterV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\n/// @title QuoterV2 Interface\n/// @notice Supports quoting the calculated amounts from exact input or exact output swaps.\n/// @notice For each pool also tells you the number of initialized ticks crossed and the sqrt price of the pool after the swap.\n/// @dev These functions are not marked view because they rely on calling non-view functions and reverting\n/// to compute the result. They are also not gas efficient and should not be called on-chain.\ninterface IQuoterV2 {\n    /// @notice Returns the amount out received for a given exact input swap without executing the swap\n    /// @param path The path of the swap, i.e. each token pair and the pool fee\n    /// @param amountIn The amount of the first token to swap\n    /// @return amountOut The amount of the last token that would be received\n    /// @return sqrtPriceX96AfterList List of the sqrt price after the swap for each pool in the path\n    /// @return initializedTicksCrossedList List of the initialized ticks that the swap crossed for each pool in the path\n    /// @return gasEstimate The estimate of the gas that the swap consumes\n    function quoteExactInput(bytes memory path, uint256 amountIn)\n        external\n        returns (\n            uint256 amountOut,\n            uint160[] memory sqrtPriceX96AfterList,\n            uint32[] memory initializedTicksCrossedList,\n            uint256 gasEstimate\n        );\n\n    struct QuoteExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint256 amountIn;\n        uint24 fee;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Returns the amount out received for a given exact input but for a swap of a single pool\n    /// @param params The params for the quote, encoded as `QuoteExactInputSingleParams`\n    /// tokenIn The token being swapped in\n    /// tokenOut The token being swapped out\n    /// fee The fee of the token pool to consider for the pair\n    /// amountIn The desired input amount\n    /// sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n    /// @return amountOut The amount of `tokenOut` that would be received\n    /// @return sqrtPriceX96After The sqrt price of the pool after the swap\n    /// @return initializedTicksCrossed The number of initialized ticks that the swap crossed\n    /// @return gasEstimate The estimate of the gas that the swap consumes\n    function quoteExactInputSingle(QuoteExactInputSingleParams memory params)\n        external\n        returns (\n            uint256 amountOut,\n            uint160 sqrtPriceX96After,\n            uint32 initializedTicksCrossed,\n            uint256 gasEstimate\n        );\n\n    /// @notice Returns the amount in required for a given exact output swap without executing the swap\n    /// @param path The path of the swap, i.e. each token pair and the pool fee. Path must be provided in reverse order\n    /// @param amountOut The amount of the last token to receive\n    /// @return amountIn The amount of first token required to be paid\n    /// @return sqrtPriceX96AfterList List of the sqrt price after the swap for each pool in the path\n    /// @return initializedTicksCrossedList List of the initialized ticks that the swap crossed for each pool in the path\n    /// @return gasEstimate The estimate of the gas that the swap consumes\n    function quoteExactOutput(bytes memory path, uint256 amountOut)\n        external\n        returns (\n            uint256 amountIn,\n            uint160[] memory sqrtPriceX96AfterList,\n            uint32[] memory initializedTicksCrossedList,\n            uint256 gasEstimate\n        );\n\n    struct QuoteExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint256 amount;\n        uint24 fee;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Returns the amount in required to receive the given exact output amount but for a swap of a single pool\n    /// @param params The params for the quote, encoded as `QuoteExactOutputSingleParams`\n    /// tokenIn The token being swapped in\n    /// tokenOut The token being swapped out\n    /// fee The fee of the token pool to consider for the pair\n    /// amountOut The desired output amount\n    /// sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n    /// @return amountIn The amount required as the input for the swap in order to receive `amountOut`\n    /// @return sqrtPriceX96After The sqrt price of the pool after the swap\n    /// @return initializedTicksCrossed The number of initialized ticks that the swap crossed\n    /// @return gasEstimate The estimate of the gas that the swap consumes\n    function quoteExactOutputSingle(QuoteExactOutputSingleParams memory params)\n        external\n        returns (\n            uint256 amountIn,\n            uint160 sqrtPriceX96After,\n            uint32 initializedTicksCrossed,\n            uint256 gasEstimate\n        );\n}\n"
    },
    "contracts/depends/uniswap-v3-periphery/interfaces/ISelfPermit.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\n\n/// @title Self Permit\n/// @notice Functionality to call permit on any EIP-2612-compliant token for use in the route\ninterface ISelfPermit {\n    /// @notice Permits this contract to spend a given token from `msg.sender`\n    /// @dev The `owner` is always msg.sender and the `spender` is always address(this).\n    /// @param token The address of the token spent\n    /// @param value The amount that can be spent of token\n    /// @param deadline A timestamp, the current blocktime must be less than or equal to this timestamp\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n    function selfPermit(\n        address token,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable;\n\n    /// @notice Permits this contract to spend a given token from `msg.sender`\n    /// @dev The `owner` is always msg.sender and the `spender` is always address(this).\n    /// Can be used instead of #selfPermit to prevent calls from failing due to a frontrun of a call to #selfPermit\n    /// @param token The address of the token spent\n    /// @param value The amount that can be spent of token\n    /// @param deadline A timestamp, the current blocktime must be less than or equal to this timestamp\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n    function selfPermitIfNecessary(\n        address token,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable;\n\n    /// @notice Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter\n    /// @dev The `owner` is always msg.sender and the `spender` is always address(this)\n    /// @param token The address of the token spent\n    /// @param nonce The current nonce of the owner\n    /// @param expiry The timestamp at which the permit is no longer valid\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n    function selfPermitAllowed(\n        address token,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable;\n\n    /// @notice Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter\n    /// @dev The `owner` is always msg.sender and the `spender` is always address(this)\n    /// Can be used instead of #selfPermitAllowed to prevent calls from failing due to a frontrun of a call to #selfPermitAllowed.\n    /// @param token The address of the token spent\n    /// @param nonce The current nonce of the owner\n    /// @param expiry The timestamp at which the permit is no longer valid\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n    function selfPermitAllowedIfNecessary(\n        address token,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable;\n}\n"
    },
    "contracts/depends/uniswap-v3-periphery/interfaces/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\nimport '../../uniswap-v3-core/interfaces/callback/IUniswapV3SwapCallback.sol';\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface ISwapRouter is IUniswapV3SwapCallback {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n}\n"
    },
    "contracts/depends/uniswap-v3-periphery/interfaces/ITickLens.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\n/// @title Tick Lens\n/// @notice Provides functions for fetching chunks of tick data for a pool\n/// @dev This avoids the waterfall of fetching the tick bitmap, parsing the bitmap to know which ticks to fetch, and\n/// then sending additional multicalls to fetch the tick data\ninterface ITickLens {\n    struct PopulatedTick {\n        int24 tick;\n        int128 liquidityNet;\n        uint128 liquidityGross;\n    }\n\n    /// @notice Get all the tick data for the populated ticks from a word of the tick bitmap of a pool\n    /// @param pool The address of the pool for which to fetch populated tick data\n    /// @param tickBitmapIndex The index of the word in the tick bitmap for which to parse the bitmap and\n    /// fetch all the populated ticks\n    /// @return populatedTicks An array of tick data for the given word in the tick bitmap\n    function getPopulatedTicksInWord(address pool, int16 tickBitmapIndex)\n        external\n        view\n        returns (PopulatedTick[] memory populatedTicks);\n}\n"
    },
    "contracts/depends/uniswap-v3-periphery/interfaces/IV3Migrator.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\nimport './IMulticall.sol';\nimport './ISelfPermit.sol';\nimport './IPoolInitializer.sol';\n\n/// @title V3 Migrator\n/// @notice Enables migration of liqudity from Uniswap v2-compatible pairs into Uniswap v3 pools\ninterface IV3Migrator is IMulticall, ISelfPermit, IPoolInitializer {\n    struct MigrateParams {\n        address pair; // the Uniswap v2-compatible pair\n        uint256 liquidityToMigrate; // expected to be balanceOf(msg.sender)\n        uint8 percentageToMigrate; // represented as a numerator over 100\n        address token0;\n        address token1;\n        uint24 fee;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Min; // must be discounted by percentageToMigrate\n        uint256 amount1Min; // must be discounted by percentageToMigrate\n        address recipient;\n        uint256 deadline;\n        bool refundAsETH;\n    }\n\n    /// @notice Migrates liquidity to v3 by burning v2 liquidity and minting a new position for v3\n    /// @dev Slippage protection is enforced via `amount{0,1}Min`, which should be a discount of the expected values of\n    /// the maximum amount of v3 liquidity that the v2 liquidity can get. For the special case of migrating to an\n    /// out-of-range position, `amount{0,1}Min` may be set to 0, enforcing that the position remains out of range\n    /// @param params The params necessary to migrate v2 liquidity, encoded as `MigrateParams` in calldata\n    function migrate(MigrateParams calldata params) external;\n}\n"
    },
    "contracts/depends/uniswap-v3-periphery/lens/TickLens.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\npragma abicoder v2;\n\nimport '../../uniswap-v3-core/interfaces/IUniswapV3Pool.sol';\n\nimport '../interfaces/ITickLens.sol';\n\n/// @title Tick Lens contract\ncontract TickLens is ITickLens {\n    /// @inheritdoc ITickLens\n    function getPopulatedTicksInWord(address pool, int16 tickBitmapIndex)\n        public\n        view\n        override\n        returns (PopulatedTick[] memory populatedTicks)\n    {\n        // fetch bitmap\n        uint256 bitmap = IUniswapV3Pool(pool).tickBitmap(tickBitmapIndex);\n\n        // calculate the number of populated ticks\n        uint256 numberOfPopulatedTicks;\n        for (uint256 i = 0; i < 256; i++) {\n            if (bitmap & (1 << i) > 0) numberOfPopulatedTicks++;\n        }\n\n        // fetch populated tick data\n        int24 tickSpacing = IUniswapV3Pool(pool).tickSpacing();\n        populatedTicks = new PopulatedTick[](numberOfPopulatedTicks);\n        for (uint256 i = 0; i < 256; i++) {\n            if (bitmap & (1 << i) > 0) {\n                int24 populatedTick = ((int24(tickBitmapIndex) << 8) + int24(uint24(i))) * tickSpacing;\n                (uint128 liquidityGross, int128 liquidityNet, , , , , , ) = IUniswapV3Pool(pool).ticks(populatedTick);\n                populatedTicks[--numberOfPopulatedTicks] = PopulatedTick({\n                    tick: populatedTick,\n                    liquidityNet: liquidityNet,\n                    liquidityGross: liquidityGross\n                });\n            }\n        }\n    }\n}\n"
    },
    "contracts/depends/uniswap-v3-periphery/libraries/ChainId.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.0;\n\n/// @title Function for getting the current chain ID\nlibrary ChainId {\n    /// @dev Gets the current chain ID\n    /// @return chainId The current chain ID\n    function get() internal view returns (uint256 chainId) {\n        assembly {\n            chainId := chainid()\n        }\n    }\n}\n"
    },
    "contracts/depends/uniswap-v3-periphery/libraries/PoolAddress.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nimport '../../uniswap-v3-core/interfaces/IUniswapV3Factory.sol';\n\n/// @title Provides functions for deriving a pool address from the factory, tokens, and the fee\nlibrary PoolAddress {\n    /// @notice The identifying key of the pool\n    struct PoolKey {\n        address token0;\n        address token1;\n        uint24 fee;\n    }\n\n    /// @notice Returns PoolKey: the ordered tokens with the matched fee levels\n    /// @param tokenA The first token of a pool, unsorted\n    /// @param tokenB The second token of a pool, unsorted\n    /// @param fee The fee level of the pool\n    /// @return Poolkey The pool details with ordered token0 and token1 assignments\n    function getPoolKey(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) internal pure returns (PoolKey memory) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        return PoolKey({token0: tokenA, token1: tokenB, fee: fee});\n    }\n\n    /// @notice Deterministically computes the pool address given the factory and PoolKey\n    /// @param factory The Uniswap V3 factory contract address\n    /// @param key The PoolKey\n    /// @return pool The contract address of the V3 pool\n    function computeAddress(address factory, PoolKey memory key) internal pure returns (address pool) {\n        require(key.token0 < key.token1);\n        pool = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex'ff',\n                            factory,\n                            keccak256(abi.encode(key.token0, key.token1, key.fee)),\n                            IUniswapV3Factory(factory).poolCodeHash()\n                        )\n                    )\n                )\n            )\n        );\n    }\n}\n"
    },
    "contracts/depends/uniswap-v3-periphery/libraries/PoolTicksCounter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.6.0;\n\nimport '../../uniswap-v3-core/interfaces/IUniswapV3Pool.sol';\n\nlibrary PoolTicksCounter {\n    /// @dev This function counts the number of initialized ticks that would incur a gas cost between tickBefore and tickAfter.\n    /// When tickBefore and/or tickAfter themselves are initialized, the logic over whether we should count them depends on the\n    /// direction of the swap. If we are swapping upwards (tickAfter > tickBefore) we don't want to count tickBefore but we do\n    /// want to count tickAfter. The opposite is true if we are swapping downwards.\n    function countInitializedTicksCrossed(\n        IUniswapV3Pool self,\n        int24 tickBefore,\n        int24 tickAfter\n    ) internal view returns (uint32 initializedTicksCrossed) {\n        int16 wordPosLower;\n        int16 wordPosHigher;\n        uint8 bitPosLower;\n        uint8 bitPosHigher;\n        bool tickBeforeInitialized;\n        bool tickAfterInitialized;\n\n        {\n            // Get the key and offset in the tick bitmap of the active tick before and after the swap.\n            int16 wordPos = int16((tickBefore / self.tickSpacing()) >> 8);\n            uint8 bitPos = uint8(uint24((tickBefore / self.tickSpacing()) % 256));\n\n            int16 wordPosAfter = int16((tickAfter / self.tickSpacing()) >> 8);\n            uint8 bitPosAfter = uint8(uint24((tickAfter / self.tickSpacing()) % 256));\n\n            // In the case where tickAfter is initialized, we only want to count it if we are swapping downwards.\n            // If the initializable tick after the swap is initialized, our original tickAfter is a\n            // multiple of tick spacing, and we are swapping downwards we know that tickAfter is initialized\n            // and we shouldn't count it.\n            tickAfterInitialized =\n                ((self.tickBitmap(wordPosAfter) & (1 << bitPosAfter)) > 0) &&\n                ((tickAfter % self.tickSpacing()) == 0) &&\n                (tickBefore > tickAfter);\n\n            // In the case where tickBefore is initialized, we only want to count it if we are swapping upwards.\n            // Use the same logic as above to decide whether we should count tickBefore or not.\n            tickBeforeInitialized =\n                ((self.tickBitmap(wordPos) & (1 << bitPos)) > 0) &&\n                ((tickBefore % self.tickSpacing()) == 0) &&\n                (tickBefore < tickAfter);\n\n            if (wordPos < wordPosAfter || (wordPos == wordPosAfter && bitPos <= bitPosAfter)) {\n                wordPosLower = wordPos;\n                bitPosLower = bitPos;\n                wordPosHigher = wordPosAfter;\n                bitPosHigher = bitPosAfter;\n            } else {\n                wordPosLower = wordPosAfter;\n                bitPosLower = bitPosAfter;\n                wordPosHigher = wordPos;\n                bitPosHigher = bitPos;\n            }\n        }\n\n        // Count the number of initialized ticks crossed by iterating through the tick bitmap.\n        // Our first mask should include the lower tick and everything to its left.\n        uint256 mask = type(uint256).max << bitPosLower;\n        while (wordPosLower <= wordPosHigher) {\n            // If we're on the final tick bitmap page, ensure we only count up to our\n            // ending tick.\n            if (wordPosLower == wordPosHigher) {\n                mask = mask & (type(uint256).max >> (255 - bitPosHigher));\n            }\n\n            uint256 masked = self.tickBitmap(wordPosLower) & mask;\n            initializedTicksCrossed += countOneBits(masked);\n            wordPosLower++;\n            // Reset our mask so we consider all bits on the next iteration.\n            mask = type(uint256).max;\n        }\n\n        if (tickAfterInitialized) {\n            initializedTicksCrossed -= 1;\n        }\n\n        if (tickBeforeInitialized) {\n            initializedTicksCrossed -= 1;\n        }\n\n        return initializedTicksCrossed;\n    }\n\n    function countOneBits(uint256 x) private pure returns (uint16) {\n        uint16 bits = 0;\n        while (x != 0) {\n            bits++;\n            x &= (x - 1);\n        }\n        return bits;\n    }\n}\n"
    },
    "contracts/depends/uniswap-v3-periphery/libraries/PositionKey.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nlibrary PositionKey {\n    /// @dev Returns the key of the position in the core library\n    function compute(\n        address owner,\n        int24 tickLower,\n        int24 tickUpper\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(owner, tickLower, tickUpper));\n    }\n}\n"
    },
    "contracts/interfaces/uniswap-v3-core/callback/IUniswapV3FlashCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#flash\n/// @notice Any contract that calls IUniswapV3PoolActions#flash must implement this interface\ninterface IUniswapV3FlashCallback {\n    /// @notice Called to `msg.sender` after transferring to the recipient from IUniswapV3Pool#flash.\n    /// @dev In the implementation you must repay the pool the tokens sent by flash plus the computed fee amounts.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// @param fee0 The fee amount in token0 due to the pool by the end of the flash\n    /// @param fee1 The fee amount in token1 due to the pool by the end of the flash\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#flash call\n    function uniswapV3FlashCallback(\n        uint256 fee0,\n        uint256 fee1,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/interfaces/uniswap-v3-core/callback/IUniswapV3MintCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#mint\n/// @notice Any contract that calls IUniswapV3PoolActions#mint must implement this interface\ninterface IUniswapV3MintCallback {\n    /// @notice Called to `msg.sender` after minting liquidity to a position from IUniswapV3Pool#mint.\n    /// @dev In the implementation you must pay the pool tokens owed for the minted liquidity.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// @param amount0Owed The amount of token0 due to the pool for the minted liquidity\n    /// @param amount1Owed The amount of token1 due to the pool for the minted liquidity\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#mint call\n    function uniswapV3MintCallback(\n        uint256 amount0Owed,\n        uint256 amount1Owed,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/interfaces/uniswap-v3-core/callback/IUniswapV3SwapCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/interfaces/uniswap-v3-core/IERC20Minimal.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Minimal ERC20 interface for Uniswap\n/// @notice Contains a subset of the full ERC20 interface that is used in Uniswap V3\ninterface IERC20Minimal {\n    /// @notice Returns the balance of a token\n    /// @param account The account for which to look up the number of tokens it has, i.e. its balance\n    /// @return The number of tokens held by the account\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Transfers the amount of token from the `msg.sender` to the recipient\n    /// @param recipient The account that will receive the amount transferred\n    /// @param amount The number of tokens to send from the sender to the recipient\n    /// @return Returns true for a successful transfer, false for an unsuccessful transfer\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /// @notice Returns the current allowance given to a spender by an owner\n    /// @param owner The account of the token owner\n    /// @param spender The account of the token spender\n    /// @return The current allowance granted by `owner` to `spender`\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /// @notice Sets the allowance of a spender from the `msg.sender` to the value `amount`\n    /// @param spender The account which will be allowed to spend a given amount of the owners tokens\n    /// @param amount The amount of tokens allowed to be used by `spender`\n    /// @return Returns true for a successful approval, false for unsuccessful\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /// @notice Transfers `amount` tokens from `sender` to `recipient` up to the allowance given to the `msg.sender`\n    /// @param sender The account from which the transfer will be initiated\n    /// @param recipient The recipient of the transfer\n    /// @param amount The amount of the transfer\n    /// @return Returns true for a successful transfer, false for unsuccessful\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /// @notice Event emitted when tokens are transferred from one address to another, either via `#transfer` or `#transferFrom`.\n    /// @param from The account from which the tokens were sent, i.e. the balance decreased\n    /// @param to The account to which the tokens were sent, i.e. the balance increased\n    /// @param value The amount of tokens that were transferred\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @notice Event emitted when the approval amount for the spender of a given owner's tokens changes.\n    /// @param owner The account that approved spending of its tokens\n    /// @param spender The account for which the spending allowance was modified\n    /// @param value The new allowance from the owner to the spender\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/interfaces/uniswap-v3-core/interfaces/callback/IUniswapV3FlashCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#flash\n/// @notice Any contract that calls IUniswapV3PoolActions#flash must implement this interface\ninterface IUniswapV3FlashCallback {\n    /// @notice Called to `msg.sender` after transferring to the recipient from IUniswapV3Pool#flash.\n    /// @dev In the implementation you must repay the pool the tokens sent by flash plus the computed fee amounts.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// @param fee0 The fee amount in token0 due to the pool by the end of the flash\n    /// @param fee1 The fee amount in token1 due to the pool by the end of the flash\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#flash call\n    function uniswapV3FlashCallback(\n        uint256 fee0,\n        uint256 fee1,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/interfaces/uniswap-v3-core/interfaces/callback/IUniswapV3MintCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#mint\n/// @notice Any contract that calls IUniswapV3PoolActions#mint must implement this interface\ninterface IUniswapV3MintCallback {\n    /// @notice Called to `msg.sender` after minting liquidity to a position from IUniswapV3Pool#mint.\n    /// @dev In the implementation you must pay the pool tokens owed for the minted liquidity.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// @param amount0Owed The amount of token0 due to the pool for the minted liquidity\n    /// @param amount1Owed The amount of token1 due to the pool for the minted liquidity\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#mint call\n    function uniswapV3MintCallback(\n        uint256 amount0Owed,\n        uint256 amount1Owed,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/interfaces/uniswap-v3-core/interfaces/callback/IUniswapV3SwapCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/interfaces/uniswap-v3-core/interfaces/IERC20Minimal.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Minimal ERC20 interface for Uniswap\n/// @notice Contains a subset of the full ERC20 interface that is used in Uniswap V3\ninterface IERC20Minimal {\n    /// @notice Returns the balance of a token\n    /// @param account The account for which to look up the number of tokens it has, i.e. its balance\n    /// @return The number of tokens held by the account\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Transfers the amount of token from the `msg.sender` to the recipient\n    /// @param recipient The account that will receive the amount transferred\n    /// @param amount The number of tokens to send from the sender to the recipient\n    /// @return Returns true for a successful transfer, false for an unsuccessful transfer\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /// @notice Returns the current allowance given to a spender by an owner\n    /// @param owner The account of the token owner\n    /// @param spender The account of the token spender\n    /// @return The current allowance granted by `owner` to `spender`\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /// @notice Sets the allowance of a spender from the `msg.sender` to the value `amount`\n    /// @param spender The account which will be allowed to spend a given amount of the owners tokens\n    /// @param amount The amount of tokens allowed to be used by `spender`\n    /// @return Returns true for a successful approval, false for unsuccessful\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /// @notice Transfers `amount` tokens from `sender` to `recipient` up to the allowance given to the `msg.sender`\n    /// @param sender The account from which the transfer will be initiated\n    /// @param recipient The recipient of the transfer\n    /// @param amount The amount of the transfer\n    /// @return Returns true for a successful transfer, false for unsuccessful\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /// @notice Event emitted when tokens are transferred from one address to another, either via `#transfer` or `#transferFrom`.\n    /// @param from The account from which the tokens were sent, i.e. the balance decreased\n    /// @param to The account to which the tokens were sent, i.e. the balance increased\n    /// @param value The amount of tokens that were transferred\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @notice Event emitted when the approval amount for the spender of a given owner's tokens changes.\n    /// @param owner The account that approved spending of its tokens\n    /// @param spender The account for which the spending allowance was modified\n    /// @param value The new allowance from the owner to the spender\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/interfaces/uniswap-v3-core/interfaces/IUniswapV3Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title The interface for the Uniswap V3 Factory\n/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees\ninterface IUniswapV3Factory {\n    /// @notice Emitted when the owner of the factory is changed\n    /// @param oldOwner The owner before the owner was changed\n    /// @param newOwner The owner after the owner was changed\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\n\n    /// @notice Emitted when a pool is created\n    /// @param token0 The first token of the pool by address sort order\n    /// @param token1 The second token of the pool by address sort order\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\n    /// @param pool The address of the created pool\n    event PoolCreated(\n        address indexed token0,\n        address indexed token1,\n        uint24 indexed fee,\n        int24 tickSpacing,\n        address pool\n    );\n\n    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory\n    /// @param fee The enabled fee, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee\n    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\n\n    /// @notice Returns the LP pool init code hash\n    /// @return The LP pool init code hash\n    function poolCodeHash() external pure returns (bytes32);\n\n    /// @notice Returns the current owner of the factory\n    /// @dev Can be changed by the current owner via setOwner\n    /// @return The address of the factory owner\n    function owner() external view returns (address);\n\n    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled\n    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\n    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\n    /// @return The tick spacing\n    function feeAmountTickSpacing(uint24 fee) external view returns (int24);\n\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\n    /// @param tokenA The contract address of either token0 or token1\n    /// @param tokenB The contract address of the other token\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @return pool The pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external view returns (address pool);\n\n    /// @notice Creates a pool for the given two tokens and fee\n    /// @param tokenA One of the two tokens in the desired pool\n    /// @param tokenB The other of the two tokens in the desired pool\n    /// @param fee The desired fee for the pool\n    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\n    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\n    /// are invalid.\n    /// @return pool The address of the newly created pool\n    function createPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external returns (address pool);\n\n    /// @notice Updates the owner of the factory\n    /// @dev Must be called by the current owner\n    /// @param _owner The new owner of the factory\n    function setOwner(address _owner) external;\n\n    /// @notice Enables a fee amount with the given tickSpacing\n    /// @dev Fee amounts may never be removed once enabled\n    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)\n    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount\n    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\n}\n"
    },
    "contracts/interfaces/uniswap-v3-core/interfaces/IUniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nimport './pool/IUniswapV3PoolImmutables.sol';\nimport './pool/IUniswapV3PoolState.sol';\nimport './pool/IUniswapV3PoolDerivedState.sol';\nimport './pool/IUniswapV3PoolActions.sol';\nimport './pool/IUniswapV3PoolOwnerActions.sol';\nimport './pool/IUniswapV3PoolEvents.sol';\n\n/// @title The interface for a Uniswap V3 Pool\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface IUniswapV3Pool is\n    IUniswapV3PoolImmutables,\n    IUniswapV3PoolState,\n    IUniswapV3PoolDerivedState,\n    IUniswapV3PoolActions,\n    IUniswapV3PoolOwnerActions,\n    IUniswapV3PoolEvents\n{\n\n}\n"
    },
    "contracts/interfaces/uniswap-v3-core/interfaces/IUniswapV3PoolDeployer.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title An interface for a contract that is capable of deploying Uniswap V3 Pools\n/// @notice A contract that constructs a pool must implement this to pass arguments to the pool\n/// @dev This is used to avoid having constructor arguments in the pool contract, which results in the init code hash\n/// of the pool being constant allowing the CREATE2 address of the pool to be cheaply computed on-chain\ninterface IUniswapV3PoolDeployer {\n    /// @notice Get the parameters to be used in constructing the pool, set transiently during pool creation.\n    /// @dev Called by the pool constructor to fetch the parameters of the pool\n    /// Returns factory The factory address\n    /// Returns token0 The first token of the pool by address sort order\n    /// Returns token1 The second token of the pool by address sort order\n    /// Returns fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// Returns tickSpacing The minimum number of ticks between initialized ticks\n    function parameters()\n        external\n        view\n        returns (\n            address factory,\n            address token0,\n            address token1,\n            uint24 fee,\n            int24 tickSpacing\n        );\n}\n"
    },
    "contracts/interfaces/uniswap-v3-core/interfaces/pool/IUniswapV3PoolActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissionless pool actions\n/// @notice Contains pool methods that can be called by anyone\ninterface IUniswapV3PoolActions {\n    /// @notice Sets the initial price for the pool\n    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\n    function initialize(uint160 sqrtPriceX96) external;\n\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n    /// @param recipient The address for which the liquidity will be created\n    /// @param tickLower The lower tick of the position in which to add liquidity\n    /// @param tickUpper The upper tick of the position in which to add liquidity\n    /// @param amount The amount of liquidity to mint\n    /// @param data Any data that should be passed through to the callback\n    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Collects tokens owed to a position\n    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n    /// @param recipient The address which should receive the fees collected\n    /// @param tickLower The lower tick of the position for which to collect fees\n    /// @param tickUpper The upper tick of the position for which to collect fees\n    /// @param amount0Requested How much token0 should be withdrawn from the fees owed\n    /// @param amount1Requested How much token1 should be withdrawn from the fees owed\n    /// @return amount0 The amount of fees collected in token0\n    /// @return amount1 The amount of fees collected in token1\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n\n    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n    /// @dev Fees must be collected separately via a call to #collect\n    /// @param tickLower The lower tick of the position for which to burn liquidity\n    /// @param tickUpper The upper tick of the position for which to burn liquidity\n    /// @param amount How much liquidity to burn\n    /// @return amount0 The amount of token0 sent to the recipient\n    /// @return amount1 The amount of token1 sent to the recipient\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Swap token0 for token1, or token1 for token0\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n    /// @param recipient The address to receive the output of the swap\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n    /// @param data Any data to be passed through to the callback\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n\n    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\n    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\n    /// with 0 amount{0,1} and sending the donation amount(s) from the callback\n    /// @param recipient The address which will receive the token0 and token1 amounts\n    /// @param amount0 The amount of token0 to send\n    /// @param amount1 The amount of token1 to send\n    /// @param data Any data to be passed through to the callback\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n\n    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\n    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n    /// the input observationCardinalityNext.\n    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}\n"
    },
    "contracts/interfaces/uniswap-v3-core/interfaces/pool/IUniswapV3PoolDerivedState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that is not stored\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n/// blockchain. The functions here may have variable gas costs.\ninterface IUniswapV3PoolDerivedState {\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n    /// you must call it with secondsAgos = [3600, 0].\n    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n    /// timestamp\n    function observe(uint32[] calldata secondsAgos)\n        external\n        view\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n\n    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n    /// snapshot is taken and the second snapshot is taken.\n    /// @param tickLower The lower tick of the range\n    /// @param tickUpper The upper tick of the range\n    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n    /// @return secondsInside The snapshot of seconds per liquidity for the range\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n        external\n        view\n        returns (\n            int56 tickCumulativeInside,\n            uint160 secondsPerLiquidityInsideX128,\n            uint32 secondsInside\n        );\n}\n"
    },
    "contracts/interfaces/uniswap-v3-core/interfaces/pool/IUniswapV3PoolEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Events emitted by a pool\n/// @notice Contains all events emitted by the pool\ninterface IUniswapV3PoolEvents {\n    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\n    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\n    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\n    event Initialize(uint160 sqrtPriceX96, int24 tick);\n\n    /// @notice Emitted when liquidity is minted for a given position\n    /// @param sender The address that minted the liquidity\n    /// @param owner The owner of the position and recipient of any minted liquidity\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity minted to the position range\n    /// @param amount0 How much token0 was required for the minted liquidity\n    /// @param amount1 How much token1 was required for the minted liquidity\n    event Mint(\n        address sender,\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted when fees are collected by the owner of a position\n    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\n    /// @param owner The owner of the position for which fees are collected\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount0 The amount of token0 fees collected\n    /// @param amount1 The amount of token1 fees collected\n    event Collect(\n        address indexed owner,\n        address recipient,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount0,\n        uint128 amount1\n    );\n\n    /// @notice Emitted when a position's liquidity is removed\n    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\n    /// @param owner The owner of the position for which liquidity is removed\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity to remove\n    /// @param amount0 The amount of token0 withdrawn\n    /// @param amount1 The amount of token1 withdrawn\n    event Burn(\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted by the pool for any swaps between token0 and token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the output of the swap\n    /// @param amount0 The delta of the token0 balance of the pool\n    /// @param amount1 The delta of the token1 balance of the pool\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n    /// @param liquidity The liquidity of the pool after the swap\n    /// @param tick The log base 1.0001 of price of the pool after the swap\n    event Swap(\n        address indexed sender,\n        address indexed recipient,\n        int256 amount0,\n        int256 amount1,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        int24 tick\n    );\n\n    /// @notice Emitted by the pool for any flashes of token0/token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the tokens from flash\n    /// @param amount0 The amount of token0 that was flashed\n    /// @param amount1 The amount of token1 that was flashed\n    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\n    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\n    event Flash(\n        address indexed sender,\n        address indexed recipient,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 paid0,\n        uint256 paid1\n    );\n\n    /// @notice Emitted by the pool for increases to the number of observations that can be stored\n    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n    /// just before a mint/swap/burn.\n    /// @param observationCardinalityNextOld The previous value of the next observation cardinality\n    /// @param observationCardinalityNextNew The updated value of the next observation cardinality\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld,\n        uint16 observationCardinalityNextNew\n    );\n\n    /// @notice Emitted when the protocol fee is changed by the pool\n    /// @param feeProtocol0Old The previous value of the token0 protocol fee\n    /// @param feeProtocol1Old The previous value of the token1 protocol fee\n    /// @param feeProtocol0New The updated value of the token0 protocol fee\n    /// @param feeProtocol1New The updated value of the token1 protocol fee\n    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\n\n    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\n    /// @param sender The address that collects the protocol fees\n    /// @param recipient The address that receives the collected protocol fees\n    /// @param amount0 The amount of token0 protocol fees that is withdrawn\n    /// @param amount0 The amount of token1 protocol fees that is withdrawn\n    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\n}\n"
    },
    "contracts/interfaces/uniswap-v3-core/interfaces/pool/IUniswapV3PoolImmutables.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that never changes\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\ninterface IUniswapV3PoolImmutables {\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n    /// @return The contract address\n    function factory() external view returns (address);\n\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n    /// @return The fee\n    function fee() external view returns (uint24);\n\n    /// @notice The pool tick spacing\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n    /// This value is an int24 to avoid casting even though it is always positive.\n    /// @return The tick spacing\n    function tickSpacing() external view returns (int24);\n\n    /// @notice The maximum amount of position liquidity that can use any tick in the range\n    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n    /// @return The max amount of liquidity per tick\n    function maxLiquidityPerTick() external view returns (uint128);\n}\n"
    },
    "contracts/interfaces/uniswap-v3-core/interfaces/pool/IUniswapV3PoolOwnerActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissioned pool actions\n/// @notice Contains pool methods that may only be called by the factory owner\ninterface IUniswapV3PoolOwnerActions {\n    /// @notice Set the denominator of the protocol's % share of the fees\n    /// @param feeProtocol0 new protocol fee for token0 of the pool\n    /// @param feeProtocol1 new protocol fee for token1 of the pool\n    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\n\n    /// @notice Collect the protocol fee accrued to the pool\n    /// @param recipient The address to which collected protocol fees should be sent\n    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\n    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\n    /// @return amount0 The protocol fee collected in token0\n    /// @return amount1 The protocol fee collected in token1\n    function collectProtocol(\n        address recipient,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n}\n"
    },
    "contracts/interfaces/uniswap-v3-core/interfaces/pool/IUniswapV3PoolState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that can change\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\n/// per transaction\ninterface IUniswapV3PoolState {\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n    /// when accessed externally.\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n    /// boundary.\n    /// observationIndex The index of the last oracle observation that was written,\n    /// observationCardinality The current maximum number of observations stored in the pool,\n    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n    /// feeProtocol The protocol fee for both tokens of the pool.\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n    /// unlocked Whether the pool is currently locked to reentrancy\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal0X128() external view returns (uint256);\n\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal1X128() external view returns (uint256);\n\n    /// @notice The amounts of token0 and token1 that are owed to the protocol\n    /// @dev Protocol fees will never exceed uint128 max in either token\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n\n    /// @notice The currently in range liquidity available to the pool\n    /// @dev This value has no relationship to the total liquidity across all ticks\n    function liquidity() external view returns (uint128);\n\n    /// @notice Look up information about a specific tick in the pool\n    /// @param tick The tick to look up\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n    /// tick upper,\n    /// liquidityNet how much liquidity changes when the pool price crosses the tick,\n    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n    /// secondsOutside the seconds spent on the other side of the tick from the current tick,\n    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n    /// a specific position.\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n\n    /// @notice Returns the information about a position by the position's key\n    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\n    /// @return _liquidity The amount of liquidity in the position,\n    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\n    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\n    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\n    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    /// @notice Returns data about a specific observation index\n    /// @param index The element of the observations array to fetch\n    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n    /// ago, rather than at a specific index in the array.\n    /// @return blockTimestamp The timestamp of the observation,\n    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n    /// Returns initialized whether the observation has been initialized and the values are safe to use\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}\n"
    },
    "contracts/interfaces/uniswap-v3-core/IUniswapV3Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title The interface for the Uniswap V3 Factory\n/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees\ninterface IUniswapV3Factory {\n    /// @notice Emitted when the owner of the factory is changed\n    /// @param oldOwner The owner before the owner was changed\n    /// @param newOwner The owner after the owner was changed\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\n\n    /// @notice Emitted when a pool is created\n    /// @param token0 The first token of the pool by address sort order\n    /// @param token1 The second token of the pool by address sort order\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\n    /// @param pool The address of the created pool\n    event PoolCreated(\n        address indexed token0,\n        address indexed token1,\n        uint24 indexed fee,\n        int24 tickSpacing,\n        address pool\n    );\n\n    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory\n    /// @param fee The enabled fee, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee\n    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\n\n    /// @notice Returns the LP pool init code hash\n    /// @return The LP pool init code hash\n    function poolCodeHash() external pure returns (bytes32);\n\n    /// @notice Returns the current owner of the factory\n    /// @dev Can be changed by the current owner via setOwner\n    /// @return The address of the factory owner\n    function owner() external view returns (address);\n\n    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled\n    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\n    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\n    /// @return The tick spacing\n    function feeAmountTickSpacing(uint24 fee) external view returns (int24);\n\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\n    /// @param tokenA The contract address of either token0 or token1\n    /// @param tokenB The contract address of the other token\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @return pool The pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external view returns (address pool);\n\n    /// @notice Creates a pool for the given two tokens and fee\n    /// @param tokenA One of the two tokens in the desired pool\n    /// @param tokenB The other of the two tokens in the desired pool\n    /// @param fee The desired fee for the pool\n    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\n    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\n    /// are invalid.\n    /// @return pool The address of the newly created pool\n    function createPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external returns (address pool);\n\n    /// @notice Updates the owner of the factory\n    /// @dev Must be called by the current owner\n    /// @param _owner The new owner of the factory\n    function setOwner(address _owner) external;\n\n    /// @notice Enables a fee amount with the given tickSpacing\n    /// @dev Fee amounts may never be removed once enabled\n    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)\n    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount\n    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\n}\n"
    },
    "contracts/interfaces/uniswap-v3-core/IUniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nimport './pool/IUniswapV3PoolImmutables.sol';\nimport './pool/IUniswapV3PoolState.sol';\nimport './pool/IUniswapV3PoolDerivedState.sol';\nimport './pool/IUniswapV3PoolActions.sol';\nimport './pool/IUniswapV3PoolOwnerActions.sol';\nimport './pool/IUniswapV3PoolEvents.sol';\n\n/// @title The interface for a Uniswap V3 Pool\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface IUniswapV3Pool is\n    IUniswapV3PoolImmutables,\n    IUniswapV3PoolState,\n    IUniswapV3PoolDerivedState,\n    IUniswapV3PoolActions,\n    IUniswapV3PoolOwnerActions,\n    IUniswapV3PoolEvents\n{\n\n}\n"
    },
    "contracts/interfaces/uniswap-v3-core/IUniswapV3PoolDeployer.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title An interface for a contract that is capable of deploying Uniswap V3 Pools\n/// @notice A contract that constructs a pool must implement this to pass arguments to the pool\n/// @dev This is used to avoid having constructor arguments in the pool contract, which results in the init code hash\n/// of the pool being constant allowing the CREATE2 address of the pool to be cheaply computed on-chain\ninterface IUniswapV3PoolDeployer {\n    /// @notice Get the parameters to be used in constructing the pool, set transiently during pool creation.\n    /// @dev Called by the pool constructor to fetch the parameters of the pool\n    /// Returns factory The factory address\n    /// Returns token0 The first token of the pool by address sort order\n    /// Returns token1 The second token of the pool by address sort order\n    /// Returns fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// Returns tickSpacing The minimum number of ticks between initialized ticks\n    function parameters()\n        external\n        view\n        returns (\n            address factory,\n            address token0,\n            address token1,\n            uint24 fee,\n            int24 tickSpacing\n        );\n}\n"
    },
    "contracts/interfaces/uniswap-v3-core/pool/IUniswapV3PoolActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissionless pool actions\n/// @notice Contains pool methods that can be called by anyone\ninterface IUniswapV3PoolActions {\n    /// @notice Sets the initial price for the pool\n    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\n    function initialize(uint160 sqrtPriceX96) external;\n\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n    /// @param recipient The address for which the liquidity will be created\n    /// @param tickLower The lower tick of the position in which to add liquidity\n    /// @param tickUpper The upper tick of the position in which to add liquidity\n    /// @param amount The amount of liquidity to mint\n    /// @param data Any data that should be passed through to the callback\n    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Collects tokens owed to a position\n    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n    /// @param recipient The address which should receive the fees collected\n    /// @param tickLower The lower tick of the position for which to collect fees\n    /// @param tickUpper The upper tick of the position for which to collect fees\n    /// @param amount0Requested How much token0 should be withdrawn from the fees owed\n    /// @param amount1Requested How much token1 should be withdrawn from the fees owed\n    /// @return amount0 The amount of fees collected in token0\n    /// @return amount1 The amount of fees collected in token1\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n\n    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n    /// @dev Fees must be collected separately via a call to #collect\n    /// @param tickLower The lower tick of the position for which to burn liquidity\n    /// @param tickUpper The upper tick of the position for which to burn liquidity\n    /// @param amount How much liquidity to burn\n    /// @return amount0 The amount of token0 sent to the recipient\n    /// @return amount1 The amount of token1 sent to the recipient\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Swap token0 for token1, or token1 for token0\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n    /// @param recipient The address to receive the output of the swap\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n    /// @param data Any data to be passed through to the callback\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n\n    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\n    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\n    /// with 0 amount{0,1} and sending the donation amount(s) from the callback\n    /// @param recipient The address which will receive the token0 and token1 amounts\n    /// @param amount0 The amount of token0 to send\n    /// @param amount1 The amount of token1 to send\n    /// @param data Any data to be passed through to the callback\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n\n    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\n    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n    /// the input observationCardinalityNext.\n    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}\n"
    },
    "contracts/interfaces/uniswap-v3-core/pool/IUniswapV3PoolDerivedState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that is not stored\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n/// blockchain. The functions here may have variable gas costs.\ninterface IUniswapV3PoolDerivedState {\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n    /// you must call it with secondsAgos = [3600, 0].\n    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n    /// timestamp\n    function observe(uint32[] calldata secondsAgos)\n        external\n        view\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n\n    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n    /// snapshot is taken and the second snapshot is taken.\n    /// @param tickLower The lower tick of the range\n    /// @param tickUpper The upper tick of the range\n    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n    /// @return secondsInside The snapshot of seconds per liquidity for the range\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n        external\n        view\n        returns (\n            int56 tickCumulativeInside,\n            uint160 secondsPerLiquidityInsideX128,\n            uint32 secondsInside\n        );\n}\n"
    },
    "contracts/interfaces/uniswap-v3-core/pool/IUniswapV3PoolEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Events emitted by a pool\n/// @notice Contains all events emitted by the pool\ninterface IUniswapV3PoolEvents {\n    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\n    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\n    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\n    event Initialize(uint160 sqrtPriceX96, int24 tick);\n\n    /// @notice Emitted when liquidity is minted for a given position\n    /// @param sender The address that minted the liquidity\n    /// @param owner The owner of the position and recipient of any minted liquidity\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity minted to the position range\n    /// @param amount0 How much token0 was required for the minted liquidity\n    /// @param amount1 How much token1 was required for the minted liquidity\n    event Mint(\n        address sender,\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted when fees are collected by the owner of a position\n    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\n    /// @param owner The owner of the position for which fees are collected\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount0 The amount of token0 fees collected\n    /// @param amount1 The amount of token1 fees collected\n    event Collect(\n        address indexed owner,\n        address recipient,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount0,\n        uint128 amount1\n    );\n\n    /// @notice Emitted when a position's liquidity is removed\n    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\n    /// @param owner The owner of the position for which liquidity is removed\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity to remove\n    /// @param amount0 The amount of token0 withdrawn\n    /// @param amount1 The amount of token1 withdrawn\n    event Burn(\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted by the pool for any swaps between token0 and token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the output of the swap\n    /// @param amount0 The delta of the token0 balance of the pool\n    /// @param amount1 The delta of the token1 balance of the pool\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n    /// @param liquidity The liquidity of the pool after the swap\n    /// @param tick The log base 1.0001 of price of the pool after the swap\n    event Swap(\n        address indexed sender,\n        address indexed recipient,\n        int256 amount0,\n        int256 amount1,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        int24 tick\n    );\n\n    /// @notice Emitted by the pool for any flashes of token0/token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the tokens from flash\n    /// @param amount0 The amount of token0 that was flashed\n    /// @param amount1 The amount of token1 that was flashed\n    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\n    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\n    event Flash(\n        address indexed sender,\n        address indexed recipient,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 paid0,\n        uint256 paid1\n    );\n\n    /// @notice Emitted by the pool for increases to the number of observations that can be stored\n    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n    /// just before a mint/swap/burn.\n    /// @param observationCardinalityNextOld The previous value of the next observation cardinality\n    /// @param observationCardinalityNextNew The updated value of the next observation cardinality\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld,\n        uint16 observationCardinalityNextNew\n    );\n\n    /// @notice Emitted when the protocol fee is changed by the pool\n    /// @param feeProtocol0Old The previous value of the token0 protocol fee\n    /// @param feeProtocol1Old The previous value of the token1 protocol fee\n    /// @param feeProtocol0New The updated value of the token0 protocol fee\n    /// @param feeProtocol1New The updated value of the token1 protocol fee\n    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\n\n    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\n    /// @param sender The address that collects the protocol fees\n    /// @param recipient The address that receives the collected protocol fees\n    /// @param amount0 The amount of token0 protocol fees that is withdrawn\n    /// @param amount0 The amount of token1 protocol fees that is withdrawn\n    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\n}\n"
    },
    "contracts/interfaces/uniswap-v3-core/pool/IUniswapV3PoolImmutables.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that never changes\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\ninterface IUniswapV3PoolImmutables {\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n    /// @return The contract address\n    function factory() external view returns (address);\n\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n    /// @return The fee\n    function fee() external view returns (uint24);\n\n    /// @notice The pool tick spacing\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n    /// This value is an int24 to avoid casting even though it is always positive.\n    /// @return The tick spacing\n    function tickSpacing() external view returns (int24);\n\n    /// @notice The maximum amount of position liquidity that can use any tick in the range\n    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n    /// @return The max amount of liquidity per tick\n    function maxLiquidityPerTick() external view returns (uint128);\n}\n"
    },
    "contracts/interfaces/uniswap-v3-core/pool/IUniswapV3PoolOwnerActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissioned pool actions\n/// @notice Contains pool methods that may only be called by the factory owner\ninterface IUniswapV3PoolOwnerActions {\n    /// @notice Set the denominator of the protocol's % share of the fees\n    /// @param feeProtocol0 new protocol fee for token0 of the pool\n    /// @param feeProtocol1 new protocol fee for token1 of the pool\n    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\n\n    /// @notice Collect the protocol fee accrued to the pool\n    /// @param recipient The address to which collected protocol fees should be sent\n    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\n    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\n    /// @return amount0 The protocol fee collected in token0\n    /// @return amount1 The protocol fee collected in token1\n    function collectProtocol(\n        address recipient,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n}\n"
    },
    "contracts/interfaces/uniswap-v3-core/pool/IUniswapV3PoolState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that can change\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\n/// per transaction\ninterface IUniswapV3PoolState {\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n    /// when accessed externally.\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n    /// boundary.\n    /// observationIndex The index of the last oracle observation that was written,\n    /// observationCardinality The current maximum number of observations stored in the pool,\n    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n    /// feeProtocol The protocol fee for both tokens of the pool.\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n    /// unlocked Whether the pool is currently locked to reentrancy\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal0X128() external view returns (uint256);\n\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal1X128() external view returns (uint256);\n\n    /// @notice The amounts of token0 and token1 that are owed to the protocol\n    /// @dev Protocol fees will never exceed uint128 max in either token\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n\n    /// @notice The currently in range liquidity available to the pool\n    /// @dev This value has no relationship to the total liquidity across all ticks\n    function liquidity() external view returns (uint128);\n\n    /// @notice Look up information about a specific tick in the pool\n    /// @param tick The tick to look up\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n    /// tick upper,\n    /// liquidityNet how much liquidity changes when the pool price crosses the tick,\n    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n    /// secondsOutside the seconds spent on the other side of the tick from the current tick,\n    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n    /// a specific position.\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n\n    /// @notice Returns the information about a position by the position's key\n    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\n    /// @return _liquidity The amount of liquidity in the position,\n    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\n    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\n    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\n    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    /// @notice Returns data about a specific observation index\n    /// @param index The element of the observations array to fetch\n    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n    /// ago, rather than at a specific index in the array.\n    /// @return blockTimestamp The timestamp of the observation,\n    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n    /// Returns initialized whether the observation has been initialized and the values are safe to use\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}\n"
    },
    "contracts/interfaces/uniswap-v3-periphery/IERC721Permit.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\n\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/// @title ERC721 with permit\n/// @notice Extension to ERC721 that includes a permit function for signature based approvals\ninterface IERC721Permit is IERC721 {\n    /// @notice The permit typehash used in the permit signature\n    /// @return The typehash for the permit\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    /// @notice The domain separator used in the permit signature\n    /// @return The domain seperator used in encoding of permit signature\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    /// @notice Approve of a specific token ID for spending by spender via signature\n    /// @param spender The account that is being approved\n    /// @param tokenId The ID of the token that is being approved for spending\n    /// @param deadline The deadline timestamp by which the call must be mined for the approve to work\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n    function permit(\n        address spender,\n        uint256 tokenId,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable;\n}\n"
    },
    "contracts/interfaces/uniswap-v3-periphery/IMulticall.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\n/// @title Multicall interface\n/// @notice Enables calling multiple methods in a single call to the contract\ninterface IMulticall {\n    /// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n    /// @dev The `msg.value` should not be trusted for any method callable from multicall.\n    /// @param data The encoded function data for each of the calls to make to this contract\n    /// @return results The results from each of the calls passed in via data\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\n}\n"
    },
    "contracts/interfaces/uniswap-v3-periphery/INonfungiblePositionManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol';\nimport '@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol';\n\nimport './IPoolInitializer.sol';\nimport './IERC721Permit.sol';\nimport './IPeripheryPayments.sol';\nimport './IPeripheryImmutableState.sol';\n\n/// @title Non-fungible token for positions\n/// @notice Wraps Uniswap V3 positions in a non-fungible token interface which allows for them to be transferred\n/// and authorized.\ninterface INonfungiblePositionManager is\n    IPoolInitializer,\n    IPeripheryPayments,\n    IPeripheryImmutableState,\n    IERC721Metadata,\n    IERC721Enumerable,\n    IERC721Permit\n{\n    /// @notice Emitted when liquidity is increased for a position NFT\n    /// @dev Also emitted when a token is minted\n    /// @param tokenId The ID of the token for which liquidity was increased\n    /// @param liquidity The amount by which liquidity for the NFT position was increased\n    /// @param amount0 The amount of token0 that was paid for the increase in liquidity\n    /// @param amount1 The amount of token1 that was paid for the increase in liquidity\n    event IncreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);\n    /// @notice Emitted when liquidity is decreased for a position NFT\n    /// @param tokenId The ID of the token for which liquidity was decreased\n    /// @param liquidity The amount by which liquidity for the NFT position was decreased\n    /// @param amount0 The amount of token0 that was accounted for the decrease in liquidity\n    /// @param amount1 The amount of token1 that was accounted for the decrease in liquidity\n    event DecreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);\n    /// @notice Emitted when tokens are collected for a position NFT\n    /// @dev The amounts reported may not be exactly equivalent to the amounts transferred, due to rounding behavior\n    /// @param tokenId The ID of the token for which underlying tokens were collected\n    /// @param recipient The address of the account that received the collected tokens\n    /// @param amount0 The amount of token0 owed to the position that was collected\n    /// @param amount1 The amount of token1 owed to the position that was collected\n    event Collect(uint256 indexed tokenId, address recipient, uint256 amount0, uint256 amount1);\n\n    /// @notice Returns the position information associated with a given token ID.\n    /// @dev Throws if the token ID is not valid.\n    /// @param tokenId The ID of the token that represents the position\n    /// @return nonce The nonce for permits\n    /// @return operator The address that is approved for spending\n    /// @return token0 The address of the token0 for a specific pool\n    /// @return token1 The address of the token1 for a specific pool\n    /// @return fee The fee associated with the pool\n    /// @return tickLower The lower end of the tick range for the position\n    /// @return tickUpper The higher end of the tick range for the position\n    /// @return liquidity The liquidity of the position\n    /// @return feeGrowthInside0LastX128 The fee growth of token0 as of the last action on the individual position\n    /// @return feeGrowthInside1LastX128 The fee growth of token1 as of the last action on the individual position\n    /// @return tokensOwed0 The uncollected amount of token0 owed to the position as of the last computation\n    /// @return tokensOwed1 The uncollected amount of token1 owed to the position as of the last computation\n    function positions(uint256 tokenId)\n        external\n        view\n        returns (\n            uint96 nonce,\n            address operator,\n            address token0,\n            address token1,\n            uint24 fee,\n            int24 tickLower,\n            int24 tickUpper,\n            uint128 liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    struct MintParams {\n        address token0;\n        address token1;\n        uint24 fee;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        address recipient;\n        uint256 deadline;\n    }\n\n    /// @notice Creates a new position wrapped in a NFT\n    /// @dev Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized\n    /// a method does not exist, i.e. the pool is assumed to be initialized.\n    /// @param params The params necessary to mint a position, encoded as `MintParams` in calldata\n    /// @return tokenId The ID of the token that represents the minted position\n    /// @return liquidity The amount of liquidity for this position\n    /// @return amount0 The amount of token0\n    /// @return amount1 The amount of token1\n    function mint(MintParams calldata params)\n        external\n        payable\n        returns (\n            uint256 tokenId,\n            uint128 liquidity,\n            uint256 amount0,\n            uint256 amount1\n        );\n\n    struct IncreaseLiquidityParams {\n        uint256 tokenId;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    /// @notice Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`\n    /// @param params tokenId The ID of the token for which liquidity is being increased,\n    /// amount0Desired The desired amount of token0 to be spent,\n    /// amount1Desired The desired amount of token1 to be spent,\n    /// amount0Min The minimum amount of token0 to spend, which serves as a slippage check,\n    /// amount1Min The minimum amount of token1 to spend, which serves as a slippage check,\n    /// deadline The time by which the transaction must be included to effect the change\n    /// @return liquidity The new liquidity amount as a result of the increase\n    /// @return amount0 The amount of token0 to acheive resulting liquidity\n    /// @return amount1 The amount of token1 to acheive resulting liquidity\n    function increaseLiquidity(IncreaseLiquidityParams calldata params)\n        external\n        payable\n        returns (\n            uint128 liquidity,\n            uint256 amount0,\n            uint256 amount1\n        );\n\n    struct DecreaseLiquidityParams {\n        uint256 tokenId;\n        uint128 liquidity;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    /// @notice Decreases the amount of liquidity in a position and accounts it to the position\n    /// @param params tokenId The ID of the token for which liquidity is being decreased,\n    /// amount The amount by which liquidity will be decreased,\n    /// amount0Min The minimum amount of token0 that should be accounted for the burned liquidity,\n    /// amount1Min The minimum amount of token1 that should be accounted for the burned liquidity,\n    /// deadline The time by which the transaction must be included to effect the change\n    /// @return amount0 The amount of token0 accounted to the position's tokens owed\n    /// @return amount1 The amount of token1 accounted to the position's tokens owed\n    function decreaseLiquidity(DecreaseLiquidityParams calldata params)\n        external\n        payable\n        returns (uint256 amount0, uint256 amount1);\n\n    struct CollectParams {\n        uint256 tokenId;\n        address recipient;\n        uint128 amount0Max;\n        uint128 amount1Max;\n    }\n\n    /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient\n    /// @param params tokenId The ID of the NFT for which tokens are being collected,\n    /// recipient The account that should receive the tokens,\n    /// amount0Max The maximum amount of token0 to collect,\n    /// amount1Max The maximum amount of token1 to collect\n    /// @return amount0 The amount of fees collected in token0\n    /// @return amount1 The amount of fees collected in token1\n    function collect(CollectParams calldata params) external payable returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens\n    /// must be collected first.\n    /// @param tokenId The ID of the token that is being burned\n    function burn(uint256 tokenId) external payable;\n}\n"
    },
    "contracts/interfaces/uniswap-v3-periphery/IPeripheryImmutableState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Immutable state\n/// @notice Functions that return immutable state of the router\ninterface IPeripheryImmutableState {\n    /// @return Returns the address of the Uniswap V3 factory\n    function factory() external view returns (address);\n\n    /// @return Returns the address of WETH9\n    function WETH9() external view returns (address);\n}\n"
    },
    "contracts/interfaces/uniswap-v3-periphery/IPeripheryPayments.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\n\n/// @title Periphery Payments\n/// @notice Functions to ease deposits and withdrawals of ETH\ninterface IPeripheryPayments {\n    /// @notice Unwraps the contract's WETH9 balance and sends it to recipient as ETH.\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.\n    /// @param amountMinimum The minimum amount of WETH9 to unwrap\n    /// @param recipient The address receiving ETH\n    function unwrapWETH9(uint256 amountMinimum, address recipient) external payable;\n\n    /// @notice Refunds any ETH balance held by this contract to the `msg.sender`\n    /// @dev Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps\n    /// that use ether for the input amount\n    function refundETH() external payable;\n\n    /// @notice Transfers the full amount of a token held by this contract to recipient\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing the token from users\n    /// @param token The contract address of the token which will be transferred to `recipient`\n    /// @param amountMinimum The minimum amount of token required for a transfer\n    /// @param recipient The destination address of the token\n    function sweepToken(\n        address token,\n        uint256 amountMinimum,\n        address recipient\n    ) external payable;\n}\n"
    },
    "contracts/interfaces/uniswap-v3-periphery/IPoolInitializer.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\n/// @title Creates and initializes V3 Pools\n/// @notice Provides a method for creating and initializing a pool, if necessary, for bundling with other methods that\n/// require the pool to exist.\ninterface IPoolInitializer {\n    /// @notice Creates a new pool if it does not exist, then initializes if not initialized\n    /// @dev This method can be bundled with others via IMulticall for the first action (e.g. mint) performed against a pool\n    /// @param token0 The contract address of token0 of the pool\n    /// @param token1 The contract address of token1 of the pool\n    /// @param fee The fee amount of the v3 pool for the specified token pair\n    /// @param sqrtPriceX96 The initial square root price of the pool as a Q64.96 value\n    /// @return pool Returns the pool address based on the pair of tokens and fee, will return the newly created pool address if necessary\n    function createAndInitializePoolIfNecessary(\n        address token0,\n        address token1,\n        uint24 fee,\n        uint160 sqrtPriceX96\n    ) external payable returns (address pool);\n}\n"
    },
    "contracts/interfaces/uniswap-v3-staker/IUniswapV3Staker.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.6;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';\n\nimport '../uniswap-v3-core/IUniswapV3Factory.sol';\nimport '../uniswap-v3-core/IUniswapV3Pool.sol';\nimport '../uniswap-v3-core/IERC20Minimal.sol';\n\nimport '../uniswap-v3-periphery/INonfungiblePositionManager.sol';\nimport '../uniswap-v3-periphery/IMulticall.sol';\n\n/// @title Uniswap V3 Staker Interface\n/// @notice Allows staking nonfungible liquidity tokens in exchange for reward tokens\ninterface IUniswapV3Staker is IERC721Receiver, IMulticall {\n    /// @param rewardToken The token being distributed as a reward\n    /// @param pool The Uniswap V3 pool\n    /// @param startTime The time when the incentive program begins\n    /// @param endTime The time when rewards stop accruing\n    /// @param refundee The address which receives any remaining reward tokens when the incentive is ended\n    struct IncentiveKey {\n        IERC20Minimal rewardToken;\n        IUniswapV3Pool pool;\n        uint256 startTime;\n        uint256 endTime;\n        address refundee;\n    }\n\n    /// @notice The Uniswap V3 Factory\n    function factory() external view returns (IUniswapV3Factory);\n\n    /// @notice The nonfungible position manager with which this staking contract is compatible\n    function nonfungiblePositionManager() external view returns (INonfungiblePositionManager);\n\n    /// @notice The max duration of an incentive in seconds\n    function maxIncentiveDuration() external view returns (uint256);\n\n    /// @notice The max amount of seconds into the future the incentive startTime can be set\n    function maxIncentiveStartLeadTime() external view returns (uint256);\n\n    /// @notice Represents a staking incentive\n    /// @param incentiveId The ID of the incentive computed from its parameters\n    /// @return totalRewardUnclaimed The amount of reward token not yet claimed by users\n    /// @return totalSecondsClaimedX128 Total liquidity-seconds claimed, represented as a UQ32.128\n    /// @return numberOfStakes The count of deposits that are currently staked for the incentive\n    function incentives(bytes32 incentiveId)\n        external\n        view\n        returns (\n            uint256 totalRewardUnclaimed,\n            uint160 totalSecondsClaimedX128,\n            uint96 numberOfStakes\n        );\n\n    /// @notice Returns information about a deposited NFT\n    /// @return owner The owner of the deposited NFT\n    /// @return numberOfStakes Counter of how many incentives for which the liquidity is staked\n    /// @return tickLower The lower tick of the range\n    /// @return tickUpper The upper tick of the range\n    function deposits(uint256 tokenId)\n        external\n        view\n        returns (\n            address owner,\n            uint48 numberOfStakes,\n            int24 tickLower,\n            int24 tickUpper\n        );\n\n    /// @notice Returns information about a staked liquidity NFT\n    /// @param tokenId The ID of the staked token\n    /// @param incentiveId The ID of the incentive for which the token is staked\n    /// @return secondsPerLiquidityInsideInitialX128 secondsPerLiquidity represented as a UQ32.128\n    /// @return liquidity The amount of liquidity in the NFT as of the last time the rewards were computed\n    function stakes(uint256 tokenId, bytes32 incentiveId)\n        external\n        view\n        returns (uint160 secondsPerLiquidityInsideInitialX128, uint128 liquidity);\n\n    /// @notice Returns amounts of reward tokens owed to a given address according to the last time all stakes were updated\n    /// @param rewardToken The token for which to check rewards\n    /// @param owner The owner for which the rewards owed are checked\n    /// @return rewardsOwed The amount of the reward token claimable by the owner\n    function rewards(IERC20Minimal rewardToken, address owner) external view returns (uint256 rewardsOwed);\n\n    /// @notice Creates a new liquidity mining incentive program\n    /// @param key Details of the incentive to create\n    /// @param reward The amount of reward tokens to be distributed\n    function createIncentive(IncentiveKey memory key, uint256 reward) external;\n\n    /// @notice Ends an incentive after the incentive end time has passed and all stakes have been withdrawn\n    /// @param key Details of the incentive to end\n    /// @return refund The remaining reward tokens when the incentive is ended\n    function endIncentive(IncentiveKey memory key) external returns (uint256 refund);\n\n    /// @notice Transfers ownership of a deposit from the sender to the given recipient\n    /// @param tokenId The ID of the token (and the deposit) to transfer\n    /// @param to The new owner of the deposit\n    function transferDeposit(uint256 tokenId, address to) external;\n\n    /// @notice Withdraws a Uniswap V3 LP token `tokenId` from this contract to the recipient `to`\n    /// @param tokenId The unique identifier of an Uniswap V3 LP token\n    /// @param to The address where the LP token will be sent\n    /// @param data An optional data array that will be passed along to the `to` address via the NFT safeTransferFrom\n    function withdrawToken(\n        uint256 tokenId,\n        address to,\n        bytes memory data\n    ) external;\n\n    /// @notice Stakes a Uniswap V3 LP token\n    /// @param key The key of the incentive for which to stake the NFT\n    /// @param tokenId The ID of the token to stake\n    function stakeToken(IncentiveKey memory key, uint256 tokenId) external;\n\n    /// @notice Unstakes a Uniswap V3 LP token\n    /// @param key The key of the incentive for which to unstake the NFT\n    /// @param tokenId The ID of the token to unstake\n    function unstakeToken(IncentiveKey memory key, uint256 tokenId) external;\n\n    /// @notice Transfers `amountRequested` of accrued `rewardToken` rewards from the contract to the recipient `to`\n    /// @param rewardToken The token being distributed as a reward\n    /// @param to The address where claimed rewards will be sent to\n    /// @param amountRequested The amount of reward tokens to claim. Claims entire reward amount if set to 0.\n    /// @return reward The amount of reward tokens claimed\n    function claimReward(\n        IERC20Minimal rewardToken,\n        address to,\n        uint256 amountRequested\n    ) external returns (uint256 reward);\n\n    /// @notice Calculates the reward amount that will be received for the given stake\n    /// @param key The key of the incentive\n    /// @param tokenId The ID of the token\n    /// @return reward The reward accrued to the NFT for the given incentive thus far\n    function getRewardInfo(IncentiveKey memory key, uint256 tokenId)\n        external\n        returns (uint256 reward, uint160 secondsInsideX128);\n\n    /// @notice Event emitted when a liquidity mining incentive has been created\n    /// @param rewardToken The token being distributed as a reward\n    /// @param pool The Uniswap V3 pool\n    /// @param startTime The time when the incentive program begins\n    /// @param endTime The time when rewards stop accruing\n    /// @param refundee The address which receives any remaining reward tokens after the end time\n    /// @param reward The amount of reward tokens to be distributed\n    event IncentiveCreated(\n        IERC20Minimal indexed rewardToken,\n        IUniswapV3Pool indexed pool,\n        uint256 startTime,\n        uint256 endTime,\n        address refundee,\n        uint256 reward\n    );\n\n    /// @notice Event that can be emitted when a liquidity mining incentive has ended\n    /// @param incentiveId The incentive which is ending\n    /// @param refund The amount of reward tokens refunded\n    event IncentiveEnded(bytes32 indexed incentiveId, uint256 refund);\n\n    /// @notice Emitted when ownership of a deposit changes\n    /// @param tokenId The ID of the deposit (and token) that is being transferred\n    /// @param oldOwner The owner before the deposit was transferred\n    /// @param newOwner The owner after the deposit was transferred\n    event DepositTransferred(uint256 indexed tokenId, address indexed oldOwner, address indexed newOwner);\n\n    /// @notice Event emitted when a Uniswap V3 LP token has been staked\n    /// @param tokenId The unique identifier of an Uniswap V3 LP token\n    /// @param liquidity The amount of liquidity staked\n    /// @param incentiveId The incentive in which the token is staking\n    event TokenStaked(uint256 indexed tokenId, bytes32 indexed incentiveId, uint128 liquidity);\n\n    /// @notice Event emitted when a Uniswap V3 LP token has been unstaked\n    /// @param tokenId The unique identifier of an Uniswap V3 LP token\n    /// @param incentiveId The incentive in which the token is staking\n    event TokenUnstaked(uint256 indexed tokenId, bytes32 indexed incentiveId);\n\n    /// @notice Event emitted when a reward token has been claimed\n    /// @param to The address where claimed rewards were sent to\n    /// @param reward The amount of reward tokens claimed\n    event RewardClaimed(address indexed to, uint256 reward);\n}\n"
    },
    "contracts/src/bureaucracy/dutchAuction/DutchAuction.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport {IDutchAuction} from \"../../interfaces/bureaucracy/dutchAuction/IDutchAuction.sol\";\nimport {ITheReserveRoutes} from \"../../interfaces/bureaucracy/theReserve/ITheReserveRoutes.sol\";\n\nimport {DutchAuctionActions} from \"./DutchAuctionActions.sol\";\nimport {DutchAuctionAdminActions} from \"./DutchAuctionAdminActions.sol\";\nimport {DutchAuctionRoutes} from \"./DutchAuctionRoutes.sol\";\n\n/**\n * @title Bureau of the Dutch Auction\n */\ncontract DutchAuction is DutchAuctionAdminActions, DutchAuctionActions {\n  //////////////////////////////////////////////////////////////////////////////\n  // Initialization\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Initializes the Dutch Auction contract\n   *\n   * @param owner_ The owner of the Dutch Auction\n   * @param theReserve_ The Reserve smart contract\n   */\n  constructor(\n    address owner_,\n    address theReserve_\n  )\n    DutchAuctionAdminActions(owner_)\n    DutchAuctionRoutes(ITheReserveRoutes(theReserve_).getRoutes())\n  {\n    // Initialize auction settings\n    _auctionSettings = AuctionSettings({\n      priceDecayRate: DECAY_CONSTANT,\n      mintDustAmount: 1_000,\n      priceIncrement: GROWTH_RATE,\n      initialPriceBips: INITIAL_PRICE_BIPS,\n      minPriceBips: MIN_PRICE_BIPS,\n      maxPriceBips: MAX_PRICE_BIPS\n    });\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IERC165} via {IDutchAuction}, {DutchAuctionAdminActions}\n  // and {DutchAuctionActions}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IERC165-supportsInterface}\n   */\n  function supportsInterface(\n    bytes4 interfaceId\n  )\n    public\n    view\n    virtual\n    override(DutchAuctionAdminActions, DutchAuctionActions)\n    returns (bool)\n  {\n    return super.supportsInterface(interfaceId);\n  }\n}\n"
    },
    "contracts/src/bureaucracy/dutchAuction/DutchAuctionActions.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport {INonfungiblePositionManager} from \"../../../interfaces/uniswap-v3-periphery/INonfungiblePositionManager.sol\";\n\nimport {IDutchAuctionActions} from \"../../interfaces/bureaucracy/dutchAuction/IDutchAuctionActions.sol\";\nimport {VRGDA} from \"../../utils/auction/VRGDA.sol\";\nimport {LiquidityMath} from \"../../utils/math/LiquidityMath.sol\";\n\nimport {DutchAuctionBase} from \"./DutchAuctionBase.sol\";\n\n/**\n * @title Bureau of the Dutch Auction\n */\nabstract contract DutchAuctionActions is\n  IDutchAuctionActions,\n  DutchAuctionBase\n{\n  using EnumerableSet for EnumerableSet.UintSet;\n  using SafeERC20 for IERC20;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IERC165} via {IDutchAuctionActions},\n  // {DutchAuctionRoutes} and {DutchAuctionState}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IERC165-supportsInterface}\n   */\n  function supportsInterface(\n    bytes4 interfaceId\n  ) public view virtual override(IERC165, DutchAuctionBase) returns (bool) {\n    return\n      super.supportsInterface(interfaceId) ||\n      interfaceId == type(IDutchAuctionActions).interfaceId;\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IDutchAuctionActions}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IDutchAuctionActions-purchase}\n   */\n  function purchase(\n    uint256 lpNftTokenId,\n    uint256 pow1Amount,\n    uint256 marketTokenAmount,\n    address beneficiary,\n    address receiver\n  ) external override nonReentrant {\n    // Validate parameters\n    require(lpNftTokenId != 0, \"Invalid LP-NFT ID\");\n    require(pow1Amount > 0 || marketTokenAmount > 0, \"Invalid payment\");\n    require(beneficiary != address(0), \"Invalid beneficiary\");\n    require(receiver != address(0), \"Invalid receiver\");\n\n    // Read state\n    AuctionState storage auction = _auctionStates[lpNftTokenId];\n\n    // Validate state\n    // slither-disable-next-line timestamp\n    require(auction.lpNftTokenId != 0, \"LP-NFT not for sale\");\n    // slither-disable-next-line incorrect-equality,timestamp\n    require(auction.salePrice == 0, \"Auction already sold\");\n\n    // Get the current price in bips of the LP-NFT\n    uint256 currentPriceBips = getCurrentPriceBips(lpNftTokenId);\n\n    // Update state\n    _bureauState.lastSalePriceBips = currentPriceBips;\n    auction.salePrice = currentPriceBips;\n\n    // Call external contracts\n    if (pow1Amount > 0) {\n      _routes.pow1Token.safeTransferFrom(\n        _msgSender(),\n        address(this),\n        pow1Amount\n      );\n    }\n    if (marketTokenAmount > 0) {\n      _routes.marketToken.safeTransferFrom(\n        _msgSender(),\n        address(this),\n        marketTokenAmount\n      );\n    }\n\n    // Amounts to deposit\n    uint256 pow1DepositAmount = pow1Amount;\n    uint256 marketDepositAmount = marketTokenAmount;\n\n    // Handle the tip\n    {\n      // Calculate the auction tip amounts\n      uint256 pow1TipAmount = (pow1Amount * currentPriceBips) / 1e18;\n      uint256 marketTipAmount = (marketTokenAmount * currentPriceBips) / 1e18;\n\n      require(pow1TipAmount > 0 || marketTipAmount > 0, \"Invalid tips\");\n\n      // Send the tip to the beneficiary (TODO)\n      if (pow1TipAmount > 0) {\n        _routes.pow1Token.safeTransfer(beneficiary, pow1TipAmount);\n        pow1DepositAmount -= pow1TipAmount;\n      }\n      if (marketTipAmount > 0) {\n        _routes.marketToken.safeTransfer(beneficiary, marketTipAmount);\n        marketDepositAmount -= marketTipAmount;\n      }\n    }\n\n    // Get the pool fee\n    uint24 poolFee = _routes.pow1MarketPool.fee();\n\n    // Perform single-sided supply swap\n    // slither-disable-next-line incorrect-equality\n    if (pow1DepositAmount == 0) {\n      // Get market token reserve\n      uint256 marketTokenReserve = _routes.marketToken.balanceOf(\n        address(_routes.pow1MarketPool)\n      );\n\n      // Calculate market swap amount\n      uint256 marketSwapAmount = LiquidityMath.computeSwapAmountV2(\n        marketTokenReserve,\n        marketDepositAmount,\n        poolFee\n      );\n      require(marketSwapAmount <= marketDepositAmount, \"Bad liquidity math\");\n\n      // Approve swap\n      _routes.marketToken.safeIncreaseAllowance(\n        address(_routes.pow1MarketSwapper),\n        marketSwapAmount\n      );\n\n      // Perform swap\n      // slither-disable-next-line reentrancy-no-eth\n      pow1DepositAmount = _routes.pow1MarketSwapper.buyGameToken(\n        marketSwapAmount,\n        address(this)\n      );\n\n      // Update amount\n      marketDepositAmount -= marketSwapAmount;\n      // slither-disable-next-line incorrect-equality\n    } else if (marketDepositAmount == 0) {\n      // Get POW1 reserve\n      uint256 pow1Reserve = _routes.pow1Token.balanceOf(\n        address(_routes.pow1MarketPool)\n      );\n\n      // Calculate POW1 swap amount\n      uint256 pow1SwapAmount = LiquidityMath.computeSwapAmountV2(\n        pow1Reserve,\n        pow1DepositAmount,\n        poolFee\n      );\n      require(pow1SwapAmount <= pow1DepositAmount, \"Bad liquidity math\");\n\n      // Approve swap\n      _routes.pow1Token.safeIncreaseAllowance(\n        address(_routes.pow1MarketSwapper),\n        pow1SwapAmount\n      );\n\n      // Perform swap\n      marketDepositAmount = _routes.pow1MarketSwapper.sellGameToken(\n        pow1SwapAmount,\n        address(this)\n      );\n\n      // Update amount\n      pow1DepositAmount -= pow1SwapAmount;\n    }\n\n    // Read state\n    uint256 mintDustAmount = _auctionSettings.mintDustAmount;\n\n    // Validate amounts\n    require(\n      pow1DepositAmount > mintDustAmount &&\n        marketDepositAmount > mintDustAmount,\n      \"Not enough for dust\"\n    );\n\n    // Remove the LP-NFT token ID from current auctions\n    require(_currentAuctions.remove(lpNftTokenId), \"Auction not found\");\n\n    // Mint a new LP-NFT and establish its auction state\n    // slither-disable-next-line reentrancy-no-eth\n    uint256 newLpNftTokenId = _mintLpNft(mintDustAmount, mintDustAmount);\n    _establishAuctionState(newLpNftTokenId);\n\n    // Call external contracts\n    if (pow1DepositAmount > 0) {\n      _routes.pow1Token.safeIncreaseAllowance(\n        address(_routes.uniswapV3NftManager),\n        pow1DepositAmount\n      );\n    }\n    if (marketDepositAmount > 0) {\n      _routes.marketToken.safeIncreaseAllowance(\n        address(_routes.uniswapV3NftManager),\n        marketDepositAmount\n      );\n    }\n\n    // Deposit liquidity\n    // slither-disable-next-line unused-return\n    _routes.uniswapV3NftManager.increaseLiquidity(\n      INonfungiblePositionManager.IncreaseLiquidityParams({\n        tokenId: lpNftTokenId,\n        amount0Desired: address(_routes.pow1Token) <\n          address(_routes.marketToken)\n          ? pow1DepositAmount\n          : marketDepositAmount,\n        amount1Desired: address(_routes.pow1Token) <\n          address(_routes.marketToken)\n          ? marketDepositAmount\n          : pow1DepositAmount,\n        amount0Min: 0,\n        amount1Min: 0,\n        // slither-disable-next-line timestamp\n        deadline: block.timestamp\n      })\n    );\n\n    // Stake LP-NFT in the stake farm\n    _routes.uniswapV3NftManager.safeTransferFrom(\n      address(this),\n      address(_routes.pow1LpNftStakeFarm),\n      lpNftTokenId,\n      \"\"\n    );\n\n    // Return the LP-SFT to the receiver\n    _routes.lpSft.safeTransferFrom(\n      address(this),\n      receiver,\n      lpNftTokenId,\n      1,\n      \"\"\n    );\n\n    // Refund any excess tokens to the buyer\n    uint256 remainingMarketTokens = _routes.marketToken.balanceOf(\n      address(this)\n    );\n    if (remainingMarketTokens > 0) {\n      _routes.marketToken.safeTransfer(msg.sender, remainingMarketTokens);\n    }\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Internal helper functions\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Computes the tip amount based on the purchase price\n   *\n   * @param price The purchase price of the LP-NFT\n   * @return tip The calculated tip amount\n   */\n  function _computeTip(uint256 price) private pure returns (uint256 tip) {\n    // Example: Tip is 1% of the purchase price\n    tip = (price * 1e16) / 1e18; // 1% of price scaled by 1e18\n  }\n}\n"
    },
    "contracts/src/bureaucracy/dutchAuction/DutchAuctionAdminActions.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {INonfungiblePositionManager} from \"../../../interfaces/uniswap-v3-periphery/INonfungiblePositionManager.sol\";\n\nimport {IDutchAuctionAdminActions} from \"../../interfaces/bureaucracy/dutchAuction/IDutchAuctionAdminActions.sol\";\nimport {VRGDA} from \"../../utils/auction/VRGDA.sol\";\nimport {LiquidityMath} from \"../../utils/math/LiquidityMath.sol\";\n\nimport {DutchAuctionBase} from \"./DutchAuctionBase.sol\";\n\n/**\n * @title Bureau of the Dutch Auction\n */\nabstract contract DutchAuctionAdminActions is\n  IDutchAuctionAdminActions,\n  DutchAuctionBase\n{\n  using SafeERC20 for IERC20;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Initialization\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Initializes the Dutch Auction contract\n   *\n   * @param owner_ The owner of the Dutch Auction\n   */\n  constructor(address owner_) {\n    // Validate parameters\n    require(owner_ != address(0), \"Invalid owner\");\n\n    // Initialize {AccessControl}\n    _grantRole(DEFAULT_ADMIN_ROLE, owner_);\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IERC165} via {AccessControl},\n  // {IDutchAuctionAdminActions}, {DutchAuctionRoutes} and {DutchAuctionState}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IERC165-supportsInterface}\n   */\n  function supportsInterface(\n    bytes4 interfaceId\n  ) public view virtual override(IERC165, DutchAuctionBase) returns (bool) {\n    return\n      super.supportsInterface(interfaceId) ||\n      interfaceId == type(IDutchAuctionAdminActions).interfaceId;\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IDutchAuctionAdminActions}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IDutchAuction-initialize}\n   */\n  function initialize(\n    uint256 pow1Amount,\n    uint256 marketTokenAmount,\n    address receiver\n  ) external override nonReentrant returns (uint256 nftTokenId) {\n    // Validate access\n    _checkRole(DEFAULT_ADMIN_ROLE);\n\n    // Validate parameters\n    require(pow1Amount > 0, \"Invalid POW1 amount\");\n    require(marketTokenAmount > 0, \"Invalid market amount\");\n    require(receiver != address(0), \"Invalid receiver\");\n\n    // Validate state\n    require(!_initialized, \"Already initialized\");\n\n    // Update state\n    _initialized = true;\n\n    // Call external contracts\n    _routes.pow1Token.safeTransferFrom(_msgSender(), address(this), pow1Amount);\n    _routes.marketToken.safeTransferFrom(\n      _msgSender(),\n      address(this),\n      marketTokenAmount\n    );\n\n    _routes.pow1Token.safeIncreaseAllowance(\n      address(_routes.pow1MarketPooler),\n      pow1Amount\n    );\n    _routes.marketToken.safeIncreaseAllowance(\n      address(_routes.pow1MarketPooler),\n      marketTokenAmount\n    );\n\n    // Mint an LP-NFT\n    nftTokenId = _routes.pow1MarketPooler.mintLpNftImbalance(\n      pow1Amount,\n      marketTokenAmount,\n      address(this)\n    );\n\n    // Stake LP-NFT in the stake farm\n    _routes.uniswapV3NftManager.safeTransferFrom(\n      address(this),\n      address(_routes.pow1LpNftStakeFarm),\n      nftTokenId,\n      \"\"\n    );\n\n    // Get newly-minted LP-SFT address\n    address lpSftAddress = _routes.lpSft.tokenIdToAddress(nftTokenId);\n    require(lpSftAddress != address(0), \"Invalid LP-SFT\");\n\n    // Send POW1 dust to the LP-SFT\n    uint256 pow1Dust = _routes.pow1Token.balanceOf(address(this));\n    if (pow1Dust > 0) {\n      _routes.pow1Token.safeTransfer(lpSftAddress, pow1Dust);\n    }\n\n    // Send asset token dust to the receiver\n    uint256 marketTokenDust = _routes.marketToken.balanceOf(address(this));\n    if (marketTokenDust > 0) {\n      _routes.marketToken.safeTransfer(receiver, marketTokenDust);\n    }\n\n    // Return the LP-SFT to the receiver\n    _routes.lpSft.safeTransferFrom(address(this), receiver, nftTokenId, 1, \"\");\n\n    return nftTokenId;\n  }\n\n  /**\n   * @dev See {IDutchAuctionAdminActions-isInitialized}\n   */\n  function isInitialized() external view override returns (bool) {\n    // Read state\n    return _initialized;\n  }\n\n  /**\n   * @dev See {IDutchAuctionAdminActions-setAuctionCount}\n   */\n  function setAuctionCount(\n    uint32 auctionCount,\n    uint256 marketTokenDust\n  ) external override {\n    // Validate access\n    _checkRole(DEFAULT_ADMIN_ROLE);\n\n    // Validate state\n    require(_initialized, \"Not initialized\");\n\n    // Read state\n    uint32 currentAuctionCount = _targetLpNftCount;\n\n    // Update state\n    _targetLpNftCount = auctionCount;\n\n    // Mint additional LP-NFTs if necessary\n    if (auctionCount > currentAuctionCount) {\n      uint32 lpNftsToMint = auctionCount - currentAuctionCount;\n\n      // Procure dust\n      _routes.marketToken.safeTransferFrom(\n        _msgSender(),\n        address(this),\n        marketTokenDust\n      );\n\n      // Perform swaps and mint LP-NFTs\n      _mintAndInitializeAuctions(lpNftsToMint, marketTokenDust);\n\n      // Handle remaining tokens and dust\n      _handleRemainingTokens();\n    }\n  }\n\n  /**\n   * @dev See {IDutchAuctionAdminActions-getAuctionCount}\n   */\n  function getAuctionCount() external view override returns (uint32) {\n    // Read state\n    return _targetLpNftCount;\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Internal helper functions\n  //////////////////////////////////////////////////////////////////////////////\n\n  function _mintAndInitializeAuctions(\n    uint256 lpNftsToMint,\n    uint256 marketTokenDust\n  ) private {\n    // Get market token reserve\n    uint256 marketTokenReserve = _routes.marketToken.balanceOf(\n      address(_routes.pow1MarketPool)\n    );\n\n    // Get the pool fee\n    uint24 poolFee = _routes.pow1MarketPool.fee();\n\n    // Calculate swap amount\n    uint256 swapAmount = LiquidityMath.computeSwapAmountV2(\n      marketTokenReserve,\n      marketTokenDust,\n      poolFee\n    );\n    require(swapAmount <= marketTokenDust, \"Bad liquidity math\");\n\n    // Approve swap\n    _routes.marketToken.safeIncreaseAllowance(\n      address(_routes.pow1MarketSwapper),\n      swapAmount\n    );\n\n    // Perform swap\n    // slither-disable-next-line unused-return,reentrancy-benign\n    _routes.pow1MarketSwapper.buyGameToken(swapAmount, address(this));\n\n    // Mint LP-NFTs\n    for (uint256 i = 0; i < lpNftsToMint; i++) {\n      // Read external state\n      // slither-disable-next-line calls-loop\n      uint256 currentPow1Amount = _routes.pow1Token.balanceOf(address(this));\n      // slither-disable-next-line calls-loop\n      uint256 currentMarketTokenAmount = _routes.marketToken.balanceOf(\n        address(this)\n      );\n\n      // Mint an LP-NFT\n      uint256 lpNftTokenId = _mintLpNft(\n        currentPow1Amount,\n        currentMarketTokenAmount\n      );\n\n      // Establish auction state for the new LP-NFT\n      _establishAuctionState(lpNftTokenId);\n    }\n  }\n\n  function _handleRemainingTokens() private {\n    // Read external state\n    uint256 remainingPow1 = _routes.pow1Token.balanceOf(address(this));\n\n    // Swap the POW1 dust back into the market token\n    if (remainingPow1 > 0) {\n      // Approve swap\n      _routes.pow1Token.safeIncreaseAllowance(\n        address(_routes.pow1MarketSwapper),\n        remainingPow1\n      );\n\n      // Perform swap\n      // slither-disable-next-line unused-return\n      _routes.pow1MarketSwapper.sellGameToken(remainingPow1, address(this));\n    }\n\n    // Read external state\n    uint256 remainingMarketToken = _routes.marketToken.balanceOf(address(this));\n\n    // Return the market token dust to the sender\n    if (remainingMarketToken > 0) {\n      _routes.marketToken.safeTransfer(_msgSender(), remainingMarketToken);\n    }\n  }\n}\n"
    },
    "contracts/src/bureaucracy/dutchAuction/DutchAuctionBase.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport {IDutchAuctionErrors} from \"../../interfaces/bureaucracy/dutchAuction/IDutchAuctionErrors.sol\";\nimport {INonfungiblePositionManager} from \"../../../interfaces/uniswap-v3-periphery/INonfungiblePositionManager.sol\";\n\nimport {IDutchAuction} from \"../../interfaces/bureaucracy/dutchAuction/IDutchAuction.sol\";\n\nimport {DutchAuctionState} from \"./DutchAuctionState.sol\";\n\n/**\n * @title Bureau of the Dutch Auction, Base Functionality\n */\nabstract contract DutchAuctionBase is\n  IDutchAuctionErrors,\n  AccessControl,\n  ReentrancyGuard,\n  DutchAuctionState\n{\n  using EnumerableSet for EnumerableSet.UintSet;\n  using SafeERC20 for IERC20;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IERC165} via {IDutchAuction}, {AccessControl}\n  // and {IDutchAuctionState}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IERC165-supportsInterface}\n   */\n  function supportsInterface(\n    bytes4 interfaceId\n  )\n    public\n    view\n    virtual\n    override(AccessControl, DutchAuctionState)\n    returns (bool)\n  {\n    return\n      super.supportsInterface(interfaceId) ||\n      interfaceId == type(IDutchAuction).interfaceId;\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Internal utility functions\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Mint an LP-NFT\n   *\n   * Tokens provided are returned, minus a small amount lost to dust.\n   *\n   * @param pow1Amount The amount of POW1 used to mint the LP-NFT\n   * @param marketTokenAmount The amount of the market token used to mint the LP-NFT\n   *\n   * @return lpNftTokenId The token ID of the LP-NFT minted\n   */\n  function _mintLpNft(\n    uint256 pow1Amount,\n    uint256 marketTokenAmount\n  ) internal returns (uint256 lpNftTokenId) {\n    // Uniswap V3 cannot mint a token with zero liquidity\n    require(pow1Amount > 0, \"No POW1\");\n    require(marketTokenAmount > 0, \"No market token\");\n\n    // Approve pooler to spend tokens\n    _routes.pow1Token.safeIncreaseAllowance(\n      address(_routes.pow1MarketPooler),\n      pow1Amount\n    );\n    _routes.marketToken.safeIncreaseAllowance(\n      address(_routes.pow1MarketPooler),\n      marketTokenAmount\n    );\n\n    // Mint an LP-NFT\n    // slither-disable-next-line calls-loop\n    lpNftTokenId = _routes.pow1MarketPooler.mintLpNftImbalance(\n      pow1Amount,\n      marketTokenAmount,\n      address(this)\n    );\n\n    // Validate external state\n    // slither-disable-next-line calls-loop\n    require(\n      _routes.uniswapV3NftManager.ownerOf(lpNftTokenId) == address(this),\n      \"Not owner\"\n    );\n\n    // Read external state\n    // slither-disable-next-line calls-loop,unused-return\n    (, , , , , , , uint128 liquidityAmount, , , , ) = _routes\n      .uniswapV3NftManager\n      .positions(lpNftTokenId);\n\n    // Withdraw tokens from the pool\n    // slither-disable-next-line calls-loop,reentrancy-no-eth,unused-return\n    _routes.uniswapV3NftManager.decreaseLiquidity(\n      INonfungiblePositionManager.DecreaseLiquidityParams({\n        tokenId: lpNftTokenId,\n        liquidity: liquidityAmount,\n        amount0Min: 0,\n        amount1Min: 0,\n        deadline: block.timestamp\n      })\n    );\n\n    // Collect the tokens and fees\n    // slither-disable-next-line calls-loop,reentrancy-no-eth,unused-return\n    _routes.uniswapV3NftManager.collect(\n      INonfungiblePositionManager.CollectParams({\n        tokenId: lpNftTokenId,\n        recipient: address(this),\n        amount0Max: type(uint128).max,\n        amount1Max: type(uint128).max\n      })\n    );\n\n    return lpNftTokenId;\n  }\n\n  function _establishAuctionState(uint256 lpNftTokenId) internal {\n    // Calculate starting price for the new LP-NFT\n    uint256 startingPriceBips = _calculateNextStartingPriceBips();\n\n    // Initialize AuctionState for the new LP-NFT\n    AuctionState memory newAuctionState = AuctionState({\n      lpNftTokenId: lpNftTokenId,\n      startPriceBips: startingPriceBips,\n      endPriceBips: _auctionSettings.minPriceBips,\n      startTime: block.timestamp,\n      salePrice: 0\n    });\n\n    // Store the auction state\n    _auctionStates[lpNftTokenId] = newAuctionState;\n\n    // Update BureauState\n    _bureauState.totalAuctions += 1;\n\n    // Add lpNftTokenId to current auctions set\n    require(_currentAuctions.add(lpNftTokenId), \"Already added\");\n  }\n\n  /**\n   * @dev Calculates the starting price for the next LP-NFT based on the growth rate\n   *\n   * @return newStartingPriceBips The calculated starting price (scaled by 1e18)\n   */\n  function _calculateNextStartingPriceBips()\n    internal\n    view\n    returns (uint256 newStartingPriceBips)\n  {\n    uint256 lastSalePriceBips = _bureauState.lastSalePriceBips;\n\n    // TODO\n    // Calculate new starting price using growth rate\n    // slither-disable-next-line incorrect-equality\n    if (lastSalePriceBips == 0) {\n      newStartingPriceBips = _auctionSettings.initialPriceBips;\n    } else {\n      newStartingPriceBips = lastSalePriceBips * 2;\n    }\n\n    // Ensure new price does not exceed max price\n    if (newStartingPriceBips > _auctionSettings.maxPriceBips) {\n      newStartingPriceBips = _auctionSettings.maxPriceBips;\n    }\n\n    return newStartingPriceBips;\n  }\n}\n"
    },
    "contracts/src/bureaucracy/dutchAuction/DutchAuctionRoutes.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {IUniswapV3Factory} from \"../../../interfaces/uniswap-v3-core/IUniswapV3Factory.sol\";\nimport {IUniswapV3Pool} from \"../../../interfaces/uniswap-v3-core/IUniswapV3Pool.sol\";\nimport {INonfungiblePositionManager} from \"../../../interfaces/uniswap-v3-periphery/INonfungiblePositionManager.sol\";\n\nimport {IDutchAuctionRoutes} from \"../../interfaces/bureaucracy/dutchAuction/IDutchAuctionRoutes.sol\";\nimport {ITheReserveRoutes} from \"../../interfaces/bureaucracy/theReserve/ITheReserveRoutes.sol\";\nimport {ILPNFTStakeFarm} from \"../../interfaces/defi/ILPNFTStakeFarm.sol\";\nimport {ILPSFT} from \"../../interfaces/token/ERC1155/ILPSFT.sol\";\nimport {IGameTokenPooler} from \"../../interfaces/token/routes/IGameTokenPooler.sol\";\nimport {IGameTokenSwapper} from \"../../interfaces/token/routes/IGameTokenSwapper.sol\";\nimport {IMarketStableSwapper} from \"../../interfaces/token/routes/IMarketStableSwapper.sol\";\n\n/**\n * @title Bureau of the Dutch Auction\n */\ncontract DutchAuctionRoutes is IDutchAuctionRoutes {\n  //////////////////////////////////////////////////////////////////////////////\n  // Routes\n  //////////////////////////////////////////////////////////////////////////////\n\n  ITheReserveRoutes.Routes internal _routes;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Initialization\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Initializes the Dutch Auction contract\n   *\n   * @param theReserveRoutes_ The Reserve smart contract routes\n   */\n  constructor(ITheReserveRoutes.Routes memory theReserveRoutes_) {\n    // Initialize routes\n    _routes = theReserveRoutes_;\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IERC165} via {IDutchAuctionRoutes}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IERC165-supportsInterface}\n   */\n  function supportsInterface(\n    bytes4 interfaceId\n  ) public view virtual override returns (bool) {\n    return interfaceId == type(IDutchAuctionRoutes).interfaceId;\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IDutchAuctionRoutes}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IDutchAuctionRoutes-pow1Token}\n   */\n  function pow1Token() external view override returns (IERC20) {\n    return _routes.pow1Token;\n  }\n\n  /**\n   * @dev See {IDutchAuctionRoutes-pow5Token}\n   */\n  function pow5Token() external view override returns (IERC20) {\n    return _routes.pow5Token;\n  }\n\n  /**\n   * @dev See {IDutchAuctionRoutes-marketToken}\n   */\n  function marketToken() external view override returns (IERC20) {\n    return _routes.marketToken;\n  }\n\n  /**\n   * @dev See {IDutchAuctionRoutes-stableToken}\n   */\n  function stableToken() external view override returns (IERC20) {\n    return _routes.stableToken;\n  }\n\n  /**\n   * @dev See {IDutchAuctionRoutes-lpSft}\n   */\n  function lpSft() external view override returns (ILPSFT) {\n    return _routes.lpSft;\n  }\n\n  /**\n   * @dev See {IDutchAuctionRoutes-pow1MarketPool}\n   */\n  function pow1MarketPool() external view override returns (IUniswapV3Pool) {\n    return _routes.pow1MarketPool;\n  }\n\n  /**\n   * @dev See {IDutchAuctionRoutes-pow1MarketSwapper}\n   */\n  function pow1MarketSwapper()\n    external\n    view\n    override\n    returns (IGameTokenSwapper)\n  {\n    return _routes.pow1MarketSwapper;\n  }\n\n  /**\n   * @dev See {IDutchAuctionRoutes-pow5StableSwapper}\n   */\n  function pow5StableSwapper()\n    external\n    view\n    override\n    returns (IGameTokenSwapper)\n  {\n    return _routes.pow5StableSwapper;\n  }\n\n  /**\n   * @dev See {IDutchAuctionRoutes-marketStableSwapper}\n   */\n  function marketStableSwapper()\n    external\n    view\n    override\n    returns (IMarketStableSwapper)\n  {\n    return _routes.marketStableSwapper;\n  }\n\n  /**\n   * @dev See {IDutchAuctionRoutes-pow1MarketPooler}\n   */\n  function pow1MarketPooler()\n    external\n    view\n    override\n    returns (IGameTokenPooler)\n  {\n    return _routes.pow1MarketPooler;\n  }\n\n  /**\n   * @dev See {IDutchAuctionRoutes-pow1LpNftStakeFarm}\n   */\n  function pow1LpNftStakeFarm()\n    external\n    view\n    override\n    returns (ILPNFTStakeFarm)\n  {\n    return _routes.pow1LpNftStakeFarm;\n  }\n\n  /**\n   * @dev See {IDutchAuctionRoutes-uniswapV3NftManager}\n   */\n  function uniswapV3NftManager()\n    external\n    view\n    override\n    returns (INonfungiblePositionManager)\n  {\n    return _routes.uniswapV3NftManager;\n  }\n}\n"
    },
    "contracts/src/bureaucracy/dutchAuction/DutchAuctionState.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {ERC1155Holder} from \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {ERC721Holder} from \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {wadMul, wadExp, toWadUnsafe} from \"solmate/src/utils/SignedWadMath.sol\";\n\nimport {IDutchAuctionState} from \"../../interfaces/bureaucracy/dutchAuction/IDutchAuctionState.sol\";\n\nimport {VRGDA} from \"../../utils/auction/VRGDA.sol\";\n\nimport {DutchAuctionRoutes} from \"./DutchAuctionRoutes.sol\";\n\n/**\n * @title Bureau of the Dutch Auction\n */\nabstract contract DutchAuctionState is\n  IDutchAuctionState,\n  ERC721Holder,\n  ERC1155Holder,\n  DutchAuctionRoutes\n{\n  using EnumerableSet for EnumerableSet.UintSet;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Constants\n  //////////////////////////////////////////////////////////////////////////////\n\n  uint256 internal constant INITIAL_PRICE_BIPS = 2e14; // 0.02%\n  uint256 internal constant MIN_PRICE_BIPS = 1e14; // 0.01%\n  uint256 internal constant MAX_PRICE_BIPS = 1e18; // 100%\n  uint256 internal constant GROWTH_RATE = 1e18; // 100% increase in price per sale\n  uint256 internal constant DECAY_CONSTANT = 192_540_000_000_000; // Scaled by 1e18 for a 50% price drop per hour\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Internal State\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Initialization flag\n   */\n  bool internal _initialized = false;\n\n  /**\n   * @dev Target number of LP-NFTs for sale\n   */\n  uint32 internal _targetLpNftCount;\n\n  // Auction metadata\n  BureauState internal _bureauState;\n\n  // Auction settings\n  AuctionSettings internal _auctionSettings;\n\n  // Set of current LP-NFT token IDs on auction\n  EnumerableSet.UintSet internal _currentAuctions;\n\n  // Mapping from LP-NFT token ID to AuctionState\n  mapping(uint256 => AuctionState) internal _auctionStates;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IERC165} via {ERC1155Holder} and {IDutchAuctionState}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IERC165-supportsInterface}\n   */\n  function supportsInterface(\n    bytes4 interfaceId\n  )\n    public\n    view\n    virtual\n    override(IERC165, ERC1155Holder, DutchAuctionRoutes)\n    returns (bool)\n  {\n    return\n      super.supportsInterface(interfaceId) ||\n      interfaceId == type(IERC721Receiver).interfaceId ||\n      interfaceId == type(IDutchAuctionState).interfaceId;\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IDutchAuctionState}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IDutchAuctionState-getBureauState}\n   */\n  function getBureauState()\n    external\n    view\n    override\n    returns (BureauState memory)\n  {\n    return _bureauState;\n  }\n\n  /**\n   * @dev See {IDutchAuctionState-getAuctionSettings}\n   */\n  function getAuctionSettings()\n    external\n    view\n    override\n    returns (AuctionSettings memory)\n  {\n    return _auctionSettings;\n  }\n\n  /**\n   * @dev See {IDutchAuctionState-getCurrentAuctionCount}\n   */\n  function getCurrentAuctionCount() external view override returns (uint256) {\n    return _bureauState.totalAuctions;\n  }\n\n  /**\n   * @dev Returns the list of current LP-NFT token IDs on auction\n   *\n   * @return An array of LP-NFT token IDs\n   */\n  function getCurrentAuctions() external view returns (uint256[] memory) {\n    uint256 length = _currentAuctions.length();\n    uint256[] memory auctionIds = new uint256[](length);\n\n    for (uint256 i = 0; i < length; i++) {\n      auctionIds[i] = _currentAuctions.at(i);\n    }\n\n    return auctionIds;\n  }\n\n  /**\n   * @dev Returns the auction states of the current auctions\n   *\n   * @return An array of AuctionState structs\n   */\n  function getCurrentAuctionStates()\n    external\n    view\n    override\n    returns (AuctionState[] memory)\n  {\n    uint256 length = _currentAuctions.length();\n    AuctionState[] memory auctionStates = new AuctionState[](length);\n\n    for (uint256 i = 0; i < length; i++) {\n      uint256 lpNftTokenId = _currentAuctions.at(i);\n      auctionStates[i] = _auctionStates[lpNftTokenId];\n    }\n\n    return auctionStates;\n  }\n\n  /**\n   * @dev See {IDutchAuctionState-getAuctionState}\n   */\n  function getAuctionState(\n    uint256 lpNftTokenId\n  ) external view override returns (AuctionState memory) {\n    return _auctionStates[lpNftTokenId];\n  }\n\n  /**\n   * @dev See {IDutchAuctionState-getCurrentPrice}\n   */\n  function getCurrentPriceBips(\n    uint256 lpNftTokenId\n  ) public view override returns (uint256 currentPriceBips) {\n    // Read state\n    AuctionState memory auction = _auctionStates[lpNftTokenId];\n\n    // Validate state\n    // slither-disable-next-line incorrect-equality\n    require(auction.lpNftTokenId == lpNftTokenId, \"LP-NFT not for sale\");\n    // slither-disable-next-line incorrect-equality\n    require(auction.salePrice == 0, \"Auction already sold\");\n    require(auction.startTime > 0, \"Auction not started\");\n\n    // Calculate the time elapsed since the auction start\n    uint256 elapsedTime = block.timestamp - auction.startTime;\n\n    // Convert elapsedTime to WAD (scaled by 1e18)\n    int256 elapsedTimeWad = toWadUnsafe(elapsedTime);\n\n    // Convert decay constant to int256 (already scaled by 1e18)\n    int256 decayConstantWad = int256(_auctionSettings.priceDecayRate);\n\n    // Calculate the decay exponent: -decayConstant * elapsedTime\n    int256 decayExponent = -wadMul(decayConstantWad, elapsedTimeWad);\n\n    // Calculate the decay factor: e^( -decayConstant * elapsedTime )\n    int256 decayFactor = wadExp(decayExponent);\n\n    // Calculate current price: startPriceBips * decayFactor\n    int256 startPriceBips = int256(auction.startPriceBips);\n    int256 currentPriceBipsInt = wadMul(startPriceBips, decayFactor);\n\n    // Ensure current price is not less than the end price\n    uint256 endPriceBips = auction.endPriceBips;\n    if (currentPriceBipsInt < int256(endPriceBips)) {\n      currentPriceBips = endPriceBips;\n    } else {\n      currentPriceBips = uint256(currentPriceBipsInt);\n    }\n\n    return currentPriceBips;\n  }\n\n  /**\n   * @dev See {IDutchAuctionState-getTokenUri}\n   */\n  function getTokenUri(\n    uint256 lpNftTokenId\n  ) external view override returns (string memory) {\n    return _routes.uniswapV3NftManager.tokenURI(lpNftTokenId);\n  }\n}\n"
    },
    "contracts/src/bureaucracy/LiquidityForge.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport {ILiquidityForge} from \"../interfaces/bureaucracy/ILiquidityForge.sol\";\nimport {IYieldHarvest} from \"../interfaces/bureaucracy/yieldHarvest/IYieldHarvest.sol\";\nimport {ITheReserve} from \"../interfaces/bureaucracy/theReserve/ITheReserve.sol\";\nimport {IDeFiManager} from \"../interfaces/defi/IDeFiManager.sol\";\nimport {IERC20InterestFarm} from \"../interfaces/defi/IERC20InterestFarm.sol\";\nimport {ILPSFT} from \"../interfaces/token/ERC1155/ILPSFT.sol\";\nimport {IERC1155Enumerable} from \"../interfaces/token/ERC1155/extensions/IERC1155Enumerable.sol\";\n\n/**\n * @title Bureau of the Liquidity Forge\n */\ncontract LiquidityForge is Context, ReentrancyGuard, ILiquidityForge {\n  using SafeERC20 for IERC20;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Routes\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev The Reserve smart contract\n   */\n  ITheReserve public immutable theReserve;\n\n  /**\n   * @dev The LP-SFT token contract\n   */\n  ILPSFT public immutable lpSft;\n\n  /**\n   * @dev The LP-SFT debt contract\n   */\n  IERC1155Enumerable public immutable noLpSft;\n\n  /**\n   * @dev The LP-SFT manager contract\n   */\n  IDeFiManager public defiManager;\n\n  /**\n   * @dev The POW5 token contract\n   */\n  IERC20 public immutable pow5Token;\n\n  /**\n   * @dev The Liquidity Forge contract\n   */\n  IYieldHarvest public immutable yieldHarvest;\n\n  /**\n   * @dev The ERC20 interest farm\n   */\n  IERC20InterestFarm public immutable erc20InterestFarm;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Initialization\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Initializes the Liquidity Forge contract\n   *\n   * @param theReserve_ The Reserve smart contract address\n   * @param defiManager_ The LP-SFT manager contract\n   * @param yieldHarvest_ The Yield Harvest contract\n   * @param erc20InterestFarm_ The ERC20 interest farm\n   */\n  constructor(\n    address theReserve_,\n    address defiManager_,\n    address yieldHarvest_,\n    address erc20InterestFarm_\n  ) {\n    // Validate parameters\n    require(defiManager_ != address(0), \"Invalid LP-SFT mgr\");\n    require(yieldHarvest_ != address(0), \"Invalid yield harvest\");\n    require(erc20InterestFarm_ != address(0), \"Invalid interest farm\");\n\n    // Initialize routes\n    theReserve = ITheReserve(theReserve_);\n    lpSft = ILPSFT(ITheReserve(theReserve_).lpSft());\n    noLpSft = IERC1155Enumerable(ITheReserve(theReserve_).noLpSft());\n    defiManager = IDeFiManager(defiManager_);\n    pow5Token = IERC20(ITheReserve(theReserve_).pow5Token());\n    yieldHarvest = IYieldHarvest(yieldHarvest_);\n    erc20InterestFarm = IERC20InterestFarm(erc20InterestFarm_);\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IERC165} via {ILiquidityForge}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IERC165-supportsInterface}\n   */\n  function supportsInterface(\n    bytes4 interfaceId\n  ) public pure override returns (bool) {\n    return interfaceId == type(ILiquidityForge).interfaceId;\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {ILiquidityForge}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {ILiquidityForge-borrowPow5}\n   */\n  function borrowPow5(\n    uint256 tokenId,\n    uint256 amount,\n    address receiver\n  ) external override nonReentrant {\n    // Validate ownership\n    require(noLpSft.ownerOf(tokenId) == _msgSender(), \"Not NOLPSFT owner\");\n\n    // Get LP-SFT address\n    address lpSftAddress = lpSft.tokenIdToAddress(tokenId);\n\n    // Validate address\n    require(lpSftAddress != address(0), \"Invalid LP-SFT\");\n\n    // Call external contracts\n    erc20InterestFarm.recordLoan(lpSftAddress, amount);\n    defiManager.issuePow5(tokenId, amount, receiver);\n  }\n\n  /**\n   * @dev See {ILiquidityForge-repayPow5}\n   */\n  function repayPow5(\n    uint256 tokenId,\n    uint256 amount\n  ) external override nonReentrant {\n    // Validate ownership\n    require(noLpSft.ownerOf(tokenId) == _msgSender(), \"Not NOLPSFT owner\");\n\n    // Get LP-SFT address\n    address lpSftAddress = lpSft.tokenIdToAddress(tokenId);\n\n    // Validate address\n    require(lpSftAddress != address(0), \"Invalid LP-SFT\");\n\n    // Call external contracts\n    pow5Token.safeTransferFrom(_msgSender(), address(this), amount);\n    erc20InterestFarm.recordRepayment(lpSftAddress, amount);\n    defiManager.repayPow5(tokenId, amount);\n  }\n}\n"
    },
    "contracts/src/bureaucracy/ReverseRepo.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {ERC1155Holder} from \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {ERC721Holder} from \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport {IUniswapV3Pool} from \"../../interfaces/uniswap-v3-core/IUniswapV3Pool.sol\";\nimport {INonfungiblePositionManager} from \"../../interfaces/uniswap-v3-periphery/INonfungiblePositionManager.sol\";\n\nimport {IReverseRepo} from \"../interfaces/bureaucracy/IReverseRepo.sol\";\nimport {ITheReserve} from \"../interfaces/bureaucracy/theReserve/ITheReserve.sol\";\nimport {IUniV3StakeFarm} from \"../interfaces/defi/IUniV3StakeFarm.sol\";\nimport {ILPSFT} from \"../interfaces/token/ERC1155/ILPSFT.sol\";\nimport {IGameTokenPooler} from \"../interfaces/token/routes/IGameTokenPooler.sol\";\nimport {IGameTokenSwapper} from \"../interfaces/token/routes/IGameTokenSwapper.sol\";\nimport {LiquidityMath} from \"../utils/math/LiquidityMath.sol\";\n\n/**\n * @title Bureau of the Reverse Repo\n */\ncontract ReverseRepo is\n  ReentrancyGuard,\n  AccessControl,\n  ERC721Holder,\n  ERC1155Holder,\n  IReverseRepo\n{\n  using SafeERC20 for IERC20;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Routes\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev The Reserve smart contract\n   */\n  ITheReserve public immutable theReserve;\n\n  /**\n   * @dev The POW5 token\n   */\n  IERC20 public immutable pow5Token;\n\n  /**\n   * @dev The stable token\n   */\n  IERC20 public immutable stableToken;\n\n  /**\n   * @dev The upstream Uniswap V3 pool for the POW5/stable token pair\n   */\n  IUniswapV3Pool public immutable pow5StablePool;\n\n  /**\n   * @dev The token swapper\n   */\n  IGameTokenSwapper public immutable pow5StableSwapper;\n\n  /**\n   * @dev The token pooler\n   */\n  IGameTokenPooler public immutable pow5StablePooler;\n\n  /**\n   * @dev The POW5 LP-NFT stake farm\n   */\n  IUniV3StakeFarm public immutable pow5LpNftStakeFarm;\n\n  /**\n   * @dev The LP-SFT contract\n   */\n  ILPSFT public immutable lpSft;\n\n  /**\n   * @dev The upstream Uniswap V3 NFT manager\n   */\n  INonfungiblePositionManager public immutable uniswapV3NftManager;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Initialization\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Initializes the Yield Harvest contract\n   *\n   * @param owner_ The owner of the Dutch Auction\n   * @param theReserve_ The Reserve smart contract address\n   */\n  constructor(address owner_, address theReserve_) {\n    // Validate parameters\n    require(owner_ != address(0), \"Invalid owner\");\n    require(theReserve_ != address(0), \"Invalid The Reserve\");\n\n    // Initialize {AccessControl}\n    _grantRole(DEFAULT_ADMIN_ROLE, owner_);\n\n    // Initialize routes\n    theReserve = ITheReserve(theReserve_);\n    pow5Token = IERC20(ITheReserve(theReserve_).pow5Token());\n    stableToken = IERC20(ITheReserve(theReserve_).stableToken());\n    pow5StablePool = IUniswapV3Pool(ITheReserve(theReserve_).pow5StablePool());\n    pow5StableSwapper = IGameTokenSwapper(\n      ITheReserve(theReserve_).pow5StableSwapper()\n    );\n    pow5StablePooler = IGameTokenPooler(\n      ITheReserve(theReserve_).pow5StablePooler()\n    );\n    pow5LpNftStakeFarm = IUniV3StakeFarm(\n      ITheReserve(theReserve_).pow5LpNftStakeFarm()\n    );\n    lpSft = ILPSFT(ITheReserve(theReserve_).lpSft());\n    uniswapV3NftManager = INonfungiblePositionManager(\n      ITheReserve(theReserve_).uniswapV3NftManager()\n    );\n\n    // Approve the stake farm to transfer our LP-NFTs\n    uniswapV3NftManager.setApprovalForAll(\n      address(ITheReserve(theReserve_).pow5LpNftStakeFarm()),\n      true\n    );\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IERC165} via {AccessControl} and {IReverseRepo}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IERC165-supportsInterface}\n   */\n  function supportsInterface(\n    bytes4 interfaceId\n  )\n    public\n    view\n    virtual\n    override(AccessControl, ERC1155Holder, IERC165)\n    returns (bool)\n  {\n    return\n      super.supportsInterface(interfaceId) ||\n      interfaceId == type(IERC721Receiver).interfaceId ||\n      interfaceId == type(IReverseRepo).interfaceId;\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IReverseRepo}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IReverseRepo-initialize}\n   */\n  function initialize(\n    uint256 pow5Amount,\n    uint256 stableTokenAmount,\n    address receiver\n  ) external override nonReentrant returns (uint256 tokenId) {\n    // Validate access\n    _checkRole(DEFAULT_ADMIN_ROLE);\n\n    // Validate parameters\n    require(pow5Amount > 0, \"Invalid POW5 amount\");\n    require(stableTokenAmount > 0, \"Invalid stable amount\");\n    require(receiver != address(0), \"Invalid receiver\");\n\n    // Call external contracts\n    pow5Token.safeTransferFrom(_msgSender(), address(this), pow5Amount);\n    stableToken.safeTransferFrom(\n      _msgSender(),\n      address(this),\n      stableTokenAmount\n    );\n\n    pow5Token.safeIncreaseAllowance(address(pow5StablePooler), pow5Amount);\n    stableToken.safeIncreaseAllowance(\n      address(pow5StablePooler),\n      stableTokenAmount\n    );\n\n    // Approve the stake farm to transfer our LP-NFTs\n    lpSft.setApprovalForAll(address(pow5LpNftStakeFarm), true);\n\n    // Mint an LP-NFT\n    tokenId = pow5StablePooler.mintLpNftImbalance(\n      pow5Amount,\n      stableTokenAmount,\n      address(this)\n    );\n\n    // Stake LP-NFT in the stake farm\n    pow5LpNftStakeFarm.enter(tokenId);\n\n    // Get newly-minted LP-SFT address\n    address lpSftAddress = lpSft.tokenIdToAddress(tokenId);\n    require(lpSftAddress != address(0), \"Invalid LP-SFT\");\n\n    // Send POW5 dust to the receiver\n    uint256 pow5Dust = pow5Token.balanceOf(address(this));\n    if (pow5Dust > 0) {\n      pow5Token.safeTransfer(receiver, pow5Dust);\n    }\n\n    // Send stable token dust to the receiver\n    uint256 stableDust = stableToken.balanceOf(address(this));\n    if (stableDust > 0) {\n      stableToken.safeTransfer(receiver, stableDust);\n    }\n\n    // Return the LP-SFT to the receiver\n    lpSft.safeTransferFrom(address(this), receiver, tokenId, 1, \"\");\n\n    return tokenId;\n  }\n\n  /**\n   * @dev See {IReverseRepo-purchase}\n   */\n  function purchase(\n    uint256 pow5Amount,\n    uint256 stableTokenAmount,\n    address receiver\n  ) external override nonReentrant returns (uint256 tokenId) {\n    // Validate parameters\n    require(pow5Amount > 0 || stableTokenAmount > 0, \"Invalid amounts\");\n    require(receiver != address(0), \"Invalid receiver\");\n\n    // Get the pool fee\n    uint24 poolFee = pow5StablePool.fee();\n\n    // Call external contracts\n    if (pow5Amount > 0) {\n      pow5Token.safeTransferFrom(_msgSender(), address(this), pow5Amount);\n    }\n    if (stableTokenAmount > 0) {\n      stableToken.safeTransferFrom(\n        _msgSender(),\n        address(this),\n        stableTokenAmount\n      );\n    }\n\n    // Perform single-sided supply swap\n    if (pow5Amount == 0) {\n      // Get stable token reserve\n      uint256 stableReserve = stableToken.balanceOf(address(pow5StablePool));\n\n      // Calculate stable swap amount\n      uint256 stableSwapAmount = LiquidityMath.computeSwapAmountV2(\n        stableReserve,\n        stableTokenAmount,\n        poolFee\n      );\n      require(stableSwapAmount <= stableTokenAmount, \"Bad liquidity math\");\n\n      // Approve swap\n      stableToken.safeIncreaseAllowance(\n        address(pow5StableSwapper),\n        stableSwapAmount\n      );\n\n      // Perform swap\n      pow5Amount = pow5StableSwapper.buyGameToken(\n        stableSwapAmount,\n        address(this)\n      );\n\n      // Update amount\n      stableTokenAmount -= stableSwapAmount;\n    } else if (stableTokenAmount == 0) {\n      // Get POW5 reserve\n      uint256 pow5Reserve = pow5Token.balanceOf(address(pow5StablePool));\n\n      // Calculate POW5 swap amount\n      uint256 pow5SwapAmount = LiquidityMath.computeSwapAmountV2(\n        pow5Reserve,\n        pow5Amount,\n        poolFee\n      );\n      require(pow5SwapAmount <= pow5Amount, \"Bad liquidity math\");\n\n      // Approve swap\n      pow5Token.safeIncreaseAllowance(\n        address(pow5StableSwapper),\n        pow5SwapAmount\n      );\n\n      // Perform swap\n      stableTokenAmount = pow5StableSwapper.sellGameToken(\n        pow5SwapAmount,\n        address(this)\n      );\n\n      // Update amount\n      pow5Amount -= pow5SwapAmount;\n    }\n\n    // Validate state\n    require(pow5Amount > 0 || stableTokenAmount > 0, \"Invalid liquidity\");\n\n    // Approve tokens\n    if (pow5Amount > 0) {\n      pow5Token.safeIncreaseAllowance(address(pow5StablePooler), pow5Amount);\n    }\n    if (stableTokenAmount > 0) {\n      stableToken.safeIncreaseAllowance(\n        address(pow5StablePooler),\n        stableTokenAmount\n      );\n    }\n\n    // Mint an LP-NFT\n    tokenId = pow5StablePooler.mintLpNftImbalance(\n      pow5Amount,\n      stableTokenAmount,\n      address(this)\n    );\n\n    // Stake LP-NFT in the stake farm\n    pow5LpNftStakeFarm.enter(tokenId);\n\n    // Get newly-minted LP-SFT address\n    address lpSftAddress = lpSft.tokenIdToAddress(tokenId);\n    require(lpSftAddress != address(0), \"Invalid LP-SFT\");\n\n    // Send POW5 dust to the receiver\n    uint256 pow5Dust = pow5Token.balanceOf(address(this));\n    if (pow5Dust > 0) {\n      pow5Token.safeTransfer(receiver, pow5Dust);\n    }\n\n    // Send stable token dust to the receiver\n    uint256 stableDust = stableToken.balanceOf(address(this));\n    if (stableDust > 0) {\n      stableToken.safeTransfer(receiver, stableDust);\n    }\n\n    // Return the LP-SFT to the receiver\n    lpSft.safeTransferFrom(address(this), receiver, tokenId, 1, \"\");\n\n    return tokenId;\n  }\n\n  /**\n   * @dev See {IReverseRepo-exit}\n   */\n  function exit(uint256 tokenId) external override nonReentrant {\n    // Call external contracts\n    lpSft.safeTransferFrom(_msgSender(), address(this), tokenId, 1, \"\");\n\n    // Withdraw the LP-NFT from the stake farm\n    pow5LpNftStakeFarm.exit(tokenId);\n\n    // Read state\n    uint256 pow5Balance = pow5Token.balanceOf(address(this));\n\n    // Swap any POW5 to the stable token\n    if (pow5Balance > 0) {\n      pow5Token.safeIncreaseAllowance(address(pow5StableSwapper), pow5Balance);\n      // slither-disable-next-line unused-return\n      pow5StableSwapper.sellGameToken(pow5Balance, address(this));\n    }\n\n    // Read state\n    uint256 stableTokenBalance = stableToken.balanceOf(address(this));\n\n    // Return any tokens to the sender\n    if (stableTokenBalance > 0) {\n      stableToken.safeTransfer(_msgSender(), stableTokenBalance);\n    }\n\n    // Return the empty LP-NFT to the sender\n    uniswapV3NftManager.safeTransferFrom(\n      address(this),\n      _msgSender(),\n      tokenId,\n      \"\"\n    );\n  }\n}\n"
    },
    "contracts/src/bureaucracy/theReserve/TheReserve.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {ITheReserve} from \"../../interfaces/bureaucracy/theReserve/ITheReserve.sol\";\n\nimport {TheReserveRoutes} from \"./TheReserveRoutes.sol\";\n\n/**\n * @title The Reserve Smart Contract\n */\ncontract TheReserve is ITheReserve, TheReserveRoutes {\n  /**\n   * @dev Initializes The Reserve\n   *\n   * @param routes_ The routes of The Reserve\n   */\n  constructor(ITheReserve.Routes memory routes_) TheReserveRoutes(routes_) {}\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IERC165} via {TheReserveRoutes} and {ITheReserve}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IERC165-supportsInterface}\n   */\n  function supportsInterface(\n    bytes4 interfaceId\n  ) public view virtual override(IERC165, TheReserveRoutes) returns (bool) {\n    return\n      super.supportsInterface(interfaceId) ||\n      interfaceId == type(ITheReserve).interfaceId;\n  }\n}\n"
    },
    "contracts/src/bureaucracy/theReserve/TheReserveRoutes.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {IUniswapV3Factory} from \"../../../interfaces/uniswap-v3-core/IUniswapV3Factory.sol\";\nimport {IUniswapV3Pool} from \"../../../interfaces/uniswap-v3-core/IUniswapV3Pool.sol\";\nimport {INonfungiblePositionManager} from \"../../../interfaces/uniswap-v3-periphery/INonfungiblePositionManager.sol\";\n\nimport {ITheReserveRoutes} from \"../../interfaces/bureaucracy/theReserve/ITheReserveRoutes.sol\";\nimport {ILPNFTStakeFarm} from \"../../interfaces/defi/ILPNFTStakeFarm.sol\";\nimport {ILPSFTLendFarm} from \"../../interfaces/defi/ILPSFTLendFarm.sol\";\nimport {IUniV3StakeFarm} from \"../../interfaces/defi/IUniV3StakeFarm.sol\";\nimport {ILPSFT} from \"../../interfaces/token/ERC1155/ILPSFT.sol\";\nimport {INOLPSFT} from \"../../interfaces/token/ERC1155/INOLPSFT.sol\";\nimport {IGameTokenPooler} from \"../../interfaces/token/routes/IGameTokenPooler.sol\";\nimport {IGameTokenSwapper} from \"../../interfaces/token/routes/IGameTokenSwapper.sol\";\nimport {IMarketStableSwapper} from \"../../interfaces/token/routes/IMarketStableSwapper.sol\";\n\n/**\n * @title The Reserve Smart Contract, Routing Interface\n */\ncontract TheReserveRoutes is ITheReserveRoutes {\n  //////////////////////////////////////////////////////////////////////////////\n  // Routes\n  //////////////////////////////////////////////////////////////////////////////\n\n  ITheReserveRoutes.Routes internal _routes;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Initialization\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Initializes The Reserve, Routes component\n   *\n   * @param routes_ The routes of The Reserve\n   */\n  constructor(ITheReserveRoutes.Routes memory routes_) {\n    // Initialize routes\n    _routes = routes_;\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IERC165} via {ITheReserveRoutes}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IERC165-supportsInterface}\n   */\n  function supportsInterface(\n    bytes4 interfaceId\n  ) public view virtual returns (bool) {\n    return interfaceId == type(ITheReserveRoutes).interfaceId;\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {ITheReserveRoutes}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {ITheReserveRoutes-getRoutes}\n   */\n  function getRoutes() external view override returns (Routes memory) {\n    return _routes;\n  }\n\n  /**\n   * @dev See {ITheReserveRoutes-pow1Token}\n   */\n  function pow1Token() external view override returns (IERC20) {\n    return _routes.pow1Token;\n  }\n\n  /**\n   * @dev See {ITheReserveRoutes-pow5Token}\n   */\n  function pow5Token() external view override returns (IERC20) {\n    return _routes.pow5Token;\n  }\n\n  /**\n   * @dev See {ITheReserveRoutes-lpPow1Token}\n   */\n  function lpPow1Token() external view override returns (IERC20) {\n    return _routes.lpPow1Token;\n  }\n\n  /**\n   * @dev See {ITheReserveRoutes-lpPow5Token}\n   */\n  function lpPow5Token() external view override returns (IERC20) {\n    return _routes.lpPow5Token;\n  }\n\n  /**\n   * @dev See {ITheReserveRoutes-noPow5Token}\n   */\n  function noPow5Token() external view override returns (IERC20) {\n    return _routes.noPow5Token;\n  }\n\n  /**\n   * @dev See {ITheReserveRoutes-marketToken}\n   */\n  function marketToken() external view override returns (IERC20) {\n    return _routes.marketToken;\n  }\n\n  /**\n   * @dev See {ITheReserveRoutes-stableToken}\n   */\n  function stableToken() external view override returns (IERC20) {\n    return _routes.stableToken;\n  }\n\n  /**\n   * @dev See {ITheReserveRoutes-lpSft}\n   */\n  function lpSft() external view override returns (ILPSFT) {\n    return _routes.lpSft;\n  }\n\n  /**\n   * @dev See {ITheReserveRoutes-noLpSft}\n   */\n  function noLpSft() external view override returns (INOLPSFT) {\n    return _routes.noLpSft;\n  }\n\n  /**\n   * @dev See {ITheReserveRoutes-pow1MarketPool}\n   */\n  function pow1MarketPool() external view override returns (IUniswapV3Pool) {\n    return _routes.pow1MarketPool;\n  }\n\n  /**\n   * @dev See {ITheReserveRoutes-pow5StablePool}\n   */\n  function pow5StablePool() external view override returns (IUniswapV3Pool) {\n    return _routes.pow5StablePool;\n  }\n\n  /**\n   * @dev See {ITheReserveRoutes-marketStablePool}\n   */\n  function marketStablePool() external view override returns (IUniswapV3Pool) {\n    return _routes.marketStablePool;\n  }\n\n  /**\n   * @dev See {ITheReserveRoutes-pow1MarketSwapper}\n   */\n  function pow1MarketSwapper()\n    external\n    view\n    override\n    returns (IGameTokenSwapper)\n  {\n    return _routes.pow1MarketSwapper;\n  }\n\n  /**\n   * @dev See {ITheReserveRoutes-pow5StableSwapper}\n   */\n  function pow5StableSwapper()\n    external\n    view\n    override\n    returns (IGameTokenSwapper)\n  {\n    return _routes.pow5StableSwapper;\n  }\n\n  /**\n   * @dev See {ITheReserveRoutes-marketStableSwapper}\n   */\n  function marketStableSwapper()\n    external\n    view\n    override\n    returns (IMarketStableSwapper)\n  {\n    return _routes.marketStableSwapper;\n  }\n\n  /**\n   * @dev See {ITheReserveRoutes-pow1MarketPooler}\n   */\n  function pow1MarketPooler()\n    external\n    view\n    override\n    returns (IGameTokenPooler)\n  {\n    return _routes.pow1MarketPooler;\n  }\n\n  /**\n   * @dev See {ITheReserveRoutes-pow5StablePooler}\n   */\n  function pow5StablePooler()\n    external\n    view\n    override\n    returns (IGameTokenPooler)\n  {\n    return _routes.pow5StablePooler;\n  }\n\n  /**\n   * @dev See {ITheReserveRoutes-pow1LpNftStakeFarm}\n   */\n  function pow1LpNftStakeFarm()\n    external\n    view\n    override\n    returns (ILPNFTStakeFarm)\n  {\n    return _routes.pow1LpNftStakeFarm;\n  }\n\n  /**\n   * @dev See {ITheReserveRoutes-pow5LpNftStakeFarm}\n   */\n  function pow5LpNftStakeFarm()\n    external\n    view\n    override\n    returns (IUniV3StakeFarm)\n  {\n    return _routes.pow5LpNftStakeFarm;\n  }\n\n  /**\n   * @dev See {ITheReserveRoutes-pow1LpSftLendFarm}\n   */\n  function pow1LpSftLendFarm() external view override returns (ILPSFTLendFarm) {\n    return _routes.pow1LpSftLendFarm;\n  }\n\n  /**\n   * @dev See {ITheReserveRoutes-pow5LpSftLendFarm}\n   */\n  function pow5LpSftLendFarm() external view override returns (ILPSFTLendFarm) {\n    return _routes.pow5LpSftLendFarm;\n  }\n\n  /**\n   * @dev See {ITheReserveRoutes-uniswapV3Factory}\n   */\n  function uniswapV3Factory()\n    external\n    view\n    override\n    returns (IUniswapV3Factory)\n  {\n    return _routes.uniswapV3Factory;\n  }\n\n  /**\n   * @dev See {ITheReserveRoutes-uniswapV3NftManager}\n   */\n  function uniswapV3NftManager()\n    external\n    view\n    override\n    returns (INonfungiblePositionManager)\n  {\n    return _routes.uniswapV3NftManager;\n  }\n}\n"
    },
    "contracts/src/bureaucracy/yieldHarvest/YieldHarvest.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport {IERC1155Receiver} from \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport {ITheReserve} from \"../../interfaces/bureaucracy/theReserve/ITheReserve.sol\";\nimport {IYieldHarvest} from \"../../interfaces/bureaucracy/yieldHarvest/IYieldHarvest.sol\";\nimport {IDeFiManager} from \"../../interfaces/defi/IDeFiManager.sol\";\nimport {ILPSFTLendFarm} from \"../../interfaces/defi/ILPSFTLendFarm.sol\";\nimport {ILPSFTIssuable} from \"../../interfaces/token/ERC1155/extensions/ILPSFTIssuable.sol\";\nimport {ILPSFT} from \"../../interfaces/token/ERC1155/ILPSFT.sol\";\nimport {ERC1155Helpers} from \"../../token/ERC1155/utils/ERC1155Helpers.sol\";\n\n/**\n * @title Bureau of the Yield Harvest\n */\ncontract YieldHarvest is Context, ReentrancyGuard, IYieldHarvest {\n  //////////////////////////////////////////////////////////////////////////////\n  // Routes\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev The Reserve smart contract\n   */\n  ITheReserve public immutable theReserve;\n\n  /**\n   * @dev The LP-SFT contract\n   */\n  ILPSFT public immutable lpSft;\n\n  /**\n   * @dev The LP-SFT debt contract\n   */\n  ILPSFTIssuable public immutable noLpSft;\n\n  /**\n   * @dev The POW1 LP-SFT lend farm\n   */\n  ILPSFTLendFarm public immutable pow1LpSftLendFarm;\n\n  /**\n   * @dev The DeFi interface for LP-SFTs\n   */\n  IDeFiManager public immutable defiManager;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Initialization\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Initializes the Yield Harvest contract\n   *\n   * @param theReserve_ The address of The Reserve smart contract\n   * @param defiManager_ The address of the LP-SFT DeFi manager\n   */\n  constructor(address theReserve_, address defiManager_) {\n    // Validate parameters\n    require(theReserve_ != address(0), \"Invalid The Reserve\");\n    require(defiManager_ != address(0), \"Invalid DeFi mgr\");\n\n    // Initialize routes\n    theReserve = ITheReserve(theReserve_);\n    lpSft = ITheReserve(theReserve_).lpSft();\n    noLpSft = ITheReserve(theReserve_).noLpSft();\n    pow1LpSftLendFarm = ITheReserve(theReserve_).pow1LpSftLendFarm();\n    defiManager = IDeFiManager(defiManager_);\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IERC165} via {IYieldHarvest}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IERC165-supportsInterface}\n   */\n  function supportsInterface(\n    bytes4 interfaceId\n  ) external pure override returns (bool) {\n    return interfaceId == type(IYieldHarvest).interfaceId;\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IERC1155Receiver} via {IYieldHarvest}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IERC1155Receiver-onERC1155Received}\n   */\n  function onERC1155Received(\n    address,\n    address from,\n    uint256 id,\n    uint256 value,\n    bytes memory data\n  ) external override returns (bytes4) {\n    // Validate sender\n    require(\n      _msgSender() == address(lpSft) || _msgSender() == address(noLpSft),\n      \"Only (NO)LPSFT accepted\"\n    );\n\n    // Validate parameters\n    require(value == 1, \"Only NFTs\");\n    require(from != address(0), \"Invalid sender\");\n\n    if (_msgSender() == address(lpSft)) {\n      // Call external contracts\n      pow1LpSftLendFarm.lendLpSft(id);\n      noLpSft.mint(from, id, data);\n    } else {\n      // Verify no POW5 debt\n      require(defiManager.noPow5Balance(id) == 0, \"NOPOW5 must be 0\");\n\n      // Call external contracts\n      noLpSft.burn(address(this), id);\n      pow1LpSftLendFarm.withdrawLpSft(id);\n      lpSft.safeTransferFrom(address(this), from, id, 1, data);\n    }\n\n    // Satisfy IERC1155Receiver requirement\n    return this.onERC1155Received.selector;\n  }\n\n  /**\n   * @dev See {IERC1155Receiver-onERC1155BatchReceived}\n   */\n  function onERC1155BatchReceived(\n    address,\n    address from,\n    uint256[] memory ids,\n    uint256[] memory values,\n    bytes memory data\n  ) external override returns (bytes4) {\n    // Validate sender\n    require(\n      _msgSender() == address(lpSft) || _msgSender() == address(noLpSft),\n      \"Only (NO)LPSFT accepted\"\n    );\n\n    // Validate parameters\n    require(from != address(0), \"Invalid sender\");\n    ERC1155Helpers.checkAmountArray(ids, values);\n\n    if (_msgSender() == address(lpSft)) {\n      // Call external contracts\n      pow1LpSftLendFarm.lendLpSftBatch(ids);\n      noLpSft.mintBatch(from, ids, data);\n    } else {\n      pow1LpSftLendFarm.withdrawLpSftBatch(ids);\n      noLpSft.burnBatch(address(this), ids);\n      lpSft.safeBatchTransferFrom(address(this), from, ids, values, data);\n    }\n\n    // Satisfy IERC1155Receiver requirement\n    return this.onERC1155BatchReceived.selector;\n  }\n}\n"
    },
    "contracts/src/defi/DeFiManager.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * This file is derived from the Ultrachess project under the Apache 2.0 license.\n * Copyright (C) 2022-2023 Ultrachess team\n *\n * SPDX-License-Identifier: GPL-3.0-or-later AND Apache-2.0\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Arrays} from \"@openzeppelin/contracts/utils/Arrays.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport {IDeFiManager} from \"../interfaces/defi/IDeFiManager.sol\";\nimport {ILPSFT} from \"../interfaces/token/ERC1155/ILPSFT.sol\";\nimport {IERC20Issuable} from \"../interfaces/token/ERC20/extensions/IERC20Issuable.sol\";\n\n/**\n * @title LP-SFT Manager\n *\n * @dev This class is responsible for managing LP-SFT DeFi operations\n */\ncontract DeFiManager is ReentrancyGuard, AccessControl, IDeFiManager {\n  using Arrays for uint256[];\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Roles\n  //////////////////////////////////////////////////////////////////////////////\n\n  // Only DEFI_OPERATOR_ROLE can perform DeFi operations\n  bytes32 public constant DEFI_OPERATOR_ROLE = \"DEFI_OPERATOR_ROLE\";\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Routes\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev The POW1 token\n   */\n  IERC20 public immutable pow1Token;\n\n  /**\n   * @dev The POW5 token\n   */\n  IERC20Issuable public immutable pow5Token;\n\n  /**\n   * @dev The LP POW1 token\n   */\n  IERC20Issuable public immutable lpPow1Token;\n\n  /**\n   * @dev The LP POW5 token\n   */\n  IERC20Issuable public immutable lpPow5Token;\n\n  /**\n   * @dev The POW5 debt token\n   */\n  IERC20Issuable public immutable noPow5Token;\n\n  /**\n   * @dev The LP-SFT contract\n   */\n  ILPSFT public immutable lpSft;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // State\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev The borrowers of LP-SFTs\n   */\n  mapping(uint256 tokenId => address borrower) private _tokenIdToBorrower;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Initialization\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Initializes the ERC-1155 contract\n   *\n   * @param owner_ The owner of the contract\n   * @param pow1Token_ The POW1 token\n   * @param pow5Token_ The POW5 token\n   * @param lpPow1Token_ The LPPOW1 token\n   * @param lpPow5Token_ The LPPOW5 token\n   * @param noPow5Token_ The POW5 debt token\n   * @param lpSft_ The LP-SFT contract\n   */\n  constructor(\n    address owner_,\n    address pow1Token_,\n    address pow5Token_,\n    address lpPow1Token_,\n    address lpPow5Token_,\n    address noPow5Token_,\n    address lpSft_\n  ) {\n    // Validate parameters\n    require(owner_ != address(0), \"Invalid owner\");\n    require(pow1Token_ != address(0), \"Invalid POW1\");\n    require(pow5Token_ != address(0), \"Invalid POW5\");\n    require(lpPow1Token_ != address(0), \"Invalid LPPOW1\");\n    require(lpPow5Token_ != address(0), \"Invalid LPPOW5\");\n    require(noPow5Token_ != address(0), \"Invalid POW5 debt\");\n    require(lpSft_ != address(0), \"Invalid LP-SFT\");\n\n    // Initialize {AccessControl}\n    _grantRole(DEFAULT_ADMIN_ROLE, owner_);\n\n    // Initialize routes\n    pow1Token = IERC20(pow1Token_);\n    pow5Token = IERC20Issuable(pow5Token_);\n    lpPow1Token = IERC20Issuable(lpPow1Token_);\n    lpPow5Token = IERC20Issuable(lpPow5Token_);\n    noPow5Token = IERC20Issuable(noPow5Token_);\n    lpSft = ILPSFT(lpSft_);\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IERC165} via {AccessControl} and {IDeFiManager}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IERC165-supportsInterface}\n   */\n  function supportsInterface(\n    bytes4 interfaceId\n  ) public view virtual override(AccessControl, IERC165) returns (bool) {\n    return\n      super.supportsInterface(interfaceId) ||\n      type(IDeFiManager).interfaceId == interfaceId;\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IDeFiManager}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IDeFiManager-pow1Balance}\n   */\n  function pow1Balance(\n    uint256 tokenId\n  ) external view override returns (uint256) {\n    // Read state\n    address lpNftAddress = lpSft.tokenIdToAddress(tokenId);\n\n    // Validate state\n    if (lpNftAddress == address(0)) {\n      revert ILPSFT.LPSFTInvalidToken(tokenId);\n    }\n\n    // Read external state\n    return pow1Token.balanceOf(lpNftAddress);\n  }\n\n  /**\n   * @dev See {IDeFiManager-pow1BalanceBatch}\n   */\n  function pow1BalanceBatch(\n    uint256[] memory tokenIds\n  ) external view override returns (uint256[] memory) {\n    // Return value\n    uint256[] memory balances = new uint256[](tokenIds.length);\n\n    // Handle tokens\n    for (uint i = 0; i < tokenIds.length; i++) {\n      // Translate parameters\n      uint256 tokenId = tokenIds.unsafeMemoryAccess(i);\n\n      // Read state\n      // slither-disable-next-line calls-loop\n      address lpNftAddress = lpSft.tokenIdToAddress(tokenId);\n\n      // Validate state\n      if (lpNftAddress == address(0)) {\n        revert ILPSFT.LPSFTInvalidAddress(lpNftAddress);\n      }\n\n      // Update return value\n      // slither-disable-next-line calls-loop\n      balances[i] = pow1Token.balanceOf(lpNftAddress);\n    }\n\n    return balances;\n  }\n\n  /**\n   * @dev See {IDeFiManager-pow5Balance}\n   */\n  function pow5Balance(\n    uint256 tokenId\n  ) external view override returns (uint256) {\n    // Read state\n    address lpNftAddress = lpSft.tokenIdToAddress(tokenId);\n\n    // Validate state\n    if (lpNftAddress == address(0)) {\n      revert ILPSFT.LPSFTInvalidToken(tokenId);\n    }\n\n    // Read external state\n    return pow5Token.balanceOf(lpNftAddress);\n  }\n\n  /**\n   * @dev See {IDeFiManager-pow5BalanceBatch}\n   */\n  function pow5BalanceBatch(\n    uint256[] memory tokenIds\n  ) external view override returns (uint256[] memory) {\n    // Return value\n    uint256[] memory balances = new uint256[](tokenIds.length);\n\n    // Handle tokens\n    for (uint i = 0; i < tokenIds.length; i++) {\n      // Translate parameters\n      uint256 tokenId = tokenIds.unsafeMemoryAccess(i);\n\n      // Read state\n      // slither-disable-next-line calls-loop\n      address lpNftAddress = lpSft.tokenIdToAddress(tokenId);\n\n      // Validate state\n      if (lpNftAddress == address(0)) {\n        revert ILPSFT.LPSFTInvalidAddress(lpNftAddress);\n      }\n\n      // Update return value\n      // slither-disable-next-line calls-loop\n      balances[i] = pow5Token.balanceOf(lpNftAddress);\n    }\n\n    return balances;\n  }\n\n  /**\n   * @dev See {IDeFiManager-lpPow1Balance}\n   */\n  function lpPow1Balance(\n    uint256 tokenId\n  ) external view override returns (uint256) {\n    // Read state\n    address lpNftAddress = lpSft.tokenIdToAddress(tokenId);\n\n    // Validate state\n    if (lpNftAddress == address(0)) {\n      revert ILPSFT.LPSFTInvalidToken(tokenId);\n    }\n\n    // Read external state\n    return lpPow1Token.balanceOf(lpNftAddress);\n  }\n\n  /**\n   * @dev See {IDeFiManager-lpPow1BalanceBatch}\n   */\n  function lpPow1BalanceBatch(\n    uint256[] memory tokenIds\n  ) external view override returns (uint256[] memory) {\n    // Return value\n    uint256[] memory balances = new uint256[](tokenIds.length);\n\n    // Handle tokens\n    for (uint i = 0; i < tokenIds.length; i++) {\n      // Translate parameters\n      uint256 tokenId = tokenIds.unsafeMemoryAccess(i);\n\n      // Read state\n      // slither-disable-next-line calls-loop\n      address lpNftAddress = lpSft.tokenIdToAddress(tokenId);\n\n      // Validate state\n      if (lpNftAddress == address(0)) {\n        revert ILPSFT.LPSFTInvalidAddress(lpNftAddress);\n      }\n\n      // Update return value\n      // slither-disable-next-line calls-loop\n      balances[i] = lpPow1Token.balanceOf(lpNftAddress);\n    }\n\n    return balances;\n  }\n\n  /**\n   * @dev See {IDeFiManager-lpPow5Balance}\n   */\n  function lpPow5Balance(\n    uint256 tokenId\n  ) external view override returns (uint256) {\n    // Read state\n    address lpNftAddress = lpSft.tokenIdToAddress(tokenId);\n\n    // Validate state\n    if (lpNftAddress == address(0)) {\n      revert ILPSFT.LPSFTInvalidToken(tokenId);\n    }\n\n    // Read external state\n    return lpPow5Token.balanceOf(lpNftAddress);\n  }\n\n  /**\n   * @dev See {IDeFiManager-lpPow5BalanceBatch}\n   */\n  function lpPow5BalanceBatch(\n    uint256[] memory tokenIds\n  ) external view override returns (uint256[] memory) {\n    // Return value\n    uint256[] memory balances = new uint256[](tokenIds.length);\n\n    // Handle tokens\n    for (uint i = 0; i < tokenIds.length; i++) {\n      // Translate parameters\n      uint256 tokenId = tokenIds.unsafeMemoryAccess(i);\n\n      // Read state\n      // slither-disable-next-line calls-loop\n      address lpNftAddress = lpSft.tokenIdToAddress(tokenId);\n\n      // Validate state\n      if (lpNftAddress == address(0)) {\n        revert ILPSFT.LPSFTInvalidAddress(lpNftAddress);\n      }\n\n      // Update return value\n      // slither-disable-next-line calls-loop\n      balances[i] = lpPow5Token.balanceOf(lpNftAddress);\n    }\n\n    return balances;\n  }\n\n  /**\n   * @dev See {IDeFiManager-noPow5Balance}\n   */\n  function noPow5Balance(\n    uint256 tokenId\n  ) external view override returns (uint256) {\n    // Read state\n    address lpNftAddress = lpSft.tokenIdToAddress(tokenId);\n\n    // Validate state\n    if (lpNftAddress == address(0)) {\n      revert ILPSFT.LPSFTInvalidToken(tokenId);\n    }\n\n    // Read external state\n    return noPow5Token.balanceOf(lpNftAddress);\n  }\n\n  /**\n   * @dev See {IDeFiManager-noPow5BalanceBatch}\n   */\n  function noPow5BalanceBatch(\n    uint256[] memory tokenIds\n  ) external view override returns (uint256[] memory) {\n    // Return value\n    uint256[] memory balances = new uint256[](tokenIds.length);\n\n    // Handle tokens\n    for (uint i = 0; i < tokenIds.length; i++) {\n      // Translate parameters\n      uint256 tokenId = tokenIds.unsafeMemoryAccess(i);\n\n      // Read state\n      // slither-disable-next-line calls-loop\n      address lpNftAddress = lpSft.tokenIdToAddress(tokenId);\n\n      // Validate state\n      if (lpNftAddress == address(0)) {\n        revert ILPSFT.LPSFTInvalidAddress(lpNftAddress);\n      }\n\n      // Update return value\n      // slither-disable-next-line calls-loop\n      balances[i] = noPow5Token.balanceOf(lpNftAddress);\n    }\n\n    return balances;\n  }\n\n  /**\n   * @dev See {IDeFiManager-issuePow5}\n   */\n  function issuePow5(\n    uint256 tokenId,\n    uint256 amount,\n    address recipient\n  ) external override nonReentrant {\n    // Validate access\n    _checkRole(DEFI_OPERATOR_ROLE);\n\n    // Read state\n    address lpNftAddress = lpSft.tokenIdToAddress(tokenId);\n\n    // Validate state\n    if (lpNftAddress == address(0)) {\n      revert ILPSFT.LPSFTInvalidToken(tokenId);\n    }\n\n    // Read DeFi state\n    uint256 lpPow1Balance_ = lpPow1Token.balanceOf(lpNftAddress);\n    uint256 noPow5Balance_ = noPow5Token.balanceOf(lpNftAddress);\n\n    // Calculate new DeFi state\n    uint256 newNoPow5Balance = noPow5Balance_ + amount;\n\n    // Verify new collateralization ratio is below the threshold\n    require(newNoPow5Balance <= lpPow1Balance_, \"Insufficent collateral\");\n\n    // Call external contracts\n    pow5Token.mint(recipient, amount);\n    noPow5Token.mint(lpNftAddress, amount);\n  }\n\n  /**\n   * @dev See {IDeFiManager-repayPow5}\n   */\n  function repayPow5(\n    uint256 tokenId,\n    uint256 amount\n  ) external override nonReentrant {\n    // Validate access\n    _checkRole(DEFI_OPERATOR_ROLE);\n\n    // Read state\n    address lpNftAddress = lpSft.tokenIdToAddress(tokenId);\n\n    // Validate state\n    if (lpNftAddress == address(0)) {\n      revert ILPSFT.LPSFTInvalidToken(tokenId);\n    }\n\n    // Update state\n    pow5Token.burn(_msgSender(), amount);\n    noPow5Token.burn(lpNftAddress, amount);\n  }\n}\n"
    },
    "contracts/src/defi/ERC20InterestFarm.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport {IERC20InterestFarm} from \"../interfaces/defi/IERC20InterestFarm.sol\";\nimport {RewardMath} from \"../utils/math/RewardMath.sol\";\n\n/**\n * @dev A contract to lend ERC20 tokens and earn rewards based on lending\n * duration and amounts\n *\n * Rewards are calculated based on the amount of time and tokens loaned.\n *\n * Rewards are updated on every interaction.\n */\ncontract ERC20InterestFarm is\n  Context,\n  ReentrancyGuard,\n  AccessControl,\n  IERC20InterestFarm\n{\n  using SafeERC20 for IERC20;\n  using RewardMath for uint256;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Roles\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Role allowing an address to deposit tokens into the pool\n   */\n  bytes32 public constant ERC20_FARM_OPERATOR_ROLE = \"ERC20_FARM_OPERATOR_ROLE\";\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Routes\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev The reward token distributed to stakers\n   */\n  IERC20 public immutable rewardToken;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // State\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Reward rate per second per loaned token, scaled by 1e18 for precision\n   */\n  uint256 private _rewardRate;\n\n  /**\n   * @dev Total amount of tokens currently loaned in the pool\n   */\n  uint256 private _totalLoaned;\n\n  /**\n   * @dev Timestamp of the last reward update, used to calculate reward accruals\n   */\n  uint256 private _lastUpdateTime;\n\n  /**\n   * @dev Total rewards per token stored, updated upon changes to state\n   * affecting reward calculations\n   */\n  uint256 private _rewardPerTokenStored;\n\n  /**\n   * @dev Mapping of user addresses to their loaned token amounts\n   */\n  mapping(address => uint256) private _userStaked;\n\n  /**\n   * @dev Mapping of user addresses to the last recorded reward per token paid\n   *\n   * Used to calculate earned rewards.\n   */\n  mapping(address => uint256) private _userRewardPerTokenPaid;\n\n  /**\n   * @dev Mapping of user addresses to their accrued but not yet claimed rewards\n   */\n  mapping(address => uint256) private _rewards;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Initialization\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Initializes the staking pool with the staking and reward tokens\n   *\n   * @param owner_ The owner of the contract\n   * @param rewardToken_ The address of the reward token\n   * @param rewardRate_ The reward rate per second per loaned token\n   */\n  constructor(address owner_, address rewardToken_, uint256 rewardRate_) {\n    // Validate parameters\n    require(owner_ != address(0), \"Invalid owner\");\n    require(rewardToken_ != address(0), \"Invalid reward token\");\n    require(rewardRate_ > 0, \"Invalid reward rate\");\n\n    // Initialize {AccessControl}\n    _grantRole(DEFAULT_ADMIN_ROLE, owner_);\n\n    // Initialize routes\n    rewardToken = IERC20(rewardToken_);\n\n    // Initialize state\n    _rewardRate = rewardRate_;\n    _lastUpdateTime = block.timestamp;\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IERC165} via {AccessControl} and {IERC20InterestFarm}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IERC165-supportsInterface}\n   */\n  function supportsInterface(\n    bytes4 interfaceId\n  ) public view override(AccessControl, IERC165) returns (bool) {\n    return\n      super.supportsInterface(interfaceId) ||\n      interfaceId == type(IERC20InterestFarm).interfaceId;\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IFarm} via {ERC20InterestFarm}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IFarm-rewardPerToken}\n   */\n  function rewardPerToken() public view override returns (uint256) {\n    // Calculate the amount of time that has passed since the last update\n    uint256 timeElapsed = block.timestamp - _lastUpdateTime;\n\n    return\n      _rewardPerTokenStored.calculateRewardPerToken(\n        timeElapsed,\n        _rewardRate,\n        _totalLoaned\n      );\n  }\n\n  /**\n   * @dev See {IFarm-earned}\n   */\n  function earned(address account) public view override returns (uint256) {\n    return\n      _userStaked[account].calculateEarned(\n        rewardPerToken(),\n        _userRewardPerTokenPaid[account],\n        _rewards[account]\n      );\n  }\n\n  /**\n   * @dev See {IFarm-balanceOf}\n   */\n  function balanceOf(address account) public view override returns (uint256) {\n    return _userStaked[account];\n  }\n\n  /**\n   * @dev See {IFarm-totalLoaned}\n   */\n  function totalLiquidity() public view override returns (uint256) {\n    return _totalLoaned;\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IERC20InterestFarm} via {IFarm}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IERC20InterestFarm-recordLoan}\n   */\n  function recordLoan(\n    address lpSftAddress,\n    uint256 amount\n  ) public override nonReentrant {\n    // Validate access\n    _checkRole(ERC20_FARM_OPERATOR_ROLE);\n\n    // Validate parameters\n    require(lpSftAddress != address(0), \"Invalid LP-SFT address\");\n\n    // Ensure the user is staking a non-zero amount to avoid unnecessary\n    // transactions\n    require(amount > 0, \"Cannot stake 0\");\n\n    // Update state\n    _updateReward(lpSftAddress);\n\n    // Increase the total amount of tokens loaned in the pool by the amount\n    // loaned\n    _totalLoaned += amount;\n\n    // Increase the loaned amount for this specific user\n    _userStaked[lpSftAddress] += amount;\n  }\n\n  /**\n   * @dev See {IERC20InterestFarm-recordRepayment}\n   */\n  function recordRepayment(\n    address lpSftAddress,\n    uint256 amount\n  ) public override nonReentrant {\n    // Validate access\n    _checkRole(ERC20_FARM_OPERATOR_ROLE);\n\n    // Validate parameters\n    require(lpSftAddress != address(0), \"Invalid LP-SFT address\");\n\n    // Ensure the withdrawal amount is greater than zero to avoid useless\n    // transactions\n    require(amount > 0, \"Cannot withdraw 0\");\n\n    // Ensure the user has enough tokens loaned for the withdrawal\n    require(\n      amount <= _userStaked[lpSftAddress],\n      \"Withdrawal amount exceeds balance\"\n    );\n\n    // Update state\n    _updateReward(lpSftAddress);\n\n    // Reduce the total loaned tokens in the pool by the withdrawal amount\n    _totalLoaned -= amount;\n\n    // Reduce the user's loaned tokens by the withdrawal amount\n    _userStaked[lpSftAddress] -= amount;\n  }\n\n  /**\n   * @dev See {IERC20InterestFarm-claimReward}\n   */\n  function claimReward(address lpSftAddress) public override nonReentrant {\n    // Validate access\n    _checkRole(ERC20_FARM_OPERATOR_ROLE);\n\n    // Validate parameters\n    require(lpSftAddress != address(0), \"Invalid LP-SFT address\");\n\n    // Update state\n    _updateReward(lpSftAddress);\n\n    // Calculate the total reward tokens the user has earned so far\n    uint256 reward = _rewards[lpSftAddress];\n\n    // Check if there is any reward to claim to avoid unnecessary transactions\n    // slither-disable-next-line timestamp\n    if (reward > 0) {\n      // Reset the user's reward balance to zero after claiming\n      _rewards[_msgSender()] = 0;\n\n      // Transfer the reward tokens from the contract to the LP-SFT\n      rewardToken.safeTransfer(lpSftAddress, reward);\n    }\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Private interface\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Modifier to update the reward calculations for a user\n   *\n   * This modifier updates the global reward state and the specific state for a\n   * given account.\n   *\n   * @param account The address of the user whose reward data needs updating\n   */\n  function _updateReward(address account) private {\n    // Update the global state for rewards per token stored, reflecting any\n    // changes since the last interaction\n    _rewardPerTokenStored = rewardPerToken();\n\n    // Record the timestamp of this update to track the period over which\n    // rewards are calculated\n    _lastUpdateTime = block.timestamp;\n\n    // If the account is not the zero address, update the user-specific reward\n    // data\n    if (account != address(0)) {\n      // Calculate the total rewards earned by the account up to this point,\n      // using the latest reward per token rate\n      _rewards[account] = earned(account);\n\n      // Update the rate of reward per token paid to this user to the latest\n      // calculated value\n      _userRewardPerTokenPaid[account] = _rewardPerTokenStored;\n    }\n  }\n}\n"
    },
    "contracts/src/defi/LPNFTStakeFarm.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {IERC1155Errors, IERC721Errors} from \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport {IERC1155Receiver} from \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {Arrays} from \"@openzeppelin/contracts/utils/Arrays.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport {INonfungiblePositionManager} from \"../../interfaces/uniswap-v3-periphery/INonfungiblePositionManager.sol\";\n\nimport {ERC1155Helpers} from \"../token/ERC1155/utils/ERC1155Helpers.sol\";\nimport {RewardMath} from \"../utils/math/RewardMath.sol\";\n\nimport {ILPNFTStakeFarm} from \"../interfaces/defi/ILPNFTStakeFarm.sol\";\nimport {IERC1155Enumerable} from \"../interfaces/token/ERC1155/extensions/IERC1155Enumerable.sol\";\nimport {ILPNFT} from \"../interfaces/token/ERC1155/ILPNFT.sol\";\nimport {ILPSFT} from \"../interfaces/token/ERC1155/ILPSFT.sol\";\n\n/**\n * @dev A contract to lend LP-NFTs and earn rewards based on lending duration\n * and liquidity amount\n *\n * Rewards are calculated based on the amount of time and liquidity staked.\n *\n * Rewards are updated on every interaction.\n */\ncontract LPNFTStakeFarm is Context, ReentrancyGuard, ILPNFTStakeFarm {\n  using Arrays for uint256[];\n  using RewardMath for uint256;\n  using SafeERC20 for IERC20;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Routes\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev The LP-SFT token contract used by the pool\n   */\n  ILPSFT public immutable lpSft;\n\n  /**\n   * @dev The reward token distributed to stakers\n   */\n  IERC20 public immutable rewardToken;\n\n  /**\n   * @dev The LP token used for lending balances\n   */\n  IERC20 public immutable lpToken;\n\n  /**\n   * @dev The POW1 token used to return tokens\n   */\n  IERC20 public immutable pow1Token;\n\n  /**\n   * @dev The POW5 token used to return tokens\n   */\n  IERC20 public immutable pow5Token;\n\n  /**\n   * @dev The Uniswap V3 NFT manager\n   */\n  INonfungiblePositionManager public immutable uniswapV3NftManager;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // State\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Reward rate per second per lent liquidity, scaled by 1e18 for precision\n   */\n  uint256 private _rewardRate;\n\n  /**\n   * @dev Total amount of liquidity currently lent to the pool\n   */\n  uint256 private _totalLiquidity;\n\n  /**\n   * @dev Timestamp of the last reward update, used to calculate reward accruals\n   */\n  uint256 private _lastUpdateTime;\n\n  /**\n   * @dev Total rewards per token stored, updated upon changes to state\n   * affecting reward calculations\n   */\n  uint256 private _rewardPerTokenStored;\n\n  /**\n   * @dev Mapping of user addresses to the last recorded reward per token paid\n   *\n   * Used to calculate earned rewards.\n   */\n  mapping(address user => uint256 rewardPerTokenPaid)\n    private _userRewardPerTokenPaid;\n\n  /**\n   * @dev Mapping of user addresses to their accrued but not yet claimed rewards\n   */\n  mapping(address user => uint256 accruedReward) private _rewards;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Initialization\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Initializes the lending pool with the lending and reward tokens\n   *\n   * @param lpSft_ The address of the SFT token\n   * @param rewardToken_ The address of the reward token\n   * @param lpToken_ The address of the LP token used to hold staked balances\n   * @param pow1Token_ The address of the POW1 token, used to return tokens\n   * @param pow5Token_ The address of the POW5 token, used to return tokens\n   * @param uniswapV3NftManager_ The address of the Uniswap V3 NFT manager\n   * @param rewardRate_ The reward rate per second per staked token\n   */\n  constructor(\n    address lpSft_,\n    address rewardToken_,\n    address lpToken_,\n    address pow1Token_,\n    address pow5Token_,\n    address uniswapV3NftManager_,\n    uint256 rewardRate_\n  ) {\n    // Validate parameters\n    require(lpSft_ != address(0), \"Invalid SFT token\");\n    require(rewardToken_ != address(0), \"Invalid reward token\");\n    require(lpToken_ != address(0), \"Invalid LP token\");\n    require(pow1Token_ != address(0), \"Invalid POW1 token\");\n    require(pow5Token_ != address(0), \"Invalid POW5 token\");\n    require(uniswapV3NftManager_ != address(0), \"Invalid NFT manager\");\n    require(rewardRate_ > 0, \"Invalid reward rate\");\n\n    // Initialize routes\n    lpSft = ILPSFT(lpSft_);\n    rewardToken = IERC20(rewardToken_);\n    lpToken = IERC20(lpToken_);\n    pow1Token = IERC20(pow1Token_);\n    pow5Token = IERC20(pow5Token_);\n    uniswapV3NftManager = INonfungiblePositionManager(uniswapV3NftManager_);\n\n    // Initialize state\n    _rewardRate = rewardRate_;\n    _lastUpdateTime = block.timestamp;\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IERC165} via {ILPNFTStakeFarm}\n  //////////////////////////////////////////////////////////////////////////////\n\n  function supportsInterface(\n    bytes4 interfaceId\n  ) public view virtual override returns (bool) {\n    return interfaceId == type(ILPNFTStakeFarm).interfaceId;\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IERC721Receiver} via {ILPNFTStakeFarm}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IERC721Receiver-onERC721Received}\n   */\n  function onERC721Received(\n    address,\n    address from,\n    uint256 tokenId,\n    bytes calldata\n  ) public virtual override nonReentrant returns (bytes4) {\n    // Validate parameters\n    if (from == address(0)) {\n      revert IERC721Errors.ERC721InvalidSender(from);\n    }\n    if (tokenId == 0) {\n      revert ILPNFT.LPNFTInvalidTokenID();\n    }\n\n    // Call external contract to create LP-SFT\n    // slither-disable-next-line reentrancy-benign\n    lpSft.mint(from, tokenId, \"\");\n\n    // Handle the LP-NFT\n    _onLpNftReceived(tokenId);\n\n    // Satisfy IERC721Receiver requirement\n    return IERC721Receiver.onERC721Received.selector;\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IERC1155Receiver} via {ILPNFTStakeFarm}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IERC1155Receiver-onERC1155Received}\n   */\n  function onERC1155Received(\n    address,\n    address from,\n    uint256 id,\n    uint256 value,\n    bytes calldata\n  ) public virtual override nonReentrant returns (bytes4) {\n    // Validate sender\n    require(_msgSender() == address(lpSft), \"Only LP-SFT\");\n\n    // Validate parameters\n    if (from == address(0)) {\n      revert IERC1155Errors.ERC1155InvalidSender(from);\n    }\n    if (id == 0) {\n      revert ILPNFT.LPNFTInvalidTokenID();\n    }\n    if (value != 1) {\n      revert IERC1155Enumerable.ERC1155EnumerableInvalidAmount(id, value);\n    }\n\n    // Handle the LP-SFT\n    _onLpSftReceived(from, id);\n\n    // Call external contract\n    lpSft.burn(address(this), id);\n\n    // Return any tokens to the sender\n    _returnTokens(from);\n\n    // Satisfy IERC1155Receiver requirement\n    return IERC1155Receiver.onERC1155Received.selector;\n  }\n\n  /**\n   * @dev See {IERC1155Receiver-onERC1155BatchReceived}\n   */\n  function onERC1155BatchReceived(\n    address,\n    address from,\n    uint256[] calldata ids,\n    uint256[] calldata values,\n    bytes calldata\n  ) public virtual override nonReentrant returns (bytes4) {\n    // Validate sender\n    require(_msgSender() == address(lpSft), \"Only LP-SFT\");\n\n    // Validate parameters\n    if (from == address(0)) {\n      revert IERC1155Errors.ERC1155InvalidSender(from);\n    }\n    ERC1155Helpers.checkAmountArray(ids, values);\n\n    // Translate parameters\n    uint256 tokenCount = ids.length;\n\n    // Handle the token\n    for (uint256 i = 0; i < tokenCount; i++) {\n      // Translate parameters\n      uint256 tokenId = ids.unsafeMemoryAccess(i);\n\n      // Validate parameters\n      if (tokenId == 0) {\n        revert ILPNFT.LPNFTInvalidTokenID();\n      }\n\n      // Handle the LP-SFT\n      _onLpSftReceived(from, tokenId);\n    }\n\n    // Call external contract\n    lpSft.burnBatch(address(this), ids);\n\n    // Return any tokens to the sender\n    _returnTokens(from);\n\n    // Satisfy IERC1155Receiver requirement\n    return IERC1155Receiver.onERC1155BatchReceived.selector;\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IFarm} via {ILPNFTStakeFarm}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IFarm-rewardPerToken}\n   */\n  function rewardPerToken() public view override returns (uint256) {\n    // Calculate the amount of time that has passed since the last update\n    uint256 timeElapsed = block.timestamp - _lastUpdateTime;\n\n    // slither-disable-next-line calls-loop\n    return\n      _rewardPerTokenStored.calculateRewardPerToken(\n        timeElapsed,\n        _rewardRate,\n        lpToken.totalSupply()\n      );\n  }\n\n  /**\n   * @dev See {IFarm-earned}\n   */\n  function earned(address account) public view override returns (uint256) {\n    // slither-disable-next-line calls-loop\n    return\n      lpToken.balanceOf(account).calculateEarned(\n        rewardPerToken(),\n        _userRewardPerTokenPaid[account],\n        _rewards[account]\n      );\n  }\n\n  /**\n   * @dev See {IFarm-balanceOf}\n   */\n  function balanceOf(address account) public view override returns (uint256) {\n    // slither-disable-next-line calls-loop\n    return lpToken.balanceOf(account);\n  }\n\n  /**\n   * @dev See {IFarm-totalLiquidity}\n   */\n  function totalLiquidity() public view override returns (uint256) {\n    // slither-disable-next-line calls-loop\n    return lpToken.totalSupply();\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Private interface\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Internal function to handle LP-NFT received events\n   *\n   * @param tokenId The token ID of the LP-NFT. Must not be zero.\n   */\n  function _onLpNftReceived(uint256 tokenId) private {\n    // Get the LP-SFT's address\n    address lpSftAddress = lpSft.tokenIdToAddress(tokenId);\n\n    // Validate the address\n    if (lpSftAddress == address(0)) {\n      revert ILPSFT.LPSFTInvalidToken(tokenId);\n    }\n\n    // Update the reward for the LP-SFT\n    _updateReward(lpSftAddress);\n  }\n\n  /**\n   * @dev Internal function to handle ERC1155 received events\n   *\n   * @param from The address of the sender. Must not be zero.\n   * @param tokenId The token ID of the LP-NFT. Must not be zero.\n   */\n  function _onLpSftReceived(address from, uint256 tokenId) private {\n    // Get the LP-SFT's address\n    // slither-disable-next-line calls-loop\n    address lpSftAddress = lpSft.tokenIdToAddress(tokenId);\n\n    // Validate the address\n    if (lpSftAddress == address(0)) {\n      revert ILPSFT.LPSFTInvalidToken(tokenId);\n    }\n\n    // Update the reward for the LP-SFT\n    _updateReward(lpSftAddress);\n\n    // Calculate the total reward tokens the LP-SFT has earned so far\n    uint256 reward = _rewards[lpSftAddress];\n\n    // Check if there is any reward to claim to avoid unnecessary transactions\n    // slither-disable-next-line timestamp\n    if (reward > 0) {\n      // Reset the LP-SFT's reward balance to zero after claiming\n      _rewards[lpSftAddress] = 0;\n\n      // Transfer the reward tokens from the contract to the user's wallet\n      // slither-disable-next-line calls-loop\n      rewardToken.safeTransfer(from, reward);\n    }\n\n    // Return the LP-NFT to the sender\n    // slither-disable-next-line calls-loop\n    uniswapV3NftManager.safeTransferFrom(address(this), from, tokenId, \"\");\n  }\n\n  /**\n   * @dev Return any game tokens to the user after burning a LP-SFT\n   *\n   * @param recipient The address of the recipient receiving the tokens\n   */\n  function _returnTokens(address recipient) private {\n    uint256 pow1Balance = pow1Token.balanceOf(address(this));\n    uint256 pow5Balance = pow5Token.balanceOf(address(this));\n\n    if (pow1Balance > 0) {\n      pow1Token.safeTransfer(recipient, pow1Balance);\n    }\n    if (pow5Balance > 0) {\n      pow5Token.safeTransfer(recipient, pow5Balance);\n    }\n  }\n\n  /**\n   * @dev Modifier to update the reward calculations for a user\n   *\n   * This modifier updates the global reward state and the specific state for a\n   * given account.\n   *\n   * @param account The address of the user whose reward data needs updating\n   */\n  function _updateReward(address account) private {\n    // Update the global state for rewards per token stored, reflecting any\n    // changes since the last interaction\n    // slither-disable-next-line calls-loop\n    _rewardPerTokenStored = rewardPerToken();\n\n    // Record the timestamp of this update to track the period over which\n    // rewards are calculated\n    _lastUpdateTime = block.timestamp;\n\n    // If the account is not the zero address, update the user-specific reward\n    // data\n    if (account != address(0)) {\n      // Calculate the total rewards earned by the account up to this point,\n      // using the latest reward per token rate\n      // slither-disable-next-line calls-loop\n      _rewards[account] = earned(account);\n\n      // Update the rate of reward per token paid to this user to the latest\n      // calculated value\n      _userRewardPerTokenPaid[account] = _rewardPerTokenStored;\n    }\n  }\n}\n"
    },
    "contracts/src/defi/LPSFTLendFarm.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport {IERC1155Receiver} from \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {Arrays} from \"@openzeppelin/contracts/utils/Arrays.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport {INonfungiblePositionManager} from \"../../interfaces/uniswap-v3-periphery/INonfungiblePositionManager.sol\";\n\nimport {RewardMath} from \"../utils/math/RewardMath.sol\";\n\nimport {ILPSFTLendFarm} from \"../interfaces/defi/ILPSFTLendFarm.sol\";\nimport {IERC1155Enumerable} from \"../interfaces/token/ERC1155/extensions/IERC1155Enumerable.sol\";\nimport {ILPNFT} from \"../interfaces/token/ERC1155/ILPNFT.sol\";\nimport {ILPSFT} from \"../interfaces/token/ERC1155/ILPSFT.sol\";\n\n/**\n * @dev A contract to lend LP-NFTs and earn rewards based on lending duration\n * and liquidity amount\n *\n * Rewards are calculated based on the amount of time and liquidity staked.\n *\n * Rewards are updated on every interaction.\n */\ncontract LPSFTLendFarm is\n  Context,\n  ReentrancyGuard,\n  AccessControl,\n  ILPSFTLendFarm\n{\n  using Arrays for uint256[];\n  using RewardMath for uint256;\n  using SafeERC20 for IERC20;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Roles\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev LP-SFT operator role\n   */\n  bytes32 public constant LPSFT_FARM_OPERATOR_ROLE = \"LPSFT_FARM_OPERATOR_ROLE\";\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Routes\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev The LP-SFT token contract used by the pool\n   */\n  ILPSFT public immutable lpSft;\n\n  /**\n   * @dev The reward token distributed to stakers\n   */\n  IERC20 public immutable rewardToken;\n\n  /**\n   * @dev The LP token used for lending balances\n   */\n  IERC20 public immutable lpToken;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // State\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Reward rate per second per lent liquidity, scaled by 1e18 for precision\n   */\n  uint256 private _rewardRate;\n\n  /**\n   * @dev Total amount of liquidity currently lent to the pool\n   */\n  uint256 private _totalLiquidity;\n\n  /**\n   * @dev Timestamp of the last reward update, used to calculate reward accruals\n   */\n  uint256 private _lastUpdateTime;\n\n  /**\n   * @dev Total rewards per token stored\n   *\n   * Updated upon changes to state that affect reward calculations.\n   */\n  uint256 private _rewardPerTokenStored;\n\n  /**\n   * @dev Mapping of user addresses to the last recorded reward per token paid\n   *\n   * Used to calculate earned rewards.\n   */\n  mapping(address user => uint256 rewardPerTokenPaid)\n    private _userRewardPerTokenPaid;\n\n  /**\n   * @dev Mapping of user addresses to their accrued but not yet claimed rewards\n   */\n  mapping(address user => uint256 accruedReward) private _rewards;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Initialization\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Initializes the lending pool with the lending and reward tokens\n   *\n   * @param owner_ The owner of the contract\n   * @param lpSft_ The address of the SFT token\n   * @param rewardToken_ The address of the reward token\n   * @param lpToken_ The address of the LP token used to hold staked balances\n   * @param rewardRate_ The reward rate per second per staked token\n   */\n  constructor(\n    address owner_,\n    address lpSft_,\n    address rewardToken_,\n    address lpToken_,\n    uint256 rewardRate_\n  ) {\n    // Validate parameters\n    require(owner_ != address(0), \"Invalid owner\");\n    require(lpSft_ != address(0), \"Invalid LP-SFT\");\n    require(rewardToken_ != address(0), \"Invalid reward\");\n    require(lpToken_ != address(0), \"Invalid LP\");\n    require(rewardRate_ > 0, \"Invalid rate\");\n\n    // Initialize {AccessControl}\n    _grantRole(DEFAULT_ADMIN_ROLE, owner_);\n\n    // Initialize routes\n    lpSft = ILPSFT(lpSft_);\n    rewardToken = IERC20(rewardToken_);\n    lpToken = IERC20(lpToken_);\n\n    // Initialize state\n    _rewardRate = rewardRate_;\n    _lastUpdateTime = block.timestamp;\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IERC165} via {AccessControl} and {ILPSFTLendFarm}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IERC165-supportsInterface}\n   */\n  function supportsInterface(\n    bytes4 interfaceId\n  ) public view override(AccessControl, IERC165) returns (bool) {\n    return\n      super.supportsInterface(interfaceId) ||\n      interfaceId == type(ILPSFTLendFarm).interfaceId;\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IFarm} via {ILPSFTLendFarm}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IFarm-rewardPerToken}\n   */\n  function rewardPerToken() public view override returns (uint256) {\n    // Calculate the amount of time that has passed since the last update\n    uint256 timeElapsed = block.timestamp - _lastUpdateTime;\n\n    // slither-disable-next-line calls-loop\n    return\n      _rewardPerTokenStored.calculateRewardPerToken(\n        timeElapsed,\n        _rewardRate,\n        lpToken.totalSupply()\n      );\n  }\n\n  /**\n   * @dev See {IFarm-earned}\n   */\n  function earned(address account) public view override returns (uint256) {\n    // slither-disable-next-line calls-loop\n    return\n      lpToken.balanceOf(account).calculateEarned(\n        rewardPerToken(),\n        _userRewardPerTokenPaid[account],\n        _rewards[account]\n      );\n  }\n\n  /**\n   * @dev See {IFarm-balanceOf}\n   */\n  function balanceOf(address account) public view override returns (uint256) {\n    // slither-disable-next-line calls-loop\n    return lpToken.balanceOf(account);\n  }\n\n  /**\n   * @dev See {IFarm-totalLiquidity}\n   */\n  function totalLiquidity() public view override returns (uint256) {\n    // slither-disable-next-line calls-loop\n    return lpToken.totalSupply();\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {ILPSFTLendFarm}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {ILPSFTLendFarm-lendLpSft}\n   */\n  function lendLpSft(uint256 tokenId) public override nonReentrant {\n    // Validate access\n    _checkRole(LPSFT_FARM_OPERATOR_ROLE);\n\n    // Validate parameters\n    if (tokenId == 0) {\n      revert ILPNFT.LPNFTInvalidTokenID();\n    }\n\n    // Get the LP-SFT's address\n    address lpSftAddress = lpSft.tokenIdToAddress(tokenId);\n\n    // Validate the address\n    if (lpSftAddress == address(0)) {\n      revert ILPSFT.LPSFTInvalidToken(tokenId);\n    }\n\n    // Update the reward for the LP-SFT\n    _updateReward(lpSftAddress);\n  }\n\n  /**\n   * @dev See {ILPSFTLendFarm-lendLpSftBatch}\n   */\n  function lendLpSftBatch(\n    uint256[] memory tokenIds\n  ) public override nonReentrant {\n    // Validate access\n    _checkRole(LPSFT_FARM_OPERATOR_ROLE);\n\n    // Translate parameters\n    uint256 tokenCount = tokenIds.length;\n\n    // Handle tokens\n    for (uint256 i = 0; i < tokenCount; i++) {\n      // Translate parameters\n      uint256 tokenId = tokenIds.unsafeMemoryAccess(i);\n\n      // Validate parameters\n      if (tokenId == 0) {\n        revert ILPNFT.LPNFTInvalidTokenID();\n      }\n\n      // Get the LP-SFT's address\n      // slither-disable-next-line calls-loop\n      address lpSftAddress = lpSft.tokenIdToAddress(tokenId);\n\n      // Validate the address\n      if (lpSftAddress == address(0)) {\n        revert ILPSFT.LPSFTInvalidToken(tokenId);\n      }\n\n      // Update the reward for the LP-SFT\n      _updateReward(lpSftAddress);\n    }\n  }\n\n  /**\n   * @dev See {ILPSFTLendFarm-withdrawLpSft}\n   */\n  function withdrawLpSft(uint256 tokenId) public override nonReentrant {\n    // Validate access\n    _checkRole(LPSFT_FARM_OPERATOR_ROLE);\n\n    // Validate parameters\n    if (tokenId == 0) {\n      revert ILPNFT.LPNFTInvalidTokenID();\n    }\n\n    // Get the LP-SFT's address\n    address lpSftAddress = lpSft.tokenIdToAddress(tokenId);\n\n    // Validate the address\n    if (lpSftAddress == address(0)) {\n      revert ILPSFT.LPSFTInvalidToken(tokenId);\n    }\n\n    // Update the reward for the LP-SFT\n    _updateReward(lpSftAddress);\n\n    // Calculate the total reward tokens the LP-SFT has earned so far\n    uint256 reward = _rewards[lpSftAddress];\n\n    // Check if there is any reward to claim to avoid unnecessary transactions\n    // slither-disable-next-line timestamp\n    if (reward > 0) {\n      // Reset the LP-SFT's reward balance to zero after claiming\n      _rewards[lpSftAddress] = 0;\n\n      // Transfer the reward tokens from the contract to the LP-SFT\n      // slither-disable-next-line calls-loop\n      rewardToken.safeTransfer(lpSftAddress, reward);\n    }\n  }\n\n  /**\n   * @dev See {ILPSFTLendFarm-withdrawLpSftBatch}\n   */\n  function withdrawLpSftBatch(\n    uint256[] memory tokenIds\n  ) public override nonReentrant {\n    // Validate access\n    _checkRole(LPSFT_FARM_OPERATOR_ROLE);\n\n    // Translate parameters\n    uint256 tokenCount = tokenIds.length;\n\n    // Handle tokens\n    for (uint256 i = 0; i < tokenCount; i++) {\n      // Translate parameters\n      uint256 tokenId = tokenIds.unsafeMemoryAccess(i);\n\n      // Validate parameters\n      if (tokenId == 0) {\n        revert ILPNFT.LPNFTInvalidTokenID();\n      }\n\n      // Get the LP-SFT's address\n      // slither-disable-next-line calls-loop\n      address lpSftAddress = lpSft.tokenIdToAddress(tokenId);\n\n      // Validate the address\n      if (lpSftAddress == address(0)) {\n        revert ILPSFT.LPSFTInvalidToken(tokenId);\n      }\n\n      // Update the reward for the LP-SFT\n      _updateReward(lpSftAddress);\n\n      // Calculate the total reward tokens the LP-SFT has earned so far\n      uint256 reward = _rewards[lpSftAddress];\n\n      // Check if there is any reward to claim to avoid unnecessary transactions\n      // slither-disable-next-line timestamp\n      if (reward > 0) {\n        // Reset the LP-SFT's reward balance to zero after claiming\n        _rewards[lpSftAddress] = 0;\n\n        // Transfer the reward tokens from the contract to the LP-SFT\n        // slither-disable-next-line calls-loop,reentrancy-no-eth\n        rewardToken.safeTransfer(lpSftAddress, reward);\n      }\n    }\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Private interface\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Modifier to update the reward calculations for a user\n   *\n   * This modifier updates the global reward state and the specific state for a\n   * given account.\n   *\n   * @param account The address of the user whose reward data needs updating\n   */\n  function _updateReward(address account) private {\n    // Update the global state for rewards per token stored, reflecting any\n    // changes since the last interaction\n    // slither-disable-next-line calls-loop\n    _rewardPerTokenStored = rewardPerToken();\n\n    // Record the timestamp of this update to track the period over which\n    // rewards are calculated\n    _lastUpdateTime = block.timestamp;\n\n    // If the account is not the zero address, update the user-specific reward\n    // data\n    if (account != address(0)) {\n      // Calculate the total rewards earned by the account up to this point,\n      // using the latest reward per token rate\n      // slither-disable-next-line calls-loop\n      _rewards[account] = earned(account);\n\n      // Update the rate of reward per token paid to this user to the latest\n      // calculated value\n      _userRewardPerTokenPaid[account] = _rewardPerTokenStored;\n    }\n  }\n}\n"
    },
    "contracts/src/defi/UniV3StakeFarm.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {IERC721Errors} from \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport {ERC1155Holder} from \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {ERC721Holder} from \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport {Arrays} from \"@openzeppelin/contracts/utils/Arrays.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport {IERC20Minimal} from \"../../interfaces/uniswap-v3-core/IERC20Minimal.sol\";\nimport {IUniswapV3Pool} from \"../../interfaces/uniswap-v3-core/IUniswapV3Pool.sol\";\nimport {INonfungiblePositionManager} from \"../../interfaces/uniswap-v3-periphery/INonfungiblePositionManager.sol\";\nimport {IUniswapV3Staker} from \"../../interfaces/uniswap-v3-staker/IUniswapV3Staker.sol\";\n\nimport {IUniV3StakeFarm} from \"../interfaces/defi/IUniV3StakeFarm.sol\";\nimport {IERC1155Enumerable} from \"../interfaces/token/ERC1155/extensions/IERC1155Enumerable.sol\";\nimport {ILPNFT} from \"../interfaces/token/ERC1155/ILPNFT.sol\";\nimport {ILPSFT} from \"../interfaces/token/ERC1155/ILPSFT.sol\";\n\n/**\n * @dev A contract to stake Uniswap V3 LP-NFTs with concentrated liquidity\n */\ncontract UniV3StakeFarm is\n  Context,\n  ReentrancyGuard,\n  AccessControl,\n  ERC721Holder,\n  ERC1155Holder,\n  IUniV3StakeFarm\n{\n  using Arrays for uint256[];\n  using SafeERC20 for IERC20;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Routes\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev The LP-SFT token contract used by the pool\n   */\n  ILPSFT public immutable lpSft;\n\n  /**\n   * @dev The reward token distributed to stakers\n   */\n  IERC20 public immutable rewardToken;\n\n  /**\n   * @dev The Uniswap V3 pool\n   */\n  IUniswapV3Pool public immutable uniswapV3Pool;\n\n  /**\n   * @dev The Uniswap V3 NFT manager\n   */\n  INonfungiblePositionManager public immutable uniswapV3NftManager;\n\n  /**\n   * @dev The Uniswap V3 cannonical staker\n   */\n  IUniswapV3Staker public immutable uniswapV3Staker;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // State\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev True if the incentive has been created, false otherwise\n   */\n  bool private _incentiveCreated = false;\n\n  /**\n   * @dev The Uniswap V3 staker incentive key, calculated when the incentive is\n   * created\n   */\n  IUniswapV3Staker.IncentiveKey private _incentiveKey;\n\n  /**\n   * @dev The Uniswap V3 staker incentive ID, calculated when the incentive is\n   * created\n   */\n  bytes32 private _incentiveId;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Initialization\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Initializes the lending pool with the lending and reward tokens\n   *\n   * @param owner_ The owner of the pool\n   * @param lpSft_ The address of the SFT token contract\n   * @param rewardToken_ The address of the reward token\n   * @param uniswapV3Pool_ The address of the upstream Uniswap V3 pool\n   * @param uniswapV3NftManager_ The address of the upstream Uniswap V3 NFT manager\n   * @param uniswapV3Staker_ The address of the upstream Uniswap V3 cannonical staker\n   */\n  constructor(\n    address owner_,\n    address lpSft_,\n    address rewardToken_,\n    address uniswapV3Pool_,\n    address uniswapV3NftManager_,\n    address uniswapV3Staker_\n  ) {\n    // Validate parameters\n    require(lpSft_ != address(0), \"Invalid SFT token\");\n    require(rewardToken_ != address(0), \"Invalid reward token\");\n    require(uniswapV3Pool_ != address(0), \"Invalid Uniswap V3 pool\");\n    require(uniswapV3NftManager_ != address(0), \"Invalid NFT manager\");\n    require(uniswapV3Staker_ != address(0), \"Invalid NFT manager\");\n\n    // Initialize {AccessControl}\n    _grantRole(DEFAULT_ADMIN_ROLE, owner_);\n\n    // Initialize routes\n    lpSft = ILPSFT(lpSft_);\n    rewardToken = IERC20(rewardToken_);\n    uniswapV3Pool = IUniswapV3Pool(uniswapV3Pool_);\n    uniswapV3NftManager = INonfungiblePositionManager(uniswapV3NftManager_);\n    uniswapV3Staker = IUniswapV3Staker(uniswapV3Staker_);\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IERC165} via {AccessControl} and {IUniV3StakeFarm}\n  //////////////////////////////////////////////////////////////////////////////\n\n  function supportsInterface(\n    bytes4 interfaceId\n  )\n    public\n    view\n    virtual\n    override(AccessControl, ERC1155Holder, IERC165)\n    returns (bool)\n  {\n    return\n      super.supportsInterface(interfaceId) ||\n      interfaceId == type(IERC721Receiver).interfaceId ||\n      interfaceId == type(IUniV3StakeFarm).interfaceId;\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IUniV3StakeFarm}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IUniV3StakeFarm-createIncentive}\n   */\n  function createIncentive(uint256 rewardAmount) public override nonReentrant {\n    // Validate access\n    _checkRole(DEFAULT_ADMIN_ROLE);\n\n    // Validate state\n    require(!_incentiveCreated, \"Incentive already created\");\n\n    // Update state\n    _incentiveCreated = true;\n    _incentiveKey = _createIncentiveKey();\n\n    // See IncentiveId.sol in the Uniswap V3 staker dependency\n    _incentiveId = keccak256(abi.encode(_incentiveKey));\n\n    // Transfer the reward to this contract\n    rewardToken.safeTransferFrom(_msgSender(), address(this), rewardAmount);\n\n    // Approve the Uniswap V3 staker to spend the reward\n    rewardToken.safeIncreaseAllowance(address(uniswapV3Staker), rewardAmount);\n\n    // Create the incentive\n    uniswapV3Staker.createIncentive(_incentiveKey, rewardAmount);\n\n    // Dispatch event\n    // slither-disable-next-line reentrancy-events\n    /*\n    emit IncentiveCreated(\n      _msgSender(),\n      address(rewardToken),\n      rewardAmount,\n      _incentiveKey.startTime,\n      _incentiveKey.endTime,\n      _incentiveKey.refundee\n    );\n    */\n  }\n\n  /**\n   * @dev See {IUniV3StakeFarm-isInitialized}\n   */\n  function isInitialized() external view override returns (bool) {\n    return _incentiveCreated;\n  }\n\n  /**\n   * @dev See {IUniV3StakeFarm-enter}\n   */\n  function enter(uint256 tokenId) external override nonReentrant {\n    // Validate parameters\n    if (tokenId == 0) {\n      revert ILPNFT.LPNFTInvalidTokenID();\n    }\n\n    // Transfer the LP-NFT to this contract\n    uniswapV3NftManager.safeTransferFrom(\n      address(_msgSender()),\n      address(this),\n      tokenId\n    );\n\n    // Send the LP-NFT to the Uniswap V3 staker contract and automatically\n    // stake it\n    uniswapV3NftManager.safeTransferFrom(\n      address(this),\n      address(uniswapV3Staker),\n      tokenId,\n      abi.encode(_incentiveKey)\n    );\n\n    // Mint the LP-SFT token to the sender\n    lpSft.mint(_msgSender(), tokenId, \"\");\n\n    // TODO: Emit event\n  }\n\n  /**\n   * @dev See {IUniV3StakeFarm-exit}\n   */\n  function exit(uint256 tokenId) external override nonReentrant {\n    // Validate parameters\n    if (tokenId == 0) {\n      revert ILPNFT.LPNFTInvalidTokenID();\n    }\n\n    // Transfer the LP-SFT to this contract\n    lpSft.safeTransferFrom(\n      address(_msgSender()),\n      address(this),\n      tokenId,\n      1,\n      \"\"\n    );\n\n    // Burn the LP-SFT token\n    lpSft.burn(address(this), tokenId);\n\n    // Read state\n    uint256 rewardBefore = uniswapV3Staker.rewards(\n      _incentiveKey.rewardToken,\n      address(this)\n    );\n\n    // Unstake the LP-NFT\n    uniswapV3Staker.unstakeToken(_incentiveKey, tokenId);\n\n    // Read state\n    uint256 rewardAfter = uniswapV3Staker.rewards(\n      _incentiveKey.rewardToken,\n      address(this)\n    );\n\n    // Claim the reward\n    // slither-disable-next-line unused-return\n    uniswapV3Staker.claimReward(\n      _incentiveKey.rewardToken,\n      address(this),\n      rewardAfter - rewardBefore\n    );\n\n    // Withdraw the LP-NFT from the staker\n    uniswapV3Staker.withdrawToken(tokenId, address(this), \"\");\n\n    // Read state\n    // slither-disable-next-line unused-return\n    (, , , , , , , uint128 liquidityAmount, , , , ) = uniswapV3NftManager\n      .positions(tokenId);\n\n    // Withdraw tokens from the pool\n    if (liquidityAmount > 0) {\n      // slither-disable-next-line unused-return\n      uniswapV3NftManager.decreaseLiquidity(\n        INonfungiblePositionManager.DecreaseLiquidityParams({\n          tokenId: tokenId,\n          liquidity: liquidityAmount,\n          amount0Min: 0,\n          amount1Min: 0,\n          // slither-disable-next-line timestamp\n          deadline: block.timestamp\n        })\n      );\n    }\n\n    // Collect the tokens and fees\n    // slither-disable-next-line unused-return\n    uniswapV3NftManager.collect(\n      INonfungiblePositionManager.CollectParams({\n        tokenId: tokenId,\n        recipient: address(this),\n        amount0Max: type(uint128).max,\n        amount1Max: type(uint128).max\n      })\n    );\n\n    // Read token addresses\n    IERC20 token0 = IERC20(uniswapV3Pool.token0());\n    IERC20 token1 = IERC20(uniswapV3Pool.token1());\n\n    // Read balances\n    uint256 rewardBalance = rewardToken.balanceOf(address(this));\n    uint256 token0Balance = token0.balanceOf(address(this));\n    uint256 token1Balance = token1.balanceOf(address(this));\n\n    // Return any tokens to the sender\n    if (rewardBalance > 0) {\n      rewardToken.safeTransfer(_msgSender(), rewardBalance);\n    }\n    if (token0Balance > 0) {\n      token0.safeTransfer(_msgSender(), token0Balance);\n    }\n    if (token1Balance > 0) {\n      token1.safeTransfer(_msgSender(), token1Balance);\n    }\n\n    // Return the empty LP-NFT to the sender as a keepsake\n    uniswapV3NftManager.safeTransferFrom(address(this), _msgSender(), tokenId);\n\n    /* TODO\n    // Dispatch event\n    // slither-disable-next-line reentrancy-events\n    emit NFTUnstaked(\n      _msgSender(),\n      recipient,\n      address(uniswapV3NftManager),\n      tokenId,\n      rewardClaimed,\n      assetTokenReturned\n    );\n    */\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Private interface\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Returns the incentive key for the Uniswap V3 staker\n   */\n  function _createIncentiveKey()\n    private\n    view\n    returns (IUniswapV3Staker.IncentiveKey memory)\n  {\n    return\n      IUniswapV3Staker.IncentiveKey({\n        rewardToken: IERC20Minimal(address(rewardToken)),\n        pool: uniswapV3Pool,\n        // slither-disable-next-line timestamp\n        startTime: block.timestamp,\n        // slither-disable-next-line timestamp\n        endTime: block.timestamp + 1 weeks, // TODO\n        refundee: address(this)\n      });\n  }\n}\n"
    },
    "contracts/src/interfaces/bureaucracy/dutchAuction/IDutchAuction.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {IDutchAuctionActions} from \"./IDutchAuctionActions.sol\";\nimport {IDutchAuctionAdminActions} from \"./IDutchAuctionAdminActions.sol\";\nimport {IDutchAuctionErrors} from \"./IDutchAuctionErrors.sol\";\nimport {IDutchAuctionEvents} from \"./IDutchAuctionEvents.sol\";\nimport {IDutchAuctionRoutes} from \"./IDutchAuctionRoutes.sol\";\nimport {IDutchAuctionState} from \"./IDutchAuctionState.sol\";\n\n/**\n * @title The interface for the Bureau of the Dutch Auction\n */\ninterface IDutchAuction is\n  IERC165,\n  IDutchAuctionEvents,\n  IDutchAuctionErrors,\n  IDutchAuctionRoutes,\n  IDutchAuctionState,\n  IDutchAuctionAdminActions,\n  IDutchAuctionActions\n{}\n"
    },
    "contracts/src/interfaces/bureaucracy/dutchAuction/IDutchAuctionActions.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * @title Bureau of the Dutch Auction, Public Action Interface\n */\ninterface IDutchAuctionActions is IERC165 {\n  //////////////////////////////////////////////////////////////////////////////\n  // Public interface\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Purchase and stake an LP-NFT at the current auction price\n   *\n   * If either `pow1Amount` or `marketTokenAmount` are zero, the purchase will\n   * be done via single-sided supply; about half of one token is swapped for the\n   * other before pooling. If neither are zero, the tokens will be supplied to\n   * the pool with no swap, and any unconsumed tokens (due to an imbalance with\n   * the current pool price) will be returned to the sender.\n   *\n   * Upon purchase, the LP-NFT is staked in a stake farm, and an LP-SFT is\n   * minted to the receiver.\n   *\n   * @param lpNftTokenId The LP-NFT token ID to purchase\n   * @param pow1Amount The amount of the game token to deposit\n   * @param marketTokenAmount The amount of the market token to deposit\n   * @param beneficiary The beneficiary of the tip paid as part of the auction\n   * @param receiver The receiver of the LP-SFT\n   */\n  function purchase(\n    uint256 lpNftTokenId,\n    uint256 pow1Amount,\n    uint256 marketTokenAmount,\n    address beneficiary,\n    address receiver\n  ) external;\n}\n"
    },
    "contracts/src/interfaces/bureaucracy/dutchAuction/IDutchAuctionAdminActions.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {IDutchAuctionState} from \"./IDutchAuctionState.sol\";\n\n/**\n * @title Bureau of the Dutch Auction, Admin Action Interface\n */\ninterface IDutchAuctionAdminActions is IERC165 {\n  //////////////////////////////////////////////////////////////////////////////\n  // Admin interface\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Initialize the Dutch Auction\n   *\n   * The Dutch Auction is initialized my minting the first POW1 LP-NFT and its\n   * holding LP-SFT. No creator tip is paid.\n   *\n   * It is assumed that this will be the first liquidity deposited in the pool,\n   * so both pow1Amount and marketTokenAmount are required to be non-zero.\n   *\n   * @param pow1Amount The amount of the game token to deposit\n   * @param marketTokenAmount The amount of the asset token to deposit\n   * @param receiver The receiver of the POW1 LP-SFT\n   *\n   * @return nftTokenId The initial LP-NFT/LP-SFT token ID\n   */\n  function initialize(\n    uint256 pow1Amount,\n    uint256 marketTokenAmount,\n    address receiver\n  ) external returns (uint256 nftTokenId);\n\n  /**\n   * @dev Check if the Dutch Auction is initialized\n   *\n   * @return True if the Dutch Auction is initialized, false otherwise\n   */\n  function isInitialized() external view returns (bool);\n\n  /**\n   * @dev Set the total number of LP-NFTs for sale\n   *\n   * If this is greater than the current number of LP-NFTs, the difference will\n   * be minted and added to the sale. If it is less, LP-NFTs won't be minted to\n   * replace the current ones as they are sold.\n   *\n   * @param auctionCount The target number of LP-NFTs for sale\n   * @param marketTokenDust Some dust to produre, if needed, to mint the LP-NFTs\n   */\n  function setAuctionCount(\n    uint32 auctionCount,\n    uint256 marketTokenDust\n  ) external;\n\n  /**\n   * @dev Get the total number of LP-NFTs for sale\n   *\n   * @return The total number of LP-NFTs for sale\n   */\n  function getAuctionCount() external view returns (uint32);\n}\n"
    },
    "contracts/src/interfaces/bureaucracy/dutchAuction/IDutchAuctionErrors.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\n/**\n * @title Bureau of the Dutch Auction, Error Interface\n *\n * @dev This includes errors for both public actions and admin actions\n */\ninterface IDutchAuctionErrors {\n  //////////////////////////////////////////////////////////////////////////////\n  // Admin Errors\n  //////////////////////////////////////////////////////////////////////////////\n\n  error DutchAuctionNotInitialized();\n\n  error DutchAuctionAlreadyInitialized();\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Public Errors\n  //////////////////////////////////////////////////////////////////////////////\n\n  error AuctionNotEnabled(uint256 slot);\n}\n"
    },
    "contracts/src/interfaces/bureaucracy/dutchAuction/IDutchAuctionEvents.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {IDutchAuctionState} from \"./IDutchAuctionState.sol\";\n\n/**\n * @title Bureau of the Dutch Auction, Event Interface\n */\ninterface IDutchAuctionEvents {\n  //////////////////////////////////////////////////////////////////////////////\n  // Events\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Event to emit when the Bureau of the Dutch Auction is initialized\n   *\n   * @param lpNftTokenId The token ID of the LP-NFT minted in the initialization\n   * @param gameTokenAmount The amount of game tokens used to initialize the pool\n   * @param assetTokenAmount The amount of asset tokens used to initialize the pool\n   * @param receiver The address of the receiver of the LP-SFT holding the staked LP-NFT\n   */\n  event AuctionInitialized(\n    uint256 lpNftTokenId,\n    uint256 gameTokenAmount,\n    uint256 assetTokenAmount,\n    address indexed initializer,\n    address indexed receiver\n  );\n\n  // TODO\n  /**\n   * @dev Event to emit when a new auction is created\n   *\n   * @param lpNftTokenId The token ID of the LP-NFT minted for the auction\n   * @param auctionStartTime The time when the auction started\n   * @param vrgdaParams The VRGDA parameters for the auction schedule\n   *\n  event AuctionCreated(\n    uint256 indexed lpNftTokenId,\n    uint256 auctionStartTime,\n    IDutchAuctionState.VRGDAParams vrgdaParams\n  );\n\n  /**\n   * @dev Event to emit when an LP-NFT is purchased\n   *\n   * @param lpNftTokenId The token ID of the LP-NFT purchased\n   * @param liquidityAmount The amount of LPPOW1 tokens in the purchased LP-NFT\n   * @param beneficiaryTip The beneficiary tip, in bips scaled by 1e18\n   * @param buyer The address of the buyer of the LP-NFT\n   * @param receiver The address of the receiver of the LP-NFT\n   *\n  event AuctionPurchased(\n    uint256 indexed lpNftTokenId,\n    uint128 liquidityAmount,\n    uint256 beneficiaryTip,\n    address indexed buyer,\n    address indexed receiver\n  );\n\n  /**\n   * @dev Event to emit when an LP-NFT position is exited, returning the\n   * underlying assets in the form of the asset token\n   *\n   * @param lpNftTokenId The token ID of the LP-NFT exited\n   * @param operator The address exiting the LP-NFT position\n   *\n  event AuctionExited(uint256 indexed lpNftTokenId, address indexed operator);\n  */\n}\n"
    },
    "contracts/src/interfaces/bureaucracy/dutchAuction/IDutchAuctionRoutes.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {IUniswapV3Factory} from \"../../../../interfaces/uniswap-v3-core/IUniswapV3Factory.sol\";\nimport {IUniswapV3Pool} from \"../../../../interfaces/uniswap-v3-core/IUniswapV3Pool.sol\";\nimport {INonfungiblePositionManager} from \"../../../../interfaces/uniswap-v3-periphery/INonfungiblePositionManager.sol\";\n\nimport {ILPNFTStakeFarm} from \"../../defi/ILPNFTStakeFarm.sol\";\nimport {ILPSFT} from \"../../token/ERC1155/ILPSFT.sol\";\nimport {IGameTokenPooler} from \"../../token/routes/IGameTokenPooler.sol\";\nimport {IGameTokenSwapper} from \"../../token/routes/IGameTokenSwapper.sol\";\nimport {IMarketStableSwapper} from \"../../token/routes/IMarketStableSwapper.sol\";\n\n/**\n * @title Bureau of the Dutch Auction, Routing Interface\n *\n * @dev These routes provide read-only access to the various contracts that the\n * Dutch Auction interacts with\n */\ninterface IDutchAuctionRoutes is IERC165 {\n  //////////////////////////////////////////////////////////////////////////////\n  // ERC-20 Token Routes\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev The POW1 game token\n   */\n  function pow1Token() external view returns (IERC20);\n\n  /**\n   * @dev The POW5 game token\n   */\n  function pow5Token() external view returns (IERC20);\n\n  /**\n   * @dev The market token paired with POW1\n   */\n  function marketToken() external view returns (IERC20);\n\n  /**\n   * @dev The stable token paired with POW5\n   */\n  function stableToken() external view returns (IERC20);\n\n  //////////////////////////////////////////////////////////////////////////////\n  // ERC-1155 Token Routes\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev The LP-SFT contract\n   */\n  function lpSft() external view returns (ILPSFT);\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Liquidity Pools\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev The POW1-market liquidity pool\n   */\n  function pow1MarketPool() external view returns (IUniswapV3Pool);\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Token Swappers\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev The swapper for the POW1-market token pair\n   */\n  function pow1MarketSwapper() external view returns (IGameTokenSwapper);\n\n  /**\n   * @dev The swapper for the POW5-stable token pair\n   */\n  function pow5StableSwapper() external view returns (IGameTokenSwapper);\n\n  /**\n   * @dev The swapper for the market-stable token pair\n   */\n  function marketStableSwapper() external view returns (IMarketStableSwapper);\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Token Poolers\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev The pooler for the POW1-market token pair\n   */\n  function pow1MarketPooler() external view returns (IGameTokenPooler);\n\n  //////////////////////////////////////////////////////////////////////////////\n  // LP-NFT Stake Farms\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev The POW1 LP-NFT stake farm\n   */\n  function pow1LpNftStakeFarm() external view returns (ILPNFTStakeFarm);\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Uniswap V3 Interfaces\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev The upstream Uniswap V3 NFT manager\n   */\n  function uniswapV3NftManager()\n    external\n    view\n    returns (INonfungiblePositionManager);\n}\n"
    },
    "contracts/src/interfaces/bureaucracy/dutchAuction/IDutchAuctionState.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * @title Bureau of the Dutch Auction, State Interface\n *\n * @dev This includes both state and derived state of the current enabled\n * auctions\n */\ninterface IDutchAuctionState is IERC165 {\n  //////////////////////////////////////////////////////////////////////////////\n  // Types\n  //////////////////////////////////////////////////////////////////////////////\n\n  struct AuctionSettings {\n    uint256 priceDecayRate; // The rate at which the price decreases (scaled by 1e18)\n    uint256 mintDustAmount; // Amount of dust required for pre-minting\n    uint256 priceIncrement; // Price increase ratio after each purchase (scaled by 1e18)\n    uint256 initialPriceBips; // Initial starting price (scaled by 1e18)\n    uint256 minPriceBips; // Minimum possible price (scaled by 1e18)\n    uint256 maxPriceBips; // Maximum possible price (scaled by 1e18)\n  }\n\n  struct BureauState {\n    uint256 totalAuctions; // Total number of LP-NFTs that have gone up for auction\n    uint256 lastSalePriceBips; // The price at which the last NFT was sold (scaled by 1e18)\n  }\n\n  struct AuctionState {\n    uint256 lpNftTokenId; // ID of the LP-NFT for sale\n    uint256 startPriceBips; // The starting price of the NFT (scaled by 1e18)\n    uint256 endPriceBips; // The end price after the auction's decay (minPrice)\n    uint256 startTime; // The time the auction starts\n    uint256 salePrice; // Set when the NFT has been sold, or 0 if unsold\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Public interface\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Returns the auction settings\n   *\n   * @return The AuctionSettings struct containing the auction configuration\n   */\n  function getAuctionSettings() external view returns (AuctionSettings memory);\n\n  /**\n   * @dev Returns the metadata of the Dutch Auction\n   *\n   * @return The BureauState struct containing the bureau state\n   */\n  function getBureauState() external view returns (BureauState memory);\n\n  /**\n   * @dev Returns the number of active auctions\n   *\n   * @return The total number of auctions in progress\n   */\n  function getCurrentAuctionCount() external view returns (uint256);\n\n  /**\n   * @dev Returns the list of current LP-NFT token IDs on auction\n   *\n   * @return An array of LP-NFT token IDs\n   */\n  function getCurrentAuctions() external view returns (uint256[] memory);\n\n  /**\n   * @dev Returns the auction states of the current auctions\n   *\n   * @return An array of AuctionState structs\n   */\n  function getCurrentAuctionStates()\n    external\n    view\n    returns (AuctionState[] memory);\n\n  /**\n   * @dev Returns the auction state for a given LP-NFT\n   *\n   * @param lpNftTokenId The token ID of the LP-NFT\n   * @return The AuctionState struct containing the auction details\n   */\n  function getAuctionState(\n    uint256 lpNftTokenId\n  ) external view returns (AuctionState memory);\n\n  /**\n   * @dev Get the current tip price for an LP-NFT\n   *\n   * @param lpNftTokenId The LP-NFT token ID\n   *\n   * @return currentPriceBips The LP-NFT tip price, scaled by 1e18\n   */\n  function getCurrentPriceBips(\n    uint256 lpNftTokenId\n  ) external view returns (uint256 currentPriceBips);\n\n  /**\n   * @dev Get the token URI for an LP-NFT\n   *\n   * @param lpNftTokenId The LP-NFT token ID\n   *\n   * @return tokenUri The URI of the LP-NFT\n   */\n  function getTokenUri(\n    uint256 lpNftTokenId\n  ) external view returns (string memory);\n}\n"
    },
    "contracts/src/interfaces/bureaucracy/ILiquidityForge.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * @title Bureau of the Liquidity Forge\n *\n * Collateralize the LP-NFT with a collateralization ratio of up to 100x in\n * return for a POW5 loan with negative interest.\n *\n * Like US dollars, POW5 is loaned into existence. Loan interest is set by an\n * inverted yield curve.\n *\n * Loans can be refinanced at any time. While collateralized, the DeFi\n * can be claimed by repaying the POW5 (which is destroyed) or by using a flash\n * loan.\n *\n * If the player defaults on the POW5 loan, the game is over for that LP-\n * and the player walks away with the POW5 principal plus interest and claimed\n * DeFi yield. Staked value and unclaimed yield is sold off by The Reserve for\n * the unpaid POW5 (which is destroyed). The empty LP-NFT returned to the\n * player as a keepsake.\n */\ninterface ILiquidityForge is IERC165 {\n  //////////////////////////////////////////////////////////////////////////////\n  // Public interface\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Borrow POW5 against a collateralized LP-SFT\n   *\n   * @param tokenId The LP-SFT token ID\n   * @param amount The amount of POW5 to borrow\n   * @param receiver The receiver of the POW5\n   */\n  function borrowPow5(\n    uint256 tokenId,\n    uint256 amount,\n    address receiver\n  ) external;\n\n  /**\n   * @dev Repay POW5 against a collateralized LP-SFT\n   *\n   * @param tokenId The LP-SFT ID\n   */\n  function repayPow5(uint256 tokenId, uint256 amount) external;\n}\n"
    },
    "contracts/src/interfaces/bureaucracy/IReverseRepo.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * @title Bureau of the Reverse Repo\n *\n * Lend your POW5 liquidity to The Reserve. Earn interest while accruing DeFi yield.\n */\ninterface IReverseRepo is IERC165 {\n  //////////////////////////////////////////////////////////////////////////////\n  // Admin interface\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Initialize the Reverse Repo\n   *\n   * The Dutch Auction is initialized my minting the first POW5 LP-SFT.\n   *\n   * It is assumed that this will be the first liquidity deposited in the pool,\n   * so both pow5Amount and stableTokenAmount are required to be non-zero.\n   *\n   * @param pow5Amount The amount of the game token to deposit\n   * @param stableTokenAmount The amount of the stable token to deposit\n   * @param receiver The receiver of the POW5 LP-SFT\n   *\n   * @return tokenId The LP-NFT/LP-SFT token ID\n   */\n  function initialize(\n    uint256 pow5Amount,\n    uint256 stableTokenAmount,\n    address receiver\n  ) external returns (uint256 tokenId);\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Public interface\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Buy a POW5 LP-SFT\n   *\n   * If either `pow5Amount` or `stableTokenAmount` are zero, the purchase\n   * will be done via single-sided supply; about half of one token is swapped\n   * for the other before pooling. If neither are zero, the tokens will be\n   * supplied to the pool with no swap, and any unconsumed tokens (due to an\n   * imbalance with the current pool price) will be returned to the receiver.\n   *\n   * @param pow5Amount The amount of the game token to deposit\n   * @param stableTokenAmount The amount of the stable token to deposit\n   * @param receiver The receiver of the POW5 LP-SFT\n   *\n   * @return tokenId The LP-NFT/LP-SFT token ID\n   */\n  function purchase(\n    uint256 pow5Amount,\n    uint256 stableTokenAmount,\n    address receiver\n  ) external returns (uint256 tokenId);\n\n  /**\n   * @dev Exit a POW5 LP-SFT position\n   *\n   * This function allows the LP-SFT owner to exit the pool, receiving their\n   * share of the pool's assets in the form of the stable token. The LP-SFT is\n   * burned in the process. The empty LP-NFT is returned to the sender.\n   *\n   * @param tokenId The LP-NFT/LP-SFT token ID\n   */\n  function exit(uint256 tokenId) external;\n}\n"
    },
    "contracts/src/interfaces/bureaucracy/theReserve/ITheReserve.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {ITheReserveRoutes} from \"./ITheReserveRoutes.sol\";\n\ninterface ITheReserve is IERC165, ITheReserveRoutes {}\n"
    },
    "contracts/src/interfaces/bureaucracy/theReserve/ITheReserveRoutes.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {IUniswapV3Factory} from \"../../../../interfaces/uniswap-v3-core/IUniswapV3Factory.sol\";\nimport {IUniswapV3Pool} from \"../../../../interfaces/uniswap-v3-core/IUniswapV3Pool.sol\";\nimport {INonfungiblePositionManager} from \"../../../../interfaces/uniswap-v3-periphery/INonfungiblePositionManager.sol\";\n\nimport {ILPNFTStakeFarm} from \"../../defi/ILPNFTStakeFarm.sol\";\nimport {ILPSFTLendFarm} from \"../../defi/ILPSFTLendFarm.sol\";\nimport {IUniV3StakeFarm} from \"../../defi/IUniV3StakeFarm.sol\";\nimport {ILPSFT} from \"../../token/ERC1155/ILPSFT.sol\";\nimport {INOLPSFT} from \"../../token/ERC1155/INOLPSFT.sol\";\nimport {IGameTokenPooler} from \"../../token/routes/IGameTokenPooler.sol\";\nimport {IGameTokenSwapper} from \"../../token/routes/IGameTokenSwapper.sol\";\nimport {IMarketStableSwapper} from \"../../token/routes/IMarketStableSwapper.sol\";\n\n/**\n * @title The Reserve Smart Contract, Routing Interface\n *\n * @dev These routes provide access to the contracts that The Reserve's various\n * bureaus interact with\n */\ninterface ITheReserveRoutes is IERC165 {\n  //////////////////////////////////////////////////////////////////////////////\n  // Types\n  //////////////////////////////////////////////////////////////////////////////\n\n  struct Routes {\n    IERC20 pow1Token;\n    IERC20 pow5Token;\n    IERC20 lpPow1Token;\n    IERC20 lpPow5Token;\n    IERC20 noPow5Token;\n    IERC20 marketToken;\n    IERC20 stableToken;\n    ILPSFT lpSft;\n    INOLPSFT noLpSft;\n    IUniswapV3Pool pow1MarketPool;\n    IUniswapV3Pool pow5StablePool;\n    IUniswapV3Pool marketStablePool;\n    IGameTokenSwapper pow1MarketSwapper;\n    IGameTokenSwapper pow5StableSwapper;\n    IMarketStableSwapper marketStableSwapper;\n    IGameTokenPooler pow1MarketPooler;\n    IGameTokenPooler pow5StablePooler;\n    ILPNFTStakeFarm pow1LpNftStakeFarm;\n    IUniV3StakeFarm pow5LpNftStakeFarm;\n    ILPSFTLendFarm pow1LpSftLendFarm;\n    ILPSFTLendFarm pow5LpSftLendFarm;\n    IUniswapV3Factory uniswapV3Factory;\n    INonfungiblePositionManager uniswapV3NftManager;\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Route Accessors\n  //////////////////////////////////////////////////////////////////////////////\n\n  function getRoutes() external view returns (Routes memory);\n\n  //////////////////////////////////////////////////////////////////////////////\n  // ERC-20 Token Routes\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev The POW1 game token\n   */\n  function pow1Token() external view returns (IERC20);\n\n  /**\n   * @dev The POW5 game token\n   */\n  function pow5Token() external view returns (IERC20);\n\n  /**\n   * @dev The LPPOW1 liquidity token\n   */\n  function lpPow1Token() external view returns (IERC20);\n\n  /**\n   * @dev The LPPOW5 liquidity token\n   */\n  function lpPow5Token() external view returns (IERC20);\n\n  /**\n   * @dev The NOPOW5 debt token\n   */\n  function noPow5Token() external view returns (IERC20);\n\n  /**\n   * @dev The market token paired with POW1\n   */\n  function marketToken() external view returns (IERC20);\n\n  /**\n   * @dev The stable token paired with POW5\n   */\n  function stableToken() external view returns (IERC20);\n\n  //////////////////////////////////////////////////////////////////////////////\n  // ERC-1155 Token Routes\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev The LP-SFT contract\n   */\n  function lpSft() external view returns (ILPSFT);\n\n  /**\n   * @dev The LP-SFT debt contract\n   */\n  function noLpSft() external view returns (INOLPSFT);\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Liquidity Pools\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev The POW1-market liquidity pool\n   */\n  function pow1MarketPool() external view returns (IUniswapV3Pool);\n\n  /**\n   * @dev The POW5-stable liquidity pool\n   */\n  function pow5StablePool() external view returns (IUniswapV3Pool);\n\n  /**\n   * @dev The market-stable liquidity pool\n   */\n  function marketStablePool() external view returns (IUniswapV3Pool);\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Token Swappers\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev The swapper for the POW1-market token pair\n   */\n  function pow1MarketSwapper() external view returns (IGameTokenSwapper);\n\n  /**\n   * @dev The swapper for the POW5-stable token pair\n   */\n  function pow5StableSwapper() external view returns (IGameTokenSwapper);\n\n  /**\n   * @dev The swapper for the market-stable token pair\n   */\n  function marketStableSwapper() external view returns (IMarketStableSwapper);\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Token Poolers\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev The pooler for the POW1-market token pair\n   */\n  function pow1MarketPooler() external view returns (IGameTokenPooler);\n\n  /**\n   * @dev The pooler for the POW5-stable token pair\n   */\n  function pow5StablePooler() external view returns (IGameTokenPooler);\n\n  //////////////////////////////////////////////////////////////////////////////\n  // LP-NFT Stake Farms\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev The POW1 LP-NFT stake farm\n   */\n  function pow1LpNftStakeFarm() external view returns (ILPNFTStakeFarm);\n\n  /**\n   * @dev The POW5 LP-NFT stake farm\n   */\n  function pow5LpNftStakeFarm() external view returns (IUniV3StakeFarm);\n\n  //////////////////////////////////////////////////////////////////////////////\n  // LP-SFT Lend Farms\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev The POW1 LP-SFT lend farm\n   */\n  function pow1LpSftLendFarm() external view returns (ILPSFTLendFarm);\n\n  /**\n   * @dev The POW5 LP-SFT lend farm\n   */\n  function pow5LpSftLendFarm() external view returns (ILPSFTLendFarm);\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Uniswap V3 Interfaces\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev The upstream Uniswap V3 factory used to create the liquidity pools\n   */\n  function uniswapV3Factory() external view returns (IUniswapV3Factory);\n\n  /**\n   * @dev The upstream Uniswap V3 NFT manager\n   */\n  function uniswapV3NftManager()\n    external\n    view\n    returns (INonfungiblePositionManager);\n}\n"
    },
    "contracts/src/interfaces/bureaucracy/yieldHarvest/IYieldHarvest.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {IERC1155Receiver} from \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * @title Bureau of the Yield Harvest\n *\n * Lend your LP-NFT to The Reserve. Earn interest while accruing DeFi yield.\n *\n * Lending happens by sending the LPSFT tokens to the Bureau of the Yield\n * Harvest. In return, LPSFT debt tokens (NOLPSFT) are minted to the sender.\n *\n * To redeem the LPSFT tokens, NOLPSFT tokens are sent back to the contract,\n * where they are burned.\n */\ninterface IYieldHarvest is IERC165, IERC1155Receiver {}\n"
    },
    "contracts/src/interfaces/defi/IDeFiManager.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * This file is derived from the Ultrachess project under the Apache 2.0 license.\n * Copyright (C) 2022-2023 Ultrachess team\n *\n * SPDX-License-Identifier: GPL-3.0-or-later AND Apache-2.0\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\n/**\n * @dev DeFi manager interface\n */\ninterface IDeFiManager is IERC165 {\n  //////////////////////////////////////////////////////////////////////////////\n  // Public accessors\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev The POW1 balance of the LP-SFT\n   *\n   * @param tokenId The token ID of the LP-SFT\n   *\n   * @return The POW1 balance\n   */\n  function pow1Balance(uint256 tokenId) external view returns (uint256);\n\n  /**\n   * @dev The POW1 balances of multiple LP-SFTs\n   *\n   * @param tokenIds The token IDs of the LP-SFTs\n   *\n   * @return The POW1 balances for all LP-SFTs\n   */\n  function pow1BalanceBatch(\n    uint256[] memory tokenIds\n  ) external view returns (uint256[] memory);\n\n  /**\n   * @dev The POW5 balance of the LP-SFT\n   *\n   * @param tokenId The token ID of the LP-SFT\n   *\n   * @return The POW5 balance\n   */\n  function pow5Balance(uint256 tokenId) external view returns (uint256);\n\n  /**\n   * @dev The POW5 balances of multiple LP-SFTs\n   *\n   * @param tokenIds The token IDs of the LP-SFTs\n   *\n   * @return The POW5 balances for all LP-SFTs\n   */\n  function pow5BalanceBatch(\n    uint256[] memory tokenIds\n  ) external view returns (uint256[] memory);\n\n  /**\n   * @dev The LPPOW1 balance of the LP-SFT\n   *\n   * @param tokenId The token ID of the LP-SFT\n   *\n   * @return The LPPOW1 balance\n   */\n  function lpPow1Balance(uint256 tokenId) external view returns (uint256);\n\n  /**\n   * @dev The LPPOW1 balances of multiple LP-SFTs\n   *\n   * @param tokenIds The tokens ID of the LP-SFTs\n   *\n   * @return The LPPOW1 balances for all LP-SFTs\n   */\n  function lpPow1BalanceBatch(\n    uint256[] memory tokenIds\n  ) external view returns (uint256[] memory);\n\n  /**\n   * @dev The LPPOW5 balance of the LP-SFT\n   *\n   * @param tokenId The token ID of the LP-SFT\n   *\n   * @return The LPPOW5 balance\n   */\n  function lpPow5Balance(uint256 tokenId) external view returns (uint256);\n\n  /**\n   * @dev The LPPOW5 balances of multiple LP-SFTs\n   *\n   * @param tokenIds The token IDs of the LP-SFTs\n   *\n   * @return The LPPOW5 balances for all LP-SFTs\n   */\n  function lpPow5BalanceBatch(\n    uint256[] memory tokenIds\n  ) external view returns (uint256[] memory);\n\n  /**\n   * @dev The NOPOW5 balance of the LP-SFT\n   *\n   * @param tokenId The token ID of the LP-SFT\n   *\n   * @return The NOPOW5 balance\n   */\n  function noPow5Balance(uint256 tokenId) external view returns (uint256);\n\n  /**\n   * @dev The NOPOW5 balances of multiple LP-SFTs\n   *\n   * @param tokenIds The token IDs of the LP-SFTs\n   *\n   * @return The NOPOW5 balances for all LP-SFTs\n   */\n  function noPow5BalanceBatch(\n    uint256[] memory tokenIds\n  ) external view returns (uint256[] memory);\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Liquidity Forge functions\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Issue a POW5 loan using the LP-NFT as collateral\n   */\n  function issuePow5(\n    uint256 tokenId,\n    uint256 amount,\n    address recipient\n  ) external;\n\n  /**\n   * @dev Repay a POW5 loan\n   */\n  function repayPow5(uint256 tokenId, uint256 amount) external;\n}\n"
    },
    "contracts/src/interfaces/defi/IERC20InterestFarm.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nimport {IFarm} from \"./IFarm.sol\";\n\n/**\n * @dev A contract to lend ERC20 tokens and earn rewards based on lending\n * duration and amounts\n *\n * Rewards are calculated based on the amount of time and tokens loaned.\n *\n * Rewards are updated on every interaction.\n */\ninterface IERC20InterestFarm is IERC165, IFarm {\n  //////////////////////////////////////////////////////////////////////////////\n  // Public mutators\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Allows a user to deposit tokens into the pool\n   *\n   * This function increases both the total loaned tokens in the pool and the\n   * loaned amount for the user calling the function.\n   *\n   * @param lpSftAddress The address of the LP-SFT\n   * @param amount The amount of tokens the user wishes to stake\n   */\n  function recordLoan(address lpSftAddress, uint256 amount) external;\n\n  /**\n   * @dev Allows a user to withdraw loaned tokens from the pool\n   *\n   * This function decreases both the total loaned tokens in the pool and the\n   * user's loaned amount.\n   *\n   * @param lpSftAddress The address of the LP-SFT\n   * @param amount The amount of tokens the user wishes to withdraw\n   */\n  function recordRepayment(address lpSftAddress, uint256 amount) external;\n\n  /**\n   * @dev Allows a user to claim their accumulated rewards from the pool\n   *\n   * This function transfers the accumulated rewards to the user's wallet.\n   *\n   * @param lpSftAddress The address of the LP-SFT\n   */\n  function claimReward(address lpSftAddress) external;\n}\n"
    },
    "contracts/src/interfaces/defi/IFarm.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\n/**\n * @dev A contract to earn rewards based on duration and amount\n *\n * Rewards are updated on every interaction.\n */\ninterface IFarm is IERC165 {\n  //////////////////////////////////////////////////////////////////////////////\n  // Public accessors\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Calculates the accumulated balance of reward per token staked\n   *\n   * This function computes how much reward each token staked has accumulated\n   * over time, up to the latest block timestamp. It is scaled up by 1e18 to\n   * avoid precision loss during division.\n   *\n   * @return The updated reward per token value\n   */\n  function rewardPerToken() external view returns (uint256);\n\n  /**\n   * @dev Calculates the total reward tokens that an account has earned but\n   * not yet claimed\n   *\n   * This function determines the amount of reward tokens an account is entitled\n   * to, based on their staked tokens and the difference between the latest\n   * reward rate per token and the rate already paid to them, plus any rewards\n   * already accrued but not yet transferred.\n   *\n   * @param account The address of the user to calculate the earned rewards\n   *\n   * @return The total amount of reward tokens earned by the user\n   */\n  function earned(address account) external view returns (uint256);\n\n  /**\n   * @dev Calculates the total amount of staked tokens for a given account\n   *\n   * @param account The address of the account to check\n   *\n   * @return The total amount of liquidity lent by the account\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Get the total amount of tokens staked in the pool\n   *\n   * @return The total amount staked\n   */\n  function totalLiquidity() external view returns (uint256);\n}\n"
    },
    "contracts/src/interfaces/defi/ILPNFTStakeFarm.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {IERC1155Receiver} from \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nimport {IFarm} from \"./IFarm.sol\";\n\n/**\n * @dev A contract to lend LP-NFTs and earn rewards based on lending duration\n * and liquidity amount\n *\n * Rewards are calculated based on the amount of time and liquidity staked.\n *\n * Rewards are updated on every interaction.\n */\ninterface ILPNFTStakeFarm is\n  IERC165,\n  IERC721Receiver,\n  IERC1155Receiver,\n  IFarm\n{}\n"
    },
    "contracts/src/interfaces/defi/ILPSFTLendFarm.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nimport {IFarm} from \"./IFarm.sol\";\n\n/**\n * @dev A contract to lend LP-NFTs and earn rewards based on lending duration\n * and liquidity amount\n *\n * Rewards are calculated based on the amount of time and liquidity staked.\n *\n * Rewards are updated on every interaction.\n */\ninterface ILPSFTLendFarm is IERC165, IFarm {\n  //////////////////////////////////////////////////////////////////////////////\n  // Public mutators\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Lend an LP-SFT to the pool\n   *\n   * @param tokenId The LP-SFT token ID\n   */\n  function lendLpSft(uint256 tokenId) external;\n\n  /**\n   * @dev Lend a batch of LP-SFTs to the pool\n   *\n   * @param tokenIds The LP-SFT token IDs\n   */\n  function lendLpSftBatch(uint256[] memory tokenIds) external;\n\n  /**\n   * @dev Withdraw an LP-SFT from the pool\n   *\n   * @param tokenId The LP-SFT token ID\n   */\n  function withdrawLpSft(uint256 tokenId) external;\n\n  /**\n   * @dev Withdraw a batch of LP-SFTs from the pool\n   *\n   * @param tokenIds The LP-SFT token IDs\n   */\n  function withdrawLpSftBatch(uint256[] memory tokenIds) external;\n}\n"
    },
    "contracts/src/interfaces/defi/IUniV3StakeFarm.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\n/**\n * @dev A contract to stake Uniswap V3 LP-NFTs with concentrated liquidity\n */\ninterface IUniV3StakeFarm is IERC165 {\n  //////////////////////////////////////////////////////////////////////////////\n  // Initialization\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Initializes the Uniswap V3 staker incentive\n   *\n   * @param rewardAmount The reward to distribute in the incentive\n   *\n   * TODO: Allow creating multiple incentives?\n   */\n  function createIncentive(uint256 rewardAmount) external;\n\n  /**\n   * @dev Checks if the Uniswap V3 staker incentive has been initialized\n   *\n   * @return True if the incentive has been initialized, false otherwise\n   */\n  function isInitialized() external view returns (bool);\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Public interface\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Enter a staked position\n   *\n   * The LP-NFT is transferred to the staker. An LP-SFT is minted and returned\n   * to the recipient.\n   *\n   * @param tokenId The token ID of the LP-NFT\n   */\n  function enter(uint256 tokenId) external;\n\n  /**\n   * @dev Exit a staked position\n   *\n   * All tokens and rewards will be returned to the sender. The empty LP-NFT\n   * is also returned to the sender as a keepsake.\n   *\n   * @param tokenId The token ID of the LP-NFT/LP-SFT\n   */\n  function exit(uint256 tokenId) external;\n}\n"
    },
    "contracts/src/interfaces/token/ERC1155/extensions/IERC1155Enumerable.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * This file is derived from the Ultrachess project under the Apache 2.0 license.\n * Copyright (C) 2022-2023 Ultrachess team\n *\n * This file is derived from the OpenZeppelin project under the MIT license.\n * Copyright (c) 2016-2024 Zeppelin Group Ltd and contributors\n *\n * SPDX-License-Identifier: GPL-3.0-or-later AND Apache-2.0 AND MIT\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * @title ERC-1155: Multi Token Standard, optional enumeration extension\n *\n * @dev See https://eips.ethereum.org/EIPS/eip-1155\n *\n * This contract is analogous to the OpenZeppelin IERC721Enumerable contract.\n *\n * Implementers must enforce the constraint that all SFTs are NFTs (they are\n * unique with a total supply of 1).\n */\ninterface IERC1155Enumerable is IERC165, IERC1155 {\n  //////////////////////////////////////////////////////////////////////////////\n  // Errors\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Error raised if the amount of an NFT is not 1\n   *\n   * @param tokenId The ID of the NFT token with an invalid amount\n   * @param amount The amount of the NFT token\n   */\n  error ERC1155EnumerableInvalidAmount(uint256 tokenId, uint256 amount);\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Public interface\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Returns the total amount of tokens stored by the contract\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the owner of the NFT specified by `tokenId`\n   *\n   * @param tokenId The ID of the NFT token\n   *\n   * @return owner The owner of the token, or `address(0)` if the token does\n   *               not exist\n   */\n  function ownerOf(uint256 tokenId) external view returns (address owner);\n\n  /**\n   * @dev Return all token IDs owned by account\n   *\n   * @param account The account to query\n   *\n   * @return tokenIds The token IDs owned by the account\n   */\n  function getTokenIds(\n    address account\n  ) external view returns (uint256[] memory tokenIds);\n}\n"
    },
    "contracts/src/interfaces/token/ERC1155/extensions/ILPNFTHolder.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\n/**\n * @title LP-NFT holder for SFT contract\n */\ninterface ILPNFTHolder is IERC165, IERC1155 {\n  /**\n   * @dev Get the token ID of a given address\n   *\n   * @param tokenAddress The address to convert to a token ID\n   *\n   * @return The token ID on success, or uint256(0) if `tokenAddress` does not\n   * belong to a token ID\n   */\n  function addressToTokenId(\n    address tokenAddress\n  ) external view returns (uint256);\n\n  /**\n   * @dev Get the token IDs of multiple addresses\n   *\n   * @param tokenAddresses The addresses to convert to token IDs\n   *\n   * @return The addresses for the token IDs\n   */\n  function addressesToTokenIds(\n    address[] memory tokenAddresses\n  ) external view returns (uint256[] memory);\n\n  /**\n   * @dev Get the address for a given token ID\n   *\n   * @param tokenId The token ID to convert to an address\n   *\n   * @return The address, or address(0) in case `tokenId` does not belong to\n   * an LP-NFT\n   */\n  function tokenIdToAddress(uint256 tokenId) external view returns (address);\n\n  /**\n   * @dev Get the addresses for multiple token IDs\n   *\n   * @param tokenIds The token IDs to convert to addresses\n   *\n   * @return The addresses for the token IDs\n   */\n  function tokenIdsToAddresses(\n    uint256[] memory tokenIds\n  ) external view returns (address[] memory);\n}\n"
    },
    "contracts/src/interfaces/token/ERC1155/extensions/ILPSFTIssuable.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\n/**\n * @dev LP-SFT issuable extension for LP-SFT minting and burning\n */\ninterface ILPSFTIssuable is IERC165, IERC1155 {\n  //////////////////////////////////////////////////////////////////////////////\n  // Issuable interface\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Mints a new LP-SFT\n   *\n   * @param to The account receiving the minted LP-SFT\n   * @param sftTokenId The token ID of the minted LP-SFT\n   * @param data Extra data passed to the receiver contract\n   */\n  function mint(address to, uint256 sftTokenId, bytes memory data) external;\n\n  /**\n   * @dev Mints a batch of LP-SFTs\n   *\n   * @param to The account receiving the minted LP-SFT\n   * @param sftTokenIds The token IDs of the minted SFTs\n   * @param data Extra data passed to the receiver contract\n   *\n   * Note: This function does not place a limit on the number of LP-SFTs that\n   * can be minted in a single transaction. The number of LP-SFTs to mint can\n   * exceed the block gas limit, denying the transaction from completing.\n   */\n  function mintBatch(\n    address to,\n    uint256[] memory sftTokenIds,\n    bytes memory data\n  ) external;\n\n  /**\n   * @dev Burns an existing LP-SFT\n   *\n   * @param from The account to burn an LP-SFT from\n   * @param sftTokenId The token ID of the LP-SFT to burn\n   */\n  function burn(address from, uint256 sftTokenId) external;\n\n  /**\n   * @dev Burns a batch of existing LP-SFTs\n   *\n   * @param from The account to burn LP-SFTs from\n   * @param sftTokenIds The token IDs of the LP-SFTs to burn\n   *\n   * Note: This function does not place a limit on the number of LP-SFTs that\n   * can be burned in a single transaction. The number of LP-SFTs to burn can\n   * exceed the block gas limit, denying the transaction from completing.\n   */\n  function burnBatch(address from, uint256[] memory sftTokenIds) external;\n}\n"
    },
    "contracts/src/interfaces/token/ERC1155/ILPNFT.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\n/**\n * @dev LP-NFT interface\n */\ninterface ILPNFT is IERC165 {\n  //////////////////////////////////////////////////////////////////////////////\n  // Types\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Enum for which pool the LP-NFT belongs to, either LPPOW1 or LPPOW5\n   */\n  enum Pool {\n    INVALID,\n    LPPOW1,\n    LPPOW5\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Errors\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Error raised if a token ID is 0\n   *\n   * Uniswap V3 LP-NFTs start with ID 1, so a token ID of 0 is used to indicate\n   * an invalid ID.\n   */\n  error LPNFTInvalidTokenID();\n\n  /**\n   * @dev Error raised if the LP-NFT is for neither LPPOW1 nor LPPOW5 pools\n   *\n   * @param tokenId The token ID of the LP-NFT\n   */\n  error LPNFTInvalidPool(uint256 tokenId);\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Lifecycle interface\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Initialize the LP-NFT\n   *\n   * @param lpNftTokenId The token ID of the LP-NFT\n   */\n  function initialize(uint256 lpNftTokenId) external;\n\n  /**\n   * @dev Deinitialize the LP-NFT\n   *\n   * Returns any leftover ETH or ERC-20 tokens to the beneficiary.\n   *\n   * @param beneficiary The beneficiary of leftover ETH or ERC-20 tokens, if any\n   */\n  function deinitialize(address beneficiary) external;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Public interface\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Get the LP-NFT's token ID\n   *\n   * @return The LP-NFT's token ID\n   */\n  function tokenId() external view returns (uint256);\n\n  /**\n   * @dev Get the LP-NFT's URI\n   *\n   * @return The LP-NFT's URI\n   */\n  function uri() external view returns (string memory);\n\n  //////////////////////////////////////////////////////////////////////////////\n  // DeFi interface\n  /////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Get the pool of the LP-NFT, either LPPOW1 or LPPOW5\n   *\n   * @return The pool of the LP-NFT, or UNKNOWN if the LP-NFT is invalid\n   */\n  function pool() external view returns (Pool);\n\n  /**\n   * @dev Get the POW1 balance of the LP-NFT\n   *\n   * @return The POW1 balance\n   */\n  function pow1Balance() external view returns (uint256);\n\n  /**\n   * @dev Get the POW5 balance of the LP-NFT\n   *\n   * @return The POW5 balance\n   */\n  function pow5Balance() external view returns (uint256);\n\n  /**\n   * @dev Get the LPPOW1 balance of the LP-NFT\n   *\n   * @return The LPPOW1 balance\n   */\n  function lpPow1Balance() external view returns (uint256);\n\n  /**\n   * @dev Get the LPPOW5 balance of the LP-NFT\n   *\n   * @return The LPPOW5 balance\n   */\n  function lpPow5Balance() external view returns (uint256);\n\n  /**\n   * @dev Get the mount of POW5 debt held by the LP-NFT\n   *\n   * @return The NOPOW5 balance\n   */\n  function noPow5Balance() external view returns (uint256);\n}\n"
    },
    "contracts/src/interfaces/token/ERC1155/ILPSFT.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nimport {IERC1155Enumerable} from \"./extensions/IERC1155Enumerable.sol\";\nimport {ILPSFTIssuable} from \"./extensions/ILPSFTIssuable.sol\";\nimport {ILPNFTHolder} from \"./extensions/ILPNFTHolder.sol\";\n\n/**\n * @dev LP-SFT interface\n */\ninterface ILPSFT is IERC165, IERC1155Enumerable, ILPSFTIssuable, ILPNFTHolder {\n  //////////////////////////////////////////////////////////////////////////////\n  // Errors\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Error raised if a token doesn't exist\n   *\n   * @param tokenId The token ID that doesn't exist\n   */\n  error LPSFTInvalidToken(uint256 tokenId);\n\n  /**\n   * @dev Error raised if a token address doesn't belong to a token ID\n   */\n  error LPSFTInvalidAddress(address tokenAddress);\n\n  /**\n   * @dev Indicates an array of length zero was passed for token IDs\n   *\n   * Used to avoid unnecessary transactions.\n   */\n  error LPSFTEmptyArray();\n}\n"
    },
    "contracts/src/interfaces/token/ERC1155/INOLPSFT.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {IERC1155Enumerable} from \"./extensions/IERC1155Enumerable.sol\";\nimport {ILPSFTIssuable} from \"./extensions/ILPSFTIssuable.sol\";\n\n/**\n * @dev LP-SFT debt interface\n */\ninterface INOLPSFT is IERC165, IERC1155Enumerable, ILPSFTIssuable {}\n"
    },
    "contracts/src/interfaces/token/ERC20/extensions/IERC20Issuable.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * This file is derived from the Ultrachess project under the Apache 2.0 license.\n * Copyright (C) 2022-2023 Ultrachess team\n *\n * SPDX-License-Identifier: GPL-3.0-or-later AND Apache-2.0\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\n/**\n * @title ERC-20: Token Standard, optional issuable extension\n *\n * @dev See https://eips.ethereum.org/EIPS/eip-20\n */\ninterface IERC20Issuable is IERC165, IERC20 {\n  /**\n   * @dev Mints new coins\n   *\n   * @param to The account to mint coins to\n   * @param amount The amount of coins to mint\n   */\n  function mint(address to, uint256 amount) external;\n\n  /**\n   * @dev Burns existing coins\n   *\n   * @param from The account to burn coins from\n   * @param amount The amount of coins to burn\n   */\n  function burn(address from, uint256 amount) external;\n}\n"
    },
    "contracts/src/interfaces/token/routes/IGameTokenPooler.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * This file is derived from the Ultrachess project under the Apache 2.0 license.\n * Copyright (C) 2022-2023 Ultrachess team\n *\n * SPDX-License-Identifier: GPL-3.0-or-later AND Apache-2.0\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\n/**\n * @dev Token router send to liquidity to the Uniswap V3 pool in exchange for\n * an LP-NFT\n */\ninterface IGameTokenPooler {\n  //////////////////////////////////////////////////////////////////////////////\n  // Events\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Emitted when an LP-NFT is minted\n   *\n   * @param sender The sender of the assets being paid\n   * @param recipient The address of the recipient of the LP-NFT\n   * @param gameTokenAddress The address of the game token\n   * @param assetTokenAddress The address of the asset token\n   * @param nftAddress The address of the NFT manager contract\n   * @param lpNftTokenId The ID of the LP-NFT\n   * @param gameTokenShare The amount of the game token in the NFT\n   * @param assetTokenShare The amount of the asset token in the NFT\n   * @param liquidityAmount The amount of liquidity created\n   */\n  event LpNftMinted(\n    address indexed sender,\n    address indexed recipient,\n    address indexed gameTokenAddress,\n    address assetTokenAddress,\n    address nftAddress,\n    uint256 lpNftTokenId,\n    uint256 gameTokenShare,\n    uint256 assetTokenShare,\n    uint128 liquidityAmount\n  );\n\n  /**\n   * @dev Emitted when liquidity and fees are collected from an LP-NFT.\n   *\n   * @param sender The sender of the collection request\n   * @param recipient The address of the recipient of the LP-NFT fees\n   * @param gameTokenAddress The address of the game token\n   * @param assetTokenAddress The address of the asset token\n   * @param nftAddress The address of the NFT manager contract\n   * @param lpNftTokenId The ID of the NFT\n   * @param liquidityAmount The amount of liquidity in the NFT before collection\n   * @param gameTokenCollected The amount of game token fees collected\n   * @param assetTokenCollected The amount of asset token fees collected\n   * @param assetTokenReturned The amount of the asset token returned to the\n   *        recipient\n   */\n  event LpNftCollected(\n    address indexed sender,\n    address indexed recipient,\n    address indexed gameTokenAddress,\n    address assetTokenAddress,\n    address nftAddress,\n    uint256 lpNftTokenId,\n    uint128 liquidityAmount,\n    uint256 gameTokenCollected,\n    uint256 assetTokenCollected,\n    uint256 assetTokenReturned\n  );\n\n  //////////////////////////////////////////////////////////////////////////////\n  // External accessors\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Returns true if the game token is token0 in the pool\n   *\n   * @return True if the game token is token0, false otherwise\n   */\n  function gameIsToken0() external view returns (bool);\n\n  //////////////////////////////////////////////////////////////////////////////\n  // External interface for adding liquidity\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Mints an LP-NFT and deposits liquidity into the pool using the game\n   *      token\n   *\n   * A swap will occur to allow for single-sided supply.\n   *\n   * @param gameTokenAmount The amounts of the game token to deposit\n   * @param recipient The recipient of the LP-NFT\n   *\n   * @return lpNftTokenId The ID of the minted NFT\n   */\n  function mintLpNftWithGameToken(\n    uint256 gameTokenAmount,\n    address recipient\n  ) external returns (uint256 lpNftTokenId);\n\n  /**\n   * @dev Mints an LP-NFT and deposits liquidity into the pool using the asset\n   * token\n   *\n   * A swap will occur to allow for single-sided supply.\n   *\n   * @param assetTokenAmount The amount of the the asset token to use\n   * @param recipient The recipient of the LP-NFT\n   *\n   * @return lpNftTokenId The ID of the minted NFT\n   */\n  function mintLpNftWithAssetToken(\n    uint256 assetTokenAmount,\n    address recipient\n  ) external returns (uint256 lpNftTokenId);\n\n  /**\n   * @dev Mints a Uniswap V3 LP-NFT and deposits liquidity into the pool\n   * without performing a token swap\n   *\n   * @param gameTokenAmount The amount of the game token to deposit\n   * @param assetTokenAmount The amounts of the asset token to deposit\n   * @param recipient The recient of the LP-NFT\n   *\n   * @return lpNftTokenId The ID of the minted NFT\n   */\n  function mintLpNftImbalance(\n    uint256 gameTokenAmount,\n    uint256 assetTokenAmount,\n    address recipient\n  ) external returns (uint256 lpNftTokenId);\n\n  //////////////////////////////////////////////////////////////////////////////\n  // External interface for removing liquidity\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Collects the tokens and fees from an LP-NFT and returns the asset\n   * token and empty LP-NFT to the recipient\n   *\n   * @param lpNftTokenId The ID of the LP-NFT\n   * @param recipient The recipient of the fees and the LP-NFT\n   *\n   * @return assetTokenReturned The amount of the asset token returned to the\n   * recipient\n   */\n  function collectFromLpNft(\n    uint256 lpNftTokenId,\n    address recipient\n  ) external returns (uint256 assetTokenReturned);\n\n  /**\n   * @dev Liquidates everything to the asset token in one transaction and\n   * returns the empty LP-NFT\n   *\n   * @param lpNftTokenId The ID of the LP-NFT\n   *\n   * @return assetTokenReturned The amount of the asset token returned to the\n   * sender\n   */\n  function exit(\n    uint256 lpNftTokenId\n  ) external returns (uint256 assetTokenReturned);\n}\n"
    },
    "contracts/src/interfaces/token/routes/IGameTokenSwapper.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * This file is derived from the Ultrachess project under the Apache 2.0 license.\n * Copyright (C) 2022-2023 Ultrachess team\n *\n * SPDX-License-Identifier: GPL-3.0-or-later AND Apache-2.0\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\n/**\n * @dev Token router to swap between the game token and its asset token\n */\ninterface IGameTokenSwapper {\n  //////////////////////////////////////////////////////////////////////////////\n  // Events\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Emitted when POW1 is purchased with the asset token or POW5 is\n   * purchased with the stable token\n   *\n   * @param sender The sender of the asset token\n   * @param recipient The address of the recipient of the POW1\n   * @param gameTokenAddress The address of the POW1 or POW5 token contract\n   * @param assetTokenAddress The amount of the asset token being spent\n   * @param pow1Returned The amount of POW1 received\n   */\n  event GameTokenBought(\n    address indexed sender,\n    address indexed recipient,\n    address indexed gameTokenAddress,\n    address assetTokenAddress,\n    uint256 assetTokenAmount,\n    uint256 pow1Returned\n  );\n\n  /**\n   * @dev Emitted when POW1 is sold for the asset token or POW5 is sold for\n   * the stable token\n   *\n   * @param sender The sender of the game token\n   * @param recipient The address of the recipient of the asset token\n   * @param gameTokenAddress The address of the POW1 or POW5 token contract\n   * @param pow1Amount The amount of POW1 being spent\n   * @param assetTokenReturned The amount of the asset token received\n   */\n  event GameTokenSold(\n    address indexed sender,\n    address indexed recipient,\n    address indexed gameTokenAddress,\n    address assetTokenAddress,\n    uint256 pow1Amount,\n    uint256 assetTokenReturned\n  );\n\n  //////////////////////////////////////////////////////////////////////////////\n  // External accessors\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Returns true if the game token is token0 in the pool\n   *\n   * @return True if the game token is token0, false otherwise\n   */\n  function gameIsToken0() external view returns (bool);\n\n  //////////////////////////////////////////////////////////////////////////////\n  // External interface for swapping into the game token\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Swaps the asset token for the game token\n   *\n   * @param assetTokenAmount The ammount of the asset token to include in the\n   *        swap\n   * @param recipient The receiver of the game token\n   *\n   * @return gameTokenReturned The amount of the game token returned to the\n   * recipient\n   */\n  function buyGameToken(\n    uint256 assetTokenAmount,\n    address recipient\n  ) external returns (uint256 gameTokenReturned);\n\n  //////////////////////////////////////////////////////////////////////////////\n  // External interface for swapping out of the game token\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Swaps the game token for the asset token\n   *\n   * @param gameTokenAmount The amount of the game token to swap\n   * @param recipient The recient of the asset token\n   *\n   * @return assetTokenReturned The amount of asset token sent to the\n   *                            recipient\n   */\n  function sellGameToken(\n    uint256 gameTokenAmount,\n    address recipient\n  ) external returns (uint256 assetTokenReturned);\n\n  /**\n   * @dev Liquidate everything to the asset token in one function call\n   *\n   * @return assetTokenReturned The amount of asset token returned\n   */\n  function exit() external returns (uint256 assetTokenReturned);\n}\n"
    },
    "contracts/src/interfaces/token/routes/IMarketStableSwapper.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * This file is derived from the Ultrachess project under the Apache 2.0 license.\n * Copyright (C) 2022-2023 Ultrachess team\n *\n * SPDX-License-Identifier: GPL-3.0-or-later AND Apache-2.0\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\n/**\n * @dev Token router to swap between the market token and the stable token\n */\ninterface IMarketStableSwapper {\n  //////////////////////////////////////////////////////////////////////////////\n  // Events\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Emitted when the market token is purchased for the stable token\n   *\n   * @param sender The sender of the stable token\n   * @param recipient The address of the recipient of the market token\n   * @param marketTokenAddress The address of the market token contract\n   * @param stableTokenAddress The amount of the stable token being spent\n   * @param stableTokenAmount The amount of the stable token being spent\n   * @param marketTokenReturned The amount of the market token received\n   */\n  event MarketTokenBought(\n    address indexed sender,\n    address indexed recipient,\n    address indexed marketTokenAddress,\n    address stableTokenAddress,\n    uint256 stableTokenAmount,\n    uint256 marketTokenReturned\n  );\n\n  /**\n   * @dev Emitted when the market token is sold for the stable token\n   *\n   * @param sender The sender of the market token\n   * @param recipient The address of the recipient of the stable token\n   * @param marketTokenAddress The address of the market token contract\n   * @param marketTokenAmount The amount of the market token being spent\n   * @param marketTokenAmount The amount of the market token spent\n   * @param stableTokenReturned The amount of the stable token received\n   */\n  event MarketTokenSold(\n    address indexed sender,\n    address indexed recipient,\n    address indexed marketTokenAddress,\n    address stableTokenAddress,\n    uint256 marketTokenAmount,\n    uint256 stableTokenReturned\n  );\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Public accessors\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IMarketStableSwapper-marketIsToken0}\n   */\n  function marketIsToken0() external view returns (bool);\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Public interface for swapping into the market token\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Swaps the stable token for the market token\n   *\n   * @param stableTokenAmount The ammount of the stable token to include in\n   *        the swap\n   * @param recipient The receiver of the market token\n   *\n   * @return marketTokenReturned The amount of the market token returned to the\n   * recipient\n   */\n  function buyMarketToken(\n    uint256 stableTokenAmount,\n    address recipient\n  ) external returns (uint256 marketTokenReturned);\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Public interface for swapping out of the market token\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Swaps the market token for the stable token\n   *\n   * @param marketTokenAmount The amount of the market token to swap\n   * @param recipient The recient of the stable token\n   *\n   * @return stableTokenReturned The amount of stable token returned to the\n   * recipient\n   */\n  function sellMarketToken(\n    uint256 marketTokenAmount,\n    address recipient\n  ) external returns (uint256 stableTokenReturned);\n\n  /**\n   * @dev Liquidate everything to the stable token in one function call\n   *\n   * @return marketTokenAmount The amount of market token spent\n   * @return stableTokenReturned The amount of stable token returned to the\n   * recipient\n   */\n  function exit()\n    external\n    returns (uint256 marketTokenAmount, uint256 stableTokenReturned);\n}\n"
    },
    "contracts/src/token/ERC1155/extensions/ERC1155Enumerable.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * This file is derived from the Ultrachess project under the Apache 2.0 license.\n * Copyright (C) 2022-2023 Ultrachess team\n *\n * This file is derived from the OpenZeppelin project under the MIT license.\n * Copyright (c) 2016-2024 Zeppelin Group Ltd and contributors\n *\n * SPDX-License-Identifier: GPL-3.0-or-later AND Apache-2.0 AND MIT\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {Arrays} from \"@openzeppelin/contracts/utils/Arrays.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {ERC1155Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\";\n\nimport {IERC1155Enumerable} from \"../../../interfaces/token/ERC1155/extensions/IERC1155Enumerable.sol\";\n\nimport {ERC1155Helpers} from \"../utils/ERC1155Helpers.sol\";\n\nimport {ERC1155NonReentrant} from \"./ERC1155NonReentrant.sol\";\n\n/**\n * @title ERC-1155: Multi Token Standard, enumerable extension implementation\n */\nabstract contract ERC1155Enumerable is IERC1155Enumerable, ERC1155NonReentrant {\n  using Arrays for uint256[];\n  using EnumerableSet for EnumerableSet.UintSet;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // State\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Total number of tokens in existence\n   */\n  uint256 private _totalSupply;\n\n  /**\n   * @dev Mapping from token ID to owner\n   */\n  mapping(uint256 tokenId => address owner) private _tokenOwner;\n\n  /**\n   * @dev Mapping from owner to owned token IDs\n   */\n  mapping(address owner => EnumerableSet.UintSet tokenIds) private _ownedTokens;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IERC165} via {IERC1155Enumerable} and\n  // {ERC1155NonReentrant}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(\n    bytes4 interfaceId\n  ) public view virtual override(IERC165, ERC1155Upgradeable) returns (bool) {\n    return\n      interfaceId == type(IERC1155Enumerable).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {ERC1155Upgradeable} via {ERC1155NonReentrant}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {ERC1155Upgradeable-_update}\n   */\n  function _update(\n    address from,\n    address to,\n    uint256[] memory ids,\n    uint256[] memory values\n  ) internal virtual override nonReentrantERC1155Enumerable {\n    // Validate parameters\n    ERC1155Helpers.checkAmountArray(ids, values);\n\n    // Translate parameters\n    uint256 tokenCount = ids.length;\n\n    for (uint256 i = 0; i < tokenCount; i++) {\n      // Translate parameters\n      uint256 nftTokenId = ids.unsafeMemoryAccess(i);\n\n      // Handle minting\n      if (from == address(0)) {\n        // Validate state\n        require(_tokenOwner[nftTokenId] == address(0), \"Already minted\");\n\n        // Update state\n        _totalSupply += 1;\n        _tokenOwner[nftTokenId] = to;\n        require(_ownedTokens[to].add(nftTokenId), \"Already added\");\n      }\n\n      // Handle transfer\n      if (from != address(0) && to != address(0)) {\n        // Validate state\n        require(_tokenOwner[nftTokenId] == from, \"Invalid owner\");\n\n        // Update state\n        _tokenOwner[nftTokenId] = to;\n        require(_ownedTokens[from].remove(nftTokenId), \"Already removed\");\n        require(_ownedTokens[to].add(nftTokenId), \"Already added\");\n      }\n\n      // Handle burning\n      if (to == address(0)) {\n        // Validate state\n        require(_totalSupply > 0, \"No tokens\");\n        require(_tokenOwner[nftTokenId] == from, \"Invalid owner\");\n\n        // Update state\n        _totalSupply -= 1;\n        _tokenOwner[nftTokenId] = address(0);\n        require(_ownedTokens[from].remove(nftTokenId), \"Already removed\");\n      }\n    }\n\n    // Call ancestor\n    super._update(from, to, ids, values);\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IERC1155Enumerable}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IERC1155Enumerable-totalSupply}\n   */\n  function totalSupply() public view override returns (uint256) {\n    return _totalSupply;\n  }\n\n  /**\n   * @dev See {IERC1155Enumerable-ownerOf}\n   */\n  function ownerOf(\n    uint256 tokenId\n  ) public view override returns (address owner) {\n    // Read state\n    owner = _tokenOwner[tokenId];\n\n    return owner;\n  }\n\n  /**\n   * @dev See {IERC1155Enumerable-getTokenIds}\n   */\n  function getTokenIds(\n    address account\n  ) public view override returns (uint256[] memory tokenIds) {\n    // Load state\n    EnumerableSet.UintSet storage ownedTokens = _ownedTokens[account];\n\n    // Read state\n    tokenIds = ownedTokens.values();\n\n    return tokenIds;\n  }\n}\n"
    },
    "contracts/src/token/ERC1155/extensions/ERC1155NonReentrant.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * This file is derived from the OpenZeppelin project under the MIT license.\n * Copyright (c) 2016-2024 Zeppelin Group Ltd and contributors\n *\n * SPDX-License-Identifier: GPL-3.0-or-later AND MIT\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {ERC1155Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\";\n\nimport {ERC1155EnumerableNonReentrant} from \"../../../utils/guards/ERC1155EnumerableNonReentrant.sol\";\nimport {LPNFTHolderNonReentrant} from \"../../../utils/guards/LPNFTHolderNonReentrant.sol\";\nimport {LPSFTIssuableNonReentrant} from \"../../../utils/guards/LPSFTIssuableNonReentrant.sol\";\nimport {LPSFTNonReentrant} from \"../../../utils/guards/LPSFTNonReentrant.sol\";\n\n/**\n * @title ERC-1155: Multi Token Standard, non-reentrant extension\n *\n * This abstract contract extends the OpenZeppelin ERC-1155 implementation by\n * incorporating multiple reentrancy guards to enhance security for contracts\n * that are derived using diamond inheritance.\n */\nabstract contract ERC1155NonReentrant is\n  ERC1155EnumerableNonReentrant,\n  LPNFTHolderNonReentrant,\n  LPSFTIssuableNonReentrant,\n  LPSFTNonReentrant,\n  ERC1155Upgradeable\n{}\n"
    },
    "contracts/src/token/ERC1155/extensions/LPNFTHolder.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport {Arrays} from \"@openzeppelin/contracts/utils/Arrays.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {ERC1155Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\";\n\nimport {IERC1155Enumerable} from \"../../../interfaces/token/ERC1155/extensions/IERC1155Enumerable.sol\";\nimport {ILPNFT} from \"../../../interfaces/token/ERC1155/ILPNFT.sol\";\nimport {ILPNFTHolder} from \"../../../interfaces/token/ERC1155/extensions/ILPNFTHolder.sol\";\nimport {ILPSFT} from \"../../../interfaces/token/ERC1155/ILPSFT.sol\";\n\nimport {ERC1155Helpers} from \"../utils/ERC1155Helpers.sol\";\n\nimport {ERC1155NonReentrant} from \"./ERC1155NonReentrant.sol\";\n\n/**\n * @title LP-NFT holder for SFT contract\n */\nabstract contract LPNFTHolder is ILPNFTHolder, ERC1155NonReentrant {\n  using Arrays for uint256[];\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Routes\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev The LP-NFT used for clones\n   */\n  ILPNFT public lpNftTemplate;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // State\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Mapping tokenId -> LP-NFT\n   */\n  mapping(uint256 tokenId => ILPNFT token) internal _tokenIdToToken;\n\n  /**\n   * @dev Mapping LP-NFT -> tokenId\n   */\n  mapping(ILPNFT token => uint256 tokenId) internal _tokenToTokenId;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Initialization\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Initializes the contract\n   *\n   * @param lpNftTemplate_ The LP-NFT contract used for clones\n   */\n  function __LPNFTHolder_init(\n    address lpNftTemplate_\n  ) internal onlyInitializing {\n    // Validate parameters\n    require(lpNftTemplate_ != address(0), \"Invalid LPNFT\");\n\n    // Initialize routes\n    lpNftTemplate = ILPNFT(lpNftTemplate_);\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IERC165} via {ERC1155NonReentrant} and {ILPNFTHolder}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IERC165-supportsInterface}\n   */\n  function supportsInterface(\n    bytes4 interfaceId\n  ) public view virtual override(IERC165, ERC1155Upgradeable) returns (bool) {\n    return\n      super.supportsInterface(interfaceId) ||\n      interfaceId == type(ILPNFTHolder).interfaceId;\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {ERC1155Upgradeable} via {ERC1155NonReentrant}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {ERC1155Upgradeable-_update}\n   */\n  // slither-disable-next-line reentrancy-events\n  function _update(\n    address from,\n    address to,\n    uint256[] memory ids,\n    uint256[] memory values\n  ) internal virtual override nonReentrantLPNFTHolder {\n    // Validate parameters\n    ERC1155Helpers.checkAmountArray(ids, values);\n\n    // Translate parameters\n    uint256 tokenCount = ids.length;\n\n    for (uint256 i = 0; i < tokenCount; i++) {\n      // Translate parameters\n      uint256 tokenId = ids.unsafeMemoryAccess(i);\n\n      // Handle minting\n      if (from == address(0)) {\n        // Read state\n        ILPNFT existingToken = _tokenIdToToken[tokenId];\n\n        // Validate state\n        if (address(existingToken) != address(0)) {\n          revert ILPSFT.LPSFTInvalidToken(tokenId);\n        }\n\n        // Deploy clone\n        ILPNFT token = ILPNFT(Clones.clone(address(lpNftTemplate)));\n\n        // Update state\n        _tokenIdToToken[tokenId] = token;\n        _tokenToTokenId[token] = tokenId;\n\n        // Initialize clone\n        // slither-disable-next-line reentrancy-benign,reentrancy-no-eth\n        token.initialize(tokenId);\n      }\n\n      // Handle burning\n      if (to == address(0)) {\n        // Read state\n        ILPNFT token = _tokenIdToToken[tokenId];\n\n        // Validate state\n        if (address(token) == address(0)) {\n          revert ILPSFT.LPSFTInvalidToken(tokenId);\n        }\n\n        // Update state\n        delete _tokenIdToToken[tokenId];\n        delete _tokenToTokenId[token];\n\n        // Deinitialize clone\n        token.deinitialize(from);\n      }\n    }\n\n    // Call ancestor\n    super._update(from, to, ids, values);\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {ILPNFTHolder}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {ILPNFTHolder-addressToTokenId}\n   */\n  function addressToTokenId(\n    address tokenAddress\n  ) public view override returns (uint256) {\n    // Validate parameters\n    if (tokenAddress == address(0)) {\n      revert ILPSFT.LPSFTInvalidAddress(tokenAddress);\n    }\n\n    return _tokenToTokenId[ILPNFT(tokenAddress)];\n  }\n\n  /**\n   * @dev See {ILPNFTHolder-addressesToTokenIds}\n   */\n  function addressesToTokenIds(\n    address[] memory tokenAddresses\n  ) public view override returns (uint256[] memory) {\n    // Translate parameters\n    uint256 tokenCount = tokenAddresses.length;\n\n    // Return value\n    uint256[] memory tokenIds = new uint256[](tokenCount);\n\n    // Validate parameters\n    for (uint256 i = 0; i < tokenCount; i++) {\n      address tokenAddress = tokenAddresses[i];\n\n      // Validate parameters\n      if (tokenAddress == address(0)) {\n        revert ILPSFT.LPSFTInvalidAddress(tokenAddress);\n      }\n\n      tokenIds[i] = _tokenToTokenId[ILPNFT(tokenAddress)];\n    }\n\n    return tokenIds;\n  }\n\n  /**\n   * @dev See {ILPNFTHolder-tokenIdToAddress}\n   */\n  function tokenIdToAddress(\n    uint256 tokenId\n  ) public view override returns (address) {\n    if (tokenId == 0) {\n      revert ILPNFT.LPNFTInvalidTokenID();\n    }\n\n    return address(_tokenIdToToken[tokenId]);\n  }\n\n  /**\n   * @dev See {ILPNFTHolder-tokenIdsToAddresses}\n   */\n  function tokenIdsToAddresses(\n    uint256[] memory tokenIds\n  ) public view override returns (address[] memory) {\n    // Translate parameters\n    uint256 tokenCount = tokenIds.length;\n\n    // Return value\n    address[] memory tokenAddresses = new address[](tokenCount);\n\n    // Validate parameters\n    for (uint256 i = 0; i < tokenCount; i++) {\n      uint256 tokenId = tokenIds[i];\n\n      // Validate parameters\n      if (tokenId == 0) {\n        revert ILPNFT.LPNFTInvalidTokenID();\n      }\n\n      tokenAddresses[i] = address(_tokenIdToToken[tokenId]);\n    }\n\n    return tokenAddresses;\n  }\n}\n"
    },
    "contracts/src/token/ERC1155/extensions/LPSFTIssuable.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * This file is derived from the Ultrachess project under the Apache 2.0 license.\n * Copyright (C) 2022-2023 Ultrachess team\n *\n * SPDX-License-Identifier: GPL-3.0-or-later AND Apache-2.0\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {IERC1155Errors} from \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {ERC1155Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\";\n\nimport {ILPSFTIssuable} from \"../../../interfaces/token/ERC1155/extensions/ILPSFTIssuable.sol\";\nimport {ILPSFT} from \"../../../interfaces/token/ERC1155/ILPSFT.sol\";\n\nimport {ERC1155Helpers} from \"../utils/ERC1155Helpers.sol\";\n\nimport {ERC1155NonReentrant} from \"./ERC1155NonReentrant.sol\";\n\n/**\n * @title LP-SFT issuable extension for LP-SFT minting and burning\n */\nabstract contract LPSFTIssuable is\n  ILPSFTIssuable,\n  AccessControlUpgradeable,\n  ERC1155NonReentrant\n{\n  //////////////////////////////////////////////////////////////////////////////\n  // Roles\n  //////////////////////////////////////////////////////////////////////////////\n\n  // Only LPSFT_ISSUER_ROLE can mint and destroy tokens\n  bytes32 public constant LPSFT_ISSUER_ROLE = \"LPSFT_ISSUER_ROLE\";\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IERC165} via {AccessControl}, {ERC1155NonReentrant} and\n  // {ILPSFTIssuable}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IERC165-supportsInterface}\n   */\n  function supportsInterface(\n    bytes4 interfaceId\n  )\n    public\n    view\n    virtual\n    override(IERC165, AccessControlUpgradeable, ERC1155Upgradeable)\n    returns (bool)\n  {\n    return\n      super.supportsInterface(interfaceId) ||\n      interfaceId == type(ILPSFTIssuable).interfaceId;\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {ILPSFTIssuable}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {ILPSFTIssuable-mint}\n   */\n  function mint(\n    address to,\n    uint256 sftTokenId,\n    bytes memory data\n  ) external nonReentrantLPSFTIssuable {\n    // Validate access\n    _checkRole(LPSFT_ISSUER_ROLE);\n\n    // Validate parameters\n    if (to == address(0)) {\n      revert IERC1155Errors.ERC1155InvalidReceiver(to);\n    }\n\n    // Call ancestor\n    _mint(to, sftTokenId, 1, data);\n  }\n\n  /**\n   * @dev See {ILPSFTIssuable-mintBatch}\n   */\n  function mintBatch(\n    address to,\n    uint256[] memory sftTokenIds,\n    bytes memory data\n  ) external nonReentrantLPSFTIssuable {\n    // Validate access\n    _checkRole(LPSFT_ISSUER_ROLE);\n\n    // Validate parameters\n    if (to == address(0)) {\n      revert IERC1155Errors.ERC1155InvalidReceiver(to);\n    }\n    if (sftTokenIds.length == 0) {\n      revert ILPSFT.LPSFTEmptyArray();\n    }\n\n    // Translate parameters\n    uint256[] memory tokenAmounts = ERC1155Helpers.getAmountArray(\n      sftTokenIds.length\n    );\n\n    // Call ancestor\n    _mintBatch(to, sftTokenIds, tokenAmounts, data);\n  }\n\n  /**\n   * @dev See {ILPSFTIssuable-burn}\n   */\n  function burn(\n    address from,\n    uint256 sftTokenId\n  ) external nonReentrantLPSFTIssuable {\n    // Validate access\n    _checkRole(LPSFT_ISSUER_ROLE);\n\n    // Validate parameters\n    if (from == address(0)) {\n      revert IERC1155Errors.ERC1155InvalidSender(address(0));\n    }\n\n    // Call ancestor\n    _burn(from, sftTokenId, 1);\n  }\n\n  /**\n   * @dev See {ILPSFTIssuable-burnBatch}\n   */\n  function burnBatch(\n    address from,\n    uint256[] memory sftTokenIds\n  ) external nonReentrantLPSFTIssuable {\n    // Validate access\n    _checkRole(LPSFT_ISSUER_ROLE);\n\n    // Validate parameters\n    if (from == address(0)) {\n      revert IERC1155Errors.ERC1155InvalidSender(address(0));\n    }\n    if (sftTokenIds.length == 0) {\n      revert ILPSFT.LPSFTEmptyArray();\n    }\n\n    // Translate parameters\n    uint256[] memory tokenAmounts = ERC1155Helpers.getAmountArray(\n      sftTokenIds.length\n    );\n\n    // Call ancestor\n    _burnBatch(from, sftTokenIds, tokenAmounts);\n  }\n}\n"
    },
    "contracts/src/token/ERC1155/LPNFT.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nimport {INonfungiblePositionManager} from \"../../../interfaces/uniswap-v3-periphery/INonfungiblePositionManager.sol\";\n\nimport {ILPNFT} from \"../../interfaces/token/ERC1155/ILPNFT.sol\";\n\n/**\n * @title LP-NFT: Liquidity Pool Non-Fungible Token\n */\ncontract LPNFT is ILPNFT, Initializable, AccessControl {\n  using SafeERC20 for IERC20;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Routes\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev The POW1 token contract\n   */\n  IERC20 public immutable pow1Token;\n\n  /**\n   * @dev The POW5 token contract\n   */\n  IERC20 public immutable pow5Token;\n\n  /**\n   * @dev The LPPOW1 token contract\n   */\n  IERC20 public immutable lpPow1Token;\n\n  /**\n   * @dev The LPPOW5 token contract\n   */\n  IERC20 public immutable lpPow5Token;\n\n  /**\n   * @dev The NOPOW5 token contract\n   */\n  IERC20 public immutable noPow5Token;\n\n  /**\n   * @dev The Uniswap V3 NFT manager\n   */\n  INonfungiblePositionManager public immutable uniswapV3NftManager;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // State\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev The LP-NFT's token ID\n   */\n  uint256 private _tokenId = 0;\n\n  /**\n   * @dev Enum for which pool the LP-NFT belongs to, either LPPOW1 or LPPOW5\n   */\n  Pool private _pool = Pool.INVALID;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Initialization\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Initializes the LP-NFT template\n   *\n   * @param pow1Token_ The POW1 token\n   * @param pow5Token_ The POW5 token\n   * @param lpPow1Token_ The LPPOW1 token\n   * @param lpPow5Token_ The LPPOW5 token\n   * @param noPow5Token_ The NOPOW5 token\n   * @param uniswapV3NftManager_ The Uniswap V3 NFT manager\n   */\n  constructor(\n    address pow1Token_,\n    address pow5Token_,\n    address lpPow1Token_,\n    address lpPow5Token_,\n    address noPow5Token_,\n    address uniswapV3NftManager_\n  ) {\n    // Validate parameters\n    require(pow1Token_ != address(0), \"Invalid POW1\");\n    require(pow5Token_ != address(0), \"Invalid POW5\");\n    require(lpPow1Token_ != address(0), \"Invalid LPPOW1\");\n    require(lpPow5Token_ != address(0), \"Invalid LPPOW5\");\n    require(noPow5Token_ != address(0), \"Invalid NOPOW5\");\n    require(uniswapV3NftManager_ != address(0), \"Invalid NFT mgr\");\n\n    // Initialize {Initializable}\n    _disableInitializers();\n\n    // Initialize routes\n    pow1Token = IERC20(pow1Token_);\n    pow5Token = IERC20(pow5Token_);\n    lpPow1Token = IERC20(lpPow1Token_);\n    lpPow5Token = IERC20(lpPow5Token_);\n    noPow5Token = IERC20(noPow5Token_);\n    uniswapV3NftManager = INonfungiblePositionManager(uniswapV3NftManager_);\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IERC165} via {AccessControl} and {ILPNFT}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IERC165-supportsInterface}\n   */\n  function supportsInterface(\n    bytes4 interfaceId\n  ) public view virtual override(AccessControl, IERC165) returns (bool) {\n    return\n      AccessControl.supportsInterface(interfaceId) ||\n      interfaceId == type(ILPNFT).interfaceId;\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {ILPNFT}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {ILPNFT-initialize}\n   */\n  function initialize(uint256 lpNftTokenId) public override initializer {\n    // Validate parameters\n    if (lpNftTokenId == 0) {\n      revert LPNFTInvalidTokenID();\n    }\n\n    // Initialize {AccessControl}\n    _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n    // Update state\n    _tokenId = lpNftTokenId;\n\n    // Determine the pool\n    address token0;\n    address token1;\n    // slither-disable-next-line unused-return\n    (, , token0, token1, , , , , , , , ) = uniswapV3NftManager.positions(\n      lpNftTokenId\n    );\n\n    // Update state\n    if (token0 == address(pow1Token) || token1 == address(pow1Token)) {\n      _pool = Pool.LPPOW1;\n    } else if (token0 == address(pow5Token) || token1 == address(pow5Token)) {\n      _pool = Pool.LPPOW5;\n    } else {\n      revert LPNFTInvalidPool(lpNftTokenId);\n    }\n  }\n\n  /**\n   * @dev See {ILPNFT-deinitialize}\n   */\n  function deinitialize(address beneficiary) public override {\n    // Validate access\n    _checkRole(DEFAULT_ADMIN_ROLE);\n\n    // Validate parameters\n    require(beneficiary != address(0), \"Invalid beneficiary\");\n\n    // Validate state\n    if (_tokenId == 0) {\n      revert LPNFTInvalidTokenID();\n    }\n    if (_pool == Pool.INVALID) {\n      revert LPNFTInvalidPool(_tokenId);\n    }\n\n    // Update state\n    _tokenId = 0;\n    _pool = Pool.INVALID;\n\n    // Recover ETH\n    uint256 ethBalance = address(this).balance;\n    if (ethBalance > 0) {\n      // slither-disable-next-line arbitrary-send-eth\n      payable(beneficiary).transfer(ethBalance);\n    }\n\n    // Recover POW1\n    uint256 recoveredPow1Balance = pow1Token.balanceOf(address(this));\n    if (recoveredPow1Balance > 0) {\n      pow1Token.safeTransfer(beneficiary, recoveredPow1Balance);\n    }\n\n    // Recover POW5\n    uint256 recoveredPow5Balance = pow5Token.balanceOf(address(this));\n    if (recoveredPow5Balance > 0) {\n      pow5Token.safeTransfer(beneficiary, recoveredPow5Balance);\n    }\n\n    // Deinitialize {AccessControl}\n    _revokeRole(DEFAULT_ADMIN_ROLE, _msgSender());\n  }\n\n  /**\n   * @dev See {ILPNFT-tokenId}\n   */\n  function tokenId() public view override returns (uint256) {\n    // Read state\n    return _tokenId;\n  }\n\n  /**\n   * @dev See {ILPNFT-uri}\n   */\n  function uri() public view override returns (string memory) {\n    // Validate state\n    if (_tokenId == 0) {\n      revert LPNFTInvalidTokenID();\n    }\n\n    // Read external state\n    return uniswapV3NftManager.tokenURI(_tokenId);\n  }\n\n  /**\n   * @dev See {ILPNFT-pool}\n   */\n  function pool() public view override returns (Pool) {\n    // Read state\n    return _pool;\n  }\n\n  /**\n   * @dev See {ILPNFT-pow1Balance}\n   */\n  function pow1Balance() public view override returns (uint256) {\n    // Read external state\n    return pow1Token.balanceOf(address(this));\n  }\n\n  /**\n   * @dev See {ILPNFT-pow5Balance}\n   */\n  function pow5Balance() public view override returns (uint256) {\n    // Read external state\n    return pow5Token.balanceOf(address(this));\n  }\n\n  /**\n   * @dev See {ILPNFT-lpPow1Balance}\n   */\n  function lpPow1Balance() public view override returns (uint256) {\n    // Read external state\n    return lpPow1Token.balanceOf(address(this));\n  }\n\n  /**\n   * @dev See {ILPNFT-lpPow5Balance}\n   */\n  function lpPow5Balance() public view override returns (uint256) {\n    // Read external state\n    return lpPow5Token.balanceOf(address(this));\n  }\n\n  /**\n   * @dev See {ILPNFT-noPow5Balance}\n   */\n  function noPow5Balance() public view override returns (uint256) {\n    // Read external state\n    return noPow5Token.balanceOf(address(this));\n  }\n}\n"
    },
    "contracts/src/token/ERC1155/LPSFT.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * This file is derived from the Ultrachess project under the Apache 2.0 license.\n * Copyright (C) 2022-2023 Ultrachess team\n *\n * SPDX-License-Identifier: GPL-3.0-or-later AND Apache-2.0\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Arrays} from \"@openzeppelin/contracts/utils/Arrays.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {ERC1155Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\";\n\nimport {INonfungiblePositionManager} from \"../../../interfaces/uniswap-v3-periphery/INonfungiblePositionManager.sol\";\n\nimport {ILPNFT} from \"../../interfaces/token/ERC1155/ILPNFT.sol\";\nimport {ILPSFT} from \"../../interfaces/token/ERC1155/ILPSFT.sol\";\nimport {IERC20Issuable} from \"../../interfaces/token/ERC20/extensions/IERC20Issuable.sol\";\n\nimport {ERC1155Enumerable} from \"./extensions/ERC1155Enumerable.sol\";\nimport {LPNFTHolder} from \"./extensions/LPNFTHolder.sol\";\nimport {LPSFTIssuable} from \"./extensions/LPSFTIssuable.sol\";\n\n/**\n * @title ERC-1155: Multi Token Standard implementation\n *\n * @dev See https://eips.ethereum.org/EIPS/eip-1155\n */\ncontract LPSFT is ILPSFT, ERC1155Enumerable, LPNFTHolder, LPSFTIssuable {\n  using Arrays for uint256[];\n  using SafeERC20 for IERC20;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Routes\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev The POW1 token\n   */\n  IERC20 public pow1Token;\n\n  /**\n   * @dev The POW5 token\n   */\n  IERC20 public pow5Token;\n\n  /**\n   * @dev The LP POW1 token\n   */\n  IERC20Issuable public lpPow1Token;\n\n  /**\n   * @dev The LP POW5 token\n   */\n  IERC20Issuable public lpPow5Token;\n\n  /**\n   * @dev The Uniswap V3 NFT manager\n   */\n  INonfungiblePositionManager public uniswapV3NftManager;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Initialization\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Constructor\n   */\n  constructor(\n    address owner_,\n    address lpNftTemplate_,\n    address pow1Token_,\n    address pow5Token_,\n    address lpPow1Token_,\n    address lpPow5Token_,\n    address uniswapV3NftManager_\n  ) {\n    initialize(\n      owner_,\n      lpNftTemplate_,\n      pow1Token_,\n      pow5Token_,\n      lpPow1Token_,\n      lpPow5Token_,\n      uniswapV3NftManager_\n    );\n  }\n\n  /**\n   * @dev Initializes the ERC-1155 contract\n   *\n   * @param owner_ The owner of the ERC-1155 contract\n   * @param lpNftTemplate_ The LP-NFT contract used for clones\n   * @param pow1Token_ The POW1 token\n   * @param pow5Token_ The POW5 token\n   * @param lpPow1Token_ The LPPOW1 token\n   * @param lpPow5Token_ The LPPOW5 token\n   * @param uniswapV3NftManager_ The Uniswap V3 NFT manager\n   */\n  function initialize(\n    address owner_,\n    address lpNftTemplate_,\n    address pow1Token_,\n    address pow5Token_,\n    address lpPow1Token_,\n    address lpPow5Token_,\n    address uniswapV3NftManager_\n  ) public initializer {\n    // Validate parameters\n    require(owner_ != address(0), \"Invalid owner\");\n    require(lpNftTemplate_ != address(0), \"Invalid LPNFT\");\n    require(pow1Token_ != address(0), \"Invalid POW1\");\n    require(pow5Token_ != address(0), \"Invalid POW5\");\n    require(lpPow1Token_ != address(0), \"Invalid LPPOW1\");\n    require(lpPow5Token_ != address(0), \"Invalid LPPOW5\");\n    require(\n      uniswapV3NftManager_ != address(0),\n      \"Invalid Uniswap V3 NFT manager\"\n    );\n\n    // Initialize ancestors\n    __AccessControl_init();\n    __ERC1155_init(\"\");\n    __LPNFTHolder_init(lpNftTemplate_);\n\n    // Initialize {AccessControl} via {LPSFTIssuable}\n    _grantRole(DEFAULT_ADMIN_ROLE, owner_);\n\n    // Initialize routes\n    pow1Token = IERC20(pow1Token_);\n    pow5Token = IERC20(pow5Token_);\n    lpPow1Token = IERC20Issuable(lpPow1Token_);\n    lpPow5Token = IERC20Issuable(lpPow5Token_);\n    uniswapV3NftManager = INonfungiblePositionManager(uniswapV3NftManager_);\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IERC165} via {ILPSFT}, {ERC1155Enumerable},\n  // {LPSFTIssuable} and {LPNFTHolder}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IERC165-supportsInterface}\n   */\n  function supportsInterface(\n    bytes4 interfaceId\n  )\n    public\n    view\n    virtual\n    override(IERC165, ERC1155Enumerable, LPSFTIssuable, LPNFTHolder)\n    returns (bool)\n  {\n    return\n      super.supportsInterface(interfaceId) ||\n      interfaceId == type(ILPSFT).interfaceId;\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IERC1155MetadataURI} via {ERC1155Enumerable},\n  // {LSFTIssuable} and {LPNFTHolder}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IERC1155MetadataURI-uri}\n   */\n  function uri(\n    uint256 id\n  ) public view virtual override returns (string memory) {\n    // Validate parameters\n    if (id == 0) {\n      revert ILPNFT.LPNFTInvalidTokenID();\n    }\n\n    // Read state\n    ILPNFT token = _tokenIdToToken[id];\n\n    // Validate state\n    if (address(token) == address(0)) {\n      revert LPSFTInvalidToken(id);\n    }\n\n    // Read external state\n    return token.uri();\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {ERC1155Upgradeable} via {ERC1155Enumerable},\n  // {LSFTIssuable} and {LPNFTHolder}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {ERC1155-_update}\n   */\n  function _update(\n    address from,\n    address to,\n    uint256[] memory ids,\n    uint256[] memory values\n  )\n    internal\n    virtual\n    override(ERC1155Upgradeable, ERC1155Enumerable, LPNFTHolder)\n    nonReentrantLPSFT\n  {\n    // Translate parameters\n    uint256 tokenCount = ids.length;\n\n    // Check if burning\n    if (to == address(0)) {\n      // Handle burning\n      for (uint256 i = 0; i < tokenCount; i++) {\n        // Translate parameter\n        uint256 tokenId = ids.unsafeMemoryAccess(i);\n\n        // Read state\n        address tokenAddress = tokenIdToAddress(tokenId);\n\n        // Validate state\n        if (tokenAddress == address(0)) {\n          revert LPSFTInvalidToken(tokenId);\n        }\n\n        // Read all pool balances\n        uint256 lpPow1Balance_ = lpPow1Token.balanceOf(tokenAddress);\n        uint256 lpPow5Balance_ = lpPow5Token.balanceOf(tokenAddress);\n\n        // Burn all pool balances\n        if (lpPow1Balance_ > 0) {\n          // slither-disable-next-line reentrancy-no-eth\n          lpPow1Token.burn(tokenAddress, lpPow1Balance_);\n        }\n        if (lpPow5Balance_ > 0) {\n          // slither-disable-next-line reentrancy-no-eth\n          lpPow5Token.burn(tokenAddress, lpPow5Balance_);\n        }\n      }\n    }\n\n    // Call ancestors\n    // slither-disable-next-line reentrancy-events\n    super._update(from, to, ids, values);\n\n    // Check if minting\n    if (from == address(0)) {\n      // Handle minting\n      for (uint256 i = 0; i < tokenCount; i++) {\n        // Translate parameter\n        uint256 tokenId = ids.unsafeMemoryAccess(i);\n\n        // Read state\n        address tokenAddress = tokenIdToAddress(tokenId);\n\n        // Validate state\n        if (tokenAddress == address(0)) {\n          revert LPSFTInvalidToken(tokenId);\n        }\n\n        // Read state\n        address token0;\n        address token1;\n        uint128 liquidityAmount;\n        // slither-disable-next-line unused-return\n        (\n          ,\n          ,\n          token0,\n          token1,\n          ,\n          ,\n          ,\n          liquidityAmount,\n          ,\n          ,\n          ,\n\n        ) = uniswapV3NftManager.positions(tokenId);\n\n        // Increase LP token balance\n        if (token0 == address(pow1Token) || token1 == address(pow1Token)) {\n          lpPow1Token.mint(tokenAddress, uint256(liquidityAmount));\n        } else if (\n          token0 == address(pow5Token) || token1 == address(pow5Token)\n        ) {\n          lpPow5Token.mint(tokenAddress, uint256(liquidityAmount));\n        }\n      }\n    }\n\n    // If any tokens were returned to the contract after burning the LP-SFT,\n    // transfer them to the sender\n    if (to == address(0)) {\n      uint256 pow1Balance = pow1Token.balanceOf(address(this));\n      uint256 pow5Balance = pow5Token.balanceOf(address(this));\n\n      if (pow1Balance > 0) {\n        pow1Token.safeTransfer(from, pow1Balance);\n      }\n      if (pow5Balance > 0) {\n        pow5Token.safeTransfer(from, pow5Balance);\n      }\n    }\n  }\n}\n"
    },
    "contracts/src/token/ERC1155/NOLPSFT.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * This file is derived from the Ultrachess project under the Apache 2.0 license.\n * Copyright (C) 2022-2023 Ultrachess team\n *\n * SPDX-License-Identifier: GPL-3.0-or-later AND Apache-2.0\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {IERC1155MetadataURI} from \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {ERC1155Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\";\n\nimport {INOLPSFT} from \"../../interfaces/token/ERC1155/INOLPSFT.sol\";\n\nimport {ERC1155Enumerable} from \"./extensions/ERC1155Enumerable.sol\";\nimport {LPSFTIssuable} from \"./extensions/LPSFTIssuable.sol\";\n\n/**\n * @title ERC-1155: Multi Token Standard implementation\n *\n * @dev See https://eips.ethereum.org/EIPS/eip-1155\n */\ncontract NOLPSFT is INOLPSFT, ERC1155Enumerable, LPSFTIssuable {\n  //////////////////////////////////////////////////////////////////////////////\n  // Routes\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev The LP-SFT contract\n   */\n  IERC1155MetadataURI public lpSft;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Initialization\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Constructor\n   */\n  constructor(address owner_, address lpSft_) {\n    initialize(owner_, lpSft_);\n  }\n\n  /**\n   * @dev Initializes the ERC-1155 contract\n   *\n   * @param owner_ The owner of the ERC-1155 contract\n   * @param lpSft_ The LP-SFT contract\n   */\n  function initialize(address owner_, address lpSft_) public initializer {\n    // Validate parameters\n    require(owner_ != address(0), \"Invalid owner\");\n    require(lpSft_ != address(0), \"Invalid LP-SFT\");\n\n    // Initialize {AccessControl} via {LPSFTIssuable}\n    _grantRole(DEFAULT_ADMIN_ROLE, owner_);\n\n    // Initialize routes\n    lpSft = IERC1155MetadataURI(lpSft_);\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IERC165} via {INOLPSFT}, {ERC1155Enumerable} and\n  // {LPSFTIssuable}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IERC165-supportsInterface}\n   */\n  function supportsInterface(\n    bytes4 interfaceId\n  )\n    public\n    view\n    virtual\n    override(IERC165, ERC1155Enumerable, LPSFTIssuable)\n    returns (bool)\n  {\n    return super.supportsInterface(interfaceId);\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IERC1155MetadataURI} via {ERC1155Enumerable} and\n  // {LSFTIssuable}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IERC1155MetadataURI-uri}\n   */\n  function uri(\n    uint256 id\n  ) public view virtual override returns (string memory) {\n    // Read state\n    return lpSft.uri(id);\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {ERC1155Upgradeable} via {ERC1155Enumerable} and\n  // {LPSFTIssuable}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {ERC1155-_update}\n   */\n  function _update(\n    address from,\n    address to,\n    uint256[] memory ids,\n    uint256[] memory values\n  ) internal virtual override(ERC1155Upgradeable, ERC1155Enumerable) {\n    // Call ancestors\n    super._update(from, to, ids, values);\n  }\n}\n"
    },
    "contracts/src/token/ERC1155/utils/ERC1155Helpers.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * This file is derived from the Ultrachess project under the Apache 2.0 license.\n * Copyright (C) 2022-2023 Ultrachess team\n *\n * SPDX-License-Identifier: GPL-3.0-or-later AND Apache-2.0\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {IERC1155Errors} from \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport {Arrays} from \"@openzeppelin/contracts/utils/Arrays.sol\";\n\nimport {IERC1155Enumerable} from \"../../../interfaces/token/ERC1155/extensions/IERC1155Enumerable.sol\";\n\n/**\n * @title ERC-1155 Utility Functions\n */\nlibrary ERC1155Helpers {\n  using Arrays for uint256[];\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Public utility functions\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Get an amount array suitable for NFTs (where the total supply of\n   * each token is 1)\n   *\n   * @param tokenCount Number of tokens\n   *\n   * @return array Array of length `tokenCount` with all values set to 1\n   */\n  function getAmountArray(\n    uint256 tokenCount\n  ) internal pure returns (uint256[] memory) {\n    uint256[] memory array = new uint256[](tokenCount);\n\n    for (uint256 i = 0; i < tokenCount; i++) {\n      array[i] = 1;\n    }\n\n    return array;\n  }\n\n  /**\n   * @dev Check that an amount array is suitable for NFTs (where the total\n   * supply of each token is 1)\n   *\n   * @param tokenIds Array of token IDs\n   * @param amounts Array of token amounts\n   */\n  function checkAmountArray(\n    uint256[] memory tokenIds,\n    uint256[] memory amounts\n  ) internal pure {\n    // Translate parameters\n    uint256 tokenCount = tokenIds.length;\n    uint256 amountCount = amounts.length;\n\n    // Validate parameters\n    if (tokenCount != amountCount) {\n      revert IERC1155Errors.ERC1155InvalidArrayLength(tokenCount, amountCount);\n    }\n\n    // Loop through tokens\n    for (uint256 i = 0; i < tokenCount; i++) {\n      // Translate parameters\n      uint256 amount = amounts.unsafeMemoryAccess(i);\n\n      // Validate parameters\n      if (amount != 1) {\n        revert IERC1155Enumerable.ERC1155EnumerableInvalidAmount(\n          tokenIds.unsafeMemoryAccess(i),\n          amount\n        );\n      }\n    }\n  }\n}\n"
    },
    "contracts/src/token/ERC20/extensions/ERC20Issuable.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * This file is derived from the Ultrachess project under the Apache 2.0 license.\n * Copyright (C) 2022-2023 Ultrachess team\n *\n * SPDX-License-Identifier: GPL-3.0-or-later AND Apache-2.0\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport {IERC20Issuable} from \"../../../interfaces/token/ERC20/extensions/IERC20Issuable.sol\";\n\n/**\n * @title ERC-20: Token Standard, optional issuable extension\n *\n * @dev See https://eips.ethereum.org/EIPS/eip-20\n */\nabstract contract ERC20Issuable is\n  IERC20Issuable,\n  AccessControlUpgradeable,\n  ERC20Upgradeable\n{\n  //////////////////////////////////////////////////////////////////////////////\n  // Roles\n  //////////////////////////////////////////////////////////////////////////////\n\n  // Only ERC20_ISSUER_ROLE can mint and destroy tokens\n  bytes32 public constant ERC20_ISSUER_ROLE = \"ERC20_ISSUER_ROLE\";\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IERC165} via {AccessControl} and {IERC20Issuable}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IERC165-supportsInterface}\n   */\n  function supportsInterface(\n    bytes4 interfaceId\n  )\n    public\n    view\n    virtual\n    override(IERC165, AccessControlUpgradeable)\n    returns (bool)\n  {\n    return\n      super.supportsInterface(interfaceId) ||\n      interfaceId == type(IERC20).interfaceId ||\n      interfaceId == type(IERC20Metadata).interfaceId ||\n      interfaceId == type(IERC20Issuable).interfaceId;\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IERC20Issuable}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IERC20Issuable-mint}\n   */\n  function mint(address to, uint256 amount) external {\n    // Validate access\n    _checkRole(ERC20_ISSUER_ROLE);\n\n    // Call ancestor\n    _mint(to, amount);\n  }\n\n  /**\n   * @dev See {IERC20Issuable-burn}\n   */\n  function burn(address account, uint256 amount) external {\n    // Validate access\n    _checkRole(ERC20_ISSUER_ROLE);\n\n    // Call ancestor\n    _burn(account, amount);\n  }\n}\n"
    },
    "contracts/src/token/ERC20/extensions/ERC20Nontransferable.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\n/**\n * @title ERC-20: Token Standard, optional nontransferable extension\n *\n * @dev See https://eips.ethereum.org/EIPS/eip-20\n */\nabstract contract ERC20Nontransferable is ERC20Upgradeable {\n  //////////////////////////////////////////////////////////////////////////////\n  // Errors\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Emitted when a transfer is attempted\n   *\n   * @param from The sender\n   * @param to The recipient\n   * @param value The amount\n   */\n  error ERC20TransferAttempted(address from, address to, uint256 value);\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {ERC20Upgradeable}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {ERC20Upgradeable-_update}\n   */\n  function _update(\n    address from,\n    address to,\n    uint256 value\n  ) internal virtual override {\n    // Validate parameters\n    if (from != address(0) && to != address(0)) {\n      revert ERC20TransferAttempted(from, to, value);\n    }\n\n    // Call ancestor\n    super._update(from, to, value);\n  }\n}\n"
    },
    "contracts/src/token/ERC20/LPPOW1.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * This file is derived from the Ultrachess project under the Apache 2.0 license.\n * Copyright (C) 2022-2023 Ultrachess team\n *\n * SPDX-License-Identifier: GPL-3.0-or-later AND Apache-2.0\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport {ERC20Issuable} from \"./extensions/ERC20Issuable.sol\";\nimport {ERC20Nontransferable} from \"./extensions/ERC20Nontransferable.sol\";\n\n/**\n * @title ERC-20: Token Standard implementation\n *\n * @dev See https://eips.ethereum.org/EIPS/eip-20\n */\ncontract LPPOW1 is ERC20Issuable, ERC20Nontransferable {\n  //////////////////////////////////////////////////////////////////////////////\n  // Constants\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev The ERC 20 token name used by wallets to identify the token\n   */\n  string private constant TOKEN_NAME = \"LP Powell Pennies\";\n\n  /**\n   * @dev The ERC 20 token symbol used as an abbreviation of the token, such\n   * as BTC, ETH, AUG or SJCX.\n   */\n  string private constant TOKEN_SYMBOL = \"LPPOW1\";\n\n  /**\n   * @dev The number of decimal places to which the token is divisible\n   */\n  uint8 private constant DECIMALS = 16;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Initialization\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Constructor\n   */\n  constructor(address owner_) {\n    initialize(owner_);\n  }\n\n  /**\n   * @dev Initializes the ERC-20 token with a name and symbol\n   *\n   * @param owner_ The owner of the token\n   */\n  function initialize(address owner_) public initializer {\n    // Validate parameters\n    require(owner_ != address(0), \"Invalid owner\");\n\n    // Initialize ancestors\n    __AccessControl_init();\n    __ERC20_init(TOKEN_NAME, TOKEN_SYMBOL);\n\n    // Initialize {AccessControl} via {ERC20Issuable}\n    _grantRole(DEFAULT_ADMIN_ROLE, owner_);\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IERC20} via {ERC20Issuable} and {ERC20Nontransferable}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IERC20Metadata-decimals}\n   */\n  function decimals() public pure override returns (uint8) {\n    return DECIMALS;\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {ERC20Upgradeable} via {ERC20Issuable} and\n  // {ERC20Nontransferable}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {ERC20Upgradeable-_update}\n   */\n  function _update(\n    address from,\n    address to,\n    uint256 value\n  ) internal virtual override(ERC20Upgradeable, ERC20Nontransferable) {\n    // Call ancesor\n    super._update(from, to, value);\n  }\n}\n"
    },
    "contracts/src/token/ERC20/LPPOW5.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * This file is derived from the Ultrachess project under the Apache 2.0 license.\n * Copyright (C) 2022-2023 Ultrachess team\n *\n * SPDX-License-Identifier: GPL-3.0-or-later AND Apache-2.0\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport {ERC20Issuable} from \"./extensions/ERC20Issuable.sol\";\nimport {ERC20Nontransferable} from \"./extensions/ERC20Nontransferable.sol\";\n\n/**\n * @title ERC-20: Token Standard implementation\n *\n * @dev See https://eips.ethereum.org/EIPS/eip-20\n */\ncontract LPPOW5 is ERC20Issuable, ERC20Nontransferable {\n  //////////////////////////////////////////////////////////////////////////////\n  // Constants\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev The ERC 20 token name used by wallets to identify the token\n   */\n  string private constant TOKEN_NAME = \"LP Powell Nickels\";\n\n  /**\n   * @dev The ERC 20 token symbol used as an abbreviation of the token, such\n   * as BTC, ETH, AUG or SJCX.\n   */\n  string private constant TOKEN_SYMBOL = \"LPPOW5\";\n\n  /**\n   * @dev The number of decimal places to which the token is divisible\n   */\n  uint8 private constant DECIMALS = 9;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Initialization\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Constructor\n   */\n  constructor(address owner_) {\n    initialize(owner_);\n  }\n\n  /**\n   * @dev Initializes the ERC-20 token with a name and symbol\n   *\n   * @param owner_ The owner of the token\n   */\n  function initialize(address owner_) public initializer {\n    // Validate parameters\n    require(owner_ != address(0), \"Invalid owner\");\n\n    // Initialize ancestors\n    __AccessControl_init();\n    __ERC20_init(TOKEN_NAME, TOKEN_SYMBOL);\n\n    // Initialize {AccessControl} via {ERC20Issuable}\n    _grantRole(DEFAULT_ADMIN_ROLE, owner_);\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IERC20} via {ERC20Issuable} and {ERC20Nontransferable}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IERC20Metadata-decimals}\n   */\n  function decimals() public pure override returns (uint8) {\n    return DECIMALS;\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {ERC20Upgradeable} via {ERC20Issuable} and\n  // {ERC20Nontransferable}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {ERC20Upgradeable-_update}\n   */\n  function _update(\n    address from,\n    address to,\n    uint256 value\n  ) internal virtual override(ERC20Upgradeable, ERC20Nontransferable) {\n    // Call ancesor\n    super._update(from, to, value);\n  }\n}\n"
    },
    "contracts/src/token/ERC20/NOPOW5.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * This file is derived from the Ultrachess project under the Apache 2.0 license.\n * Copyright (C) 2022-2023 Ultrachess team\n *\n * SPDX-License-Identifier: GPL-3.0-or-later AND Apache-2.0\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport {ERC20Issuable} from \"./extensions/ERC20Issuable.sol\";\nimport {ERC20Nontransferable} from \"./extensions/ERC20Nontransferable.sol\";\n\n/**\n * @title ERC-20: Token Standard implementation\n *\n * @dev See https://eips.ethereum.org/EIPS/eip-20\n */\ncontract NOPOW5 is ERC20Issuable, ERC20Nontransferable {\n  //////////////////////////////////////////////////////////////////////////////\n  // Constants\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev The ERC 20 token name used by wallets to identify the token\n   */\n  string private constant TOKEN_NAME = \"Powell Nickels Debt\";\n\n  /**\n   * @dev The ERC 20 token symbol used as an abbreviation of the token, such\n   * as BTC, ETH, AUG or SJCX.\n   */\n  string private constant TOKEN_SYMBOL = \"NOPOW5\";\n\n  /**\n   * @dev The number of decimal places to which the token is divisible\n   */\n  uint8 public constant DECIMALS = 16;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Initialization\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Constructor\n   */\n  constructor(address owner_) {\n    initialize(owner_);\n  }\n\n  /**\n   * @dev Initializes the ERC-20 token with a name and symbol\n   *\n   * @param owner_ The owner of the token\n   */\n  function initialize(address owner_) public initializer {\n    // Validate parameters\n    require(owner_ != address(0), \"Invalid owner\");\n\n    // Initizize ancestors\n    __AccessControl_init();\n    __ERC20_init(TOKEN_NAME, TOKEN_SYMBOL);\n\n    // Initialize {AccessControl} via {ERC20Issuable}\n    _grantRole(DEFAULT_ADMIN_ROLE, owner_);\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IERC20Metadata} via {ERC20Issuable}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IERC20Metadata-decimals}\n   */\n  function decimals() public pure override returns (uint8) {\n    return DECIMALS;\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {ERC20Upgradeable} via {ERC20Issuable} and\n  // {ERC20Nontransferable}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {ERC20Upgradeable-_update}\n   */\n  function _update(\n    address from,\n    address to,\n    uint256 value\n  ) internal virtual override(ERC20Upgradeable, ERC20Nontransferable) {\n    // Call ancesor\n    super._update(from, to, value);\n  }\n}\n"
    },
    "contracts/src/token/ERC20/POW1.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * This file is derived from the Ultrachess project under the Apache 2.0 license.\n * Copyright (C) 2022-2023 Ultrachess team\n *\n * SPDX-License-Identifier: GPL-3.0-or-later AND Apache-2.0\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport {ERC20Issuable} from \"./extensions/ERC20Issuable.sol\";\n\n/**\n * @title ERC-20: Token Standard implementation\n *\n * @dev See https://eips.ethereum.org/EIPS/eip-20\n */\ncontract POW1 is ERC20Issuable {\n  //////////////////////////////////////////////////////////////////////////////\n  // Constants\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev The ERC 20 token name used by wallets to identify the token\n   */\n  string private constant TOKEN_NAME = \"Powell Pennies\";\n\n  /**\n   * @dev The ERC 20 token symbol used as an abbreviation of the token, such\n   * as BTC, ETH, AUG or SJCX.\n   */\n  string private constant TOKEN_SYMBOL = \"POW1\";\n\n  /**\n   * @dev The number of decimal places to which the token is divisible\n   */\n  uint8 private constant DECIMALS = 18;\n\n  /**\n   * @dev Initial supply of the token. 1 POW1 = $0.01\n   */\n  uint256 private constant INITIAL_SUPPLY = 10_000 * (10 ** uint256(DECIMALS)); // $100\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Initialization\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Constructor\n   */\n  constructor(address owner_) {\n    initialize(owner_);\n  }\n\n  /**\n   * @dev Initializes the ERC-20 token with a name and symbol\n   *\n   * @param owner_ The owner of the token\n   */\n  function initialize(address owner_) public initializer {\n    // Validate parameters\n    require(owner_ != address(0), \"Invalid owner\");\n\n    // Initialize ancestors\n    __AccessControl_init();\n    __ERC20_init(TOKEN_NAME, TOKEN_SYMBOL);\n\n    // Initialize {AccessControl} via {ERC20Issuable}\n    _grantRole(DEFAULT_ADMIN_ROLE, owner_);\n\n    // Mint the initial supply to the owner\n    _mint(owner_, INITIAL_SUPPLY);\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IERC20Metadata} via {ERC20Issuable}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IERC20Metadata-decimals}\n   */\n  function decimals() public pure override returns (uint8) {\n    return DECIMALS;\n  }\n}\n"
    },
    "contracts/src/token/ERC20/POW5.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * This file is derived from the Ultrachess project under the Apache 2.0 license.\n * Copyright (C) 2022-2023 Ultrachess team\n *\n * SPDX-License-Identifier: GPL-3.0-or-later AND Apache-2.0\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport {ERC20Issuable} from \"./extensions/ERC20Issuable.sol\";\n\n/**\n * @title ERC-20: Token Standard implementation\n *\n * @dev See https://eips.ethereum.org/EIPS/eip-20\n */\ncontract POW5 is ERC20Issuable {\n  //////////////////////////////////////////////////////////////////////////////\n  // Constants\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev The ERC 20 token name used by wallets to identify the token\n   */\n  string private constant TOKEN_NAME = \"Powell Nickels\";\n\n  /**\n   * @dev The ERC 20 token symbol used as an abbreviation of the token, such\n   * as BTC, ETH, AUG or SJCX.\n   */\n  string private constant TOKEN_SYMBOL = \"POW5\";\n\n  /**\n   * @dev The number of decimal places to which the token is divisible\n   */\n  uint8 public constant DECIMALS = 16;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Initialization\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Constructor\n   */\n  constructor(address owner_) {\n    initialize(owner_);\n  }\n\n  /**\n   * @dev Initializes the ERC-20 token with a name and symbol\n   *\n   * @param owner_ The owner of the token\n   */\n  function initialize(address owner_) public initializer {\n    // Validate parameters\n    require(owner_ != address(0), \"Invalid owner\");\n\n    // Initialize ancestors\n    __AccessControl_init();\n    __ERC20_init(TOKEN_NAME, TOKEN_SYMBOL);\n\n    // Initialize {AccessControl} via {ERC20Issuable}\n    _grantRole(DEFAULT_ADMIN_ROLE, owner_);\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IERC20Metadata} via {ERC20Issuable}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IERC20Metadata-decimals}\n   */\n  function decimals() public pure override returns (uint8) {\n    return DECIMALS;\n  }\n}\n"
    },
    "contracts/src/token/routes/MarketStableSwapper.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * This file is derived from the Ultrachess project under the Apache 2.0 license.\n * Copyright (C) 2022-2023 Ultrachess team\n *\n * SPDX-License-Identifier: GPL-3.0-or-later AND Apache-2.0\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport {IMarketStableSwapper} from \"../../interfaces/token/routes/IMarketStableSwapper.sol\";\n\nimport {UniV3Swapper} from \"./UniV3Swapper.sol\";\n\n/**\n * @dev Token router to swap between the market token and the stable token\n */\ncontract MarketStableSwapper is\n  Context,\n  ReentrancyGuard,\n  UniV3Swapper,\n  IMarketStableSwapper\n{\n  //////////////////////////////////////////////////////////////////////////////\n  // Initialization\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Initializes the contract\n   *\n   * @param marketToken_ The address of the POW1 token\n   * @param stableToken_ The address of the stable token\n   * @param marketStablePool_ The address of the pool contract for the token\n   *        pair\n   */\n  constructor(\n    address marketToken_,\n    address stableToken_,\n    address marketStablePool_\n  ) UniV3Swapper(marketToken_, stableToken_, marketStablePool_) {}\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IMarketStableSwapper}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IMarketStableSwapper-marketIsToken0}\n   */\n  function marketIsToken0() public view override returns (bool) {\n    return _numeratorIsToken0;\n  }\n\n  /**\n   * @dev See {IMarketStableSwapper-buyMarketToken}\n   */\n  function buyMarketToken(\n    uint256 stableTokenAmount,\n    address recipient\n  ) public override nonReentrant returns (uint256 marketTokenReturned) {\n    // Call ancestor\n    marketTokenReturned = _buyNumeratorToken(stableTokenAmount, recipient);\n\n    // Emit event\n    emit MarketTokenBought(\n      _msgSender(),\n      recipient,\n      address(_numeratorToken),\n      address(_denominatorToken),\n      stableTokenAmount,\n      marketTokenReturned\n    );\n\n    return marketTokenReturned;\n  }\n\n  /**\n   * @dev See {IMarketStableSwapper-sellMarketToken}\n   */\n  function sellMarketToken(\n    uint256 marketTokenAmount,\n    address recipient\n  ) public override nonReentrant returns (uint256 stableTokenReturned) {\n    // Call ancestor\n    stableTokenReturned = _sellNumeratorToken(marketTokenAmount, recipient);\n\n    // Emit event\n    emit MarketTokenSold(\n      _msgSender(),\n      address(_numeratorToken),\n      address(_denominatorToken),\n      recipient,\n      marketTokenAmount,\n      stableTokenReturned\n    );\n\n    return stableTokenReturned;\n  }\n\n  /**\n   * @dev See {IMarketStableSwapper-exit}\n   */\n  function exit()\n    public\n    override\n    nonReentrant\n    returns (uint256 marketTokenAmount, uint256 stableTokenReturned)\n  {\n    // Call ancestor\n    (marketTokenAmount, stableTokenReturned) = _exitSwapper();\n\n    // Emit event\n    emit MarketTokenSold(\n      _msgSender(),\n      _msgSender(),\n      address(_numeratorToken),\n      address(_denominatorToken),\n      marketTokenAmount,\n      stableTokenReturned\n    );\n\n    return (stableTokenReturned, marketTokenAmount);\n  }\n}\n"
    },
    "contracts/src/token/routes/POW1MarketPooler.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * This file is derived from the Ultrachess project under the Apache 2.0 license.\n * Copyright (C) 2022-2023 Ultrachess team\n *\n * SPDX-License-Identifier: GPL-3.0-or-later AND Apache-2.0\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport {IGameTokenPooler} from \"../../interfaces/token/routes/IGameTokenPooler.sol\";\n\nimport {UniV3Pooler} from \"./UniV3Pooler.sol\";\n\n/**\n * @dev Token router send to liquidity to the Uniswap V3 pool in exchange for\n *      an LP-NFT\n */\ncontract POW1MarketPooler is\n  Context,\n  ReentrancyGuard,\n  UniV3Pooler,\n  IGameTokenPooler\n{\n  //////////////////////////////////////////////////////////////////////////////\n  // Initialization\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Initializes the contract\n   *\n   * @param pow1Token_ The address of the POW1 token\n   * @param marketToken_ The address of the market token\n   * @param pow1MarketPool_ The address of the Uniswap V3 pool contract\n   * @param uniswapV3NftManager_ The address of the upstream Uniswap V3 NFT\n   *        manager\n   */\n  constructor(\n    address pow1Token_,\n    address marketToken_,\n    address pow1MarketPool_,\n    address uniswapV3NftManager_\n  )\n    UniV3Pooler(pow1Token_, marketToken_, pow1MarketPool_, uniswapV3NftManager_)\n  {}\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IGameTokenPooler}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IGameTokenPooler-gameIsToken0}\n   */\n  function gameIsToken0() public view override returns (bool) {\n    return _numeratorIsToken0;\n  }\n\n  /**\n   * @dev See {IGameTokenPooler-mintLpNftWithGameToken}\n   */\n  function mintLpNftWithGameToken(\n    uint256 gameTokenAmount,\n    address recipient\n  ) public override nonReentrant returns (uint256 lpNftTokenId) {\n    // Call ancestor\n    uint256 gameTokenShare;\n    uint256 assetTokenShare;\n    uint128 liquidityAmount;\n    (\n      lpNftTokenId,\n      gameTokenShare,\n      assetTokenShare,\n      liquidityAmount\n    ) = _mintLpNftWithNumeratorToken(gameTokenAmount, recipient);\n\n    // Dispatch event\n    emit LpNftMinted(\n      _msgSender(),\n      recipient,\n      address(_numeratorToken),\n      address(_denominatorToken),\n      address(_uniswapV3NftManager),\n      lpNftTokenId,\n      gameTokenShare,\n      assetTokenShare,\n      liquidityAmount\n    );\n\n    return lpNftTokenId;\n  }\n\n  /**\n   * @dev See {IGameTokenPooler-mintLpNftWithAssetToken}\n   */\n  function mintLpNftWithAssetToken(\n    uint256 assetTokenAmount,\n    address recipient\n  ) public override nonReentrant returns (uint256 lpNftTokenId) {\n    // Call ancestor\n    uint256 gameTokenShare;\n    uint256 assetTokenShare;\n    uint128 liquidityAmount;\n    (\n      lpNftTokenId,\n      gameTokenShare,\n      assetTokenShare,\n      liquidityAmount\n    ) = _mintLpNftWithDenominatorToken(assetTokenAmount, recipient);\n\n    // Dispatch event\n    emit LpNftMinted(\n      _msgSender(),\n      recipient,\n      address(_numeratorToken),\n      address(_denominatorToken),\n      address(_uniswapV3NftManager),\n      lpNftTokenId,\n      gameTokenShare,\n      assetTokenShare,\n      liquidityAmount\n    );\n\n    return lpNftTokenId;\n  }\n\n  /**\n   * @dev See {IGameTokenPooler-mintLpNftImbalance}\n   */\n  function mintLpNftImbalance(\n    uint256 gameTokenAmount,\n    uint256 assetTokenAmount,\n    address recipient\n  ) public override nonReentrant returns (uint256 lpNftTokenId) {\n    // Call ancestor\n    uint256 gameTokenShare;\n    uint256 assetTokenShare;\n    uint128 liquidityAmount;\n    (\n      lpNftTokenId,\n      gameTokenShare,\n      assetTokenShare,\n      liquidityAmount\n    ) = _mintLpNftImbalance(gameTokenAmount, assetTokenAmount, recipient);\n\n    // Dispatch event\n    emit LpNftMinted(\n      _msgSender(),\n      recipient,\n      address(_numeratorToken),\n      address(_denominatorToken),\n      address(_uniswapV3NftManager),\n      lpNftTokenId,\n      gameTokenShare,\n      assetTokenShare,\n      liquidityAmount\n    );\n\n    return lpNftTokenId;\n  }\n\n  /**\n   * @dev See {IGameTokenPooler-collectFromLpNft}\n   */\n  function collectFromLpNft(\n    uint256 lpNftTokenId,\n    address recipient\n  ) public override nonReentrant returns (uint256 assetTokenReturned) {\n    // Call ancestor\n    uint128 liquidityAmount;\n    uint256 gameTokenCollected;\n    uint256 assetTokenCollected;\n    (\n      liquidityAmount,\n      gameTokenCollected,\n      assetTokenCollected,\n      assetTokenReturned\n    ) = _collectFromLpNft(lpNftTokenId, recipient);\n\n    // Dispatch event\n    emit LpNftCollected(\n      _msgSender(),\n      recipient,\n      address(_numeratorToken),\n      address(_denominatorToken),\n      address(_uniswapV3NftManager),\n      lpNftTokenId,\n      liquidityAmount,\n      gameTokenCollected,\n      assetTokenCollected,\n      assetTokenReturned\n    );\n\n    return assetTokenReturned;\n  }\n\n  /**\n   * @dev See {IGameTokenPooler-exit}\n   */\n  function exit(\n    uint256 lpNftTokenId\n  ) public override nonReentrant returns (uint256 assetTokenReturned) {\n    // Call ancestor\n    uint128 liquidityAmount;\n    uint256 gameTokenCollected;\n    uint256 assetTokenCollected;\n    (\n      liquidityAmount,\n      gameTokenCollected,\n      assetTokenCollected,\n      assetTokenReturned\n    ) = _exitPooler(lpNftTokenId);\n\n    // Dispatch event\n    emit LpNftCollected(\n      _msgSender(),\n      _msgSender(),\n      address(_numeratorToken),\n      address(_denominatorToken),\n      address(_uniswapV3NftManager),\n      lpNftTokenId,\n      liquidityAmount,\n      gameTokenCollected,\n      assetTokenCollected,\n      assetTokenReturned\n    );\n\n    return assetTokenReturned;\n  }\n}\n"
    },
    "contracts/src/token/routes/POW1MarketSwapper.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * This file is derived from the Ultrachess project under the Apache 2.0 license.\n * Copyright (C) 2022-2023 Ultrachess team\n *\n * SPDX-License-Identifier: GPL-3.0-or-later AND Apache-2.0\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport {IGameTokenSwapper} from \"../../interfaces/token/routes/IGameTokenSwapper.sol\";\n\nimport {UniV3Swapper} from \"./UniV3Swapper.sol\";\n\n/**\n * @dev Token router to swap between the game token and a yielding asset token\n */\ncontract POW1MarketSwapper is\n  Context,\n  ReentrancyGuard,\n  UniV3Swapper,\n  IGameTokenSwapper\n{\n  //////////////////////////////////////////////////////////////////////////////\n  // Initialization\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Initializes the contract\n   *\n   * @param pow1Token_ The address of the POW1 token\n   * @param marketToken_ The address of the market token\n   * @param pow1MarketPool_ The address of the pool contract for the token pair\n   */\n  constructor(\n    address pow1Token_,\n    address marketToken_,\n    address pow1MarketPool_\n  ) UniV3Swapper(pow1Token_, marketToken_, pow1MarketPool_) {}\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IGameTokenSwapper}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IGameTokenSwapper-gameIsToken0}\n   */\n  function gameIsToken0() public view override returns (bool) {\n    return _numeratorIsToken0;\n  }\n\n  /**\n   * @dev See {IGameTokenSwapper-buyGameToken}\n   */\n  function buyGameToken(\n    uint256 assetTokenAmount,\n    address recipient\n  ) public override nonReentrant returns (uint256 gameTokenReturned) {\n    // Call ancestor\n    gameTokenReturned = _buyNumeratorToken(assetTokenAmount, recipient);\n\n    // Emit event\n    emit GameTokenBought(\n      _msgSender(),\n      recipient,\n      address(_numeratorToken),\n      address(_denominatorToken),\n      assetTokenAmount,\n      gameTokenReturned\n    );\n\n    return gameTokenReturned;\n  }\n\n  /**\n   * @dev See {IGameTokenSwapper-sellGameToken}\n   */\n  function sellGameToken(\n    uint256 gameTokenAmount,\n    address recipient\n  ) public override nonReentrant returns (uint256 assetTokenReturned) {\n    // Call ancestor\n    assetTokenReturned = _sellNumeratorToken(gameTokenAmount, recipient);\n\n    // Emit event\n    emit GameTokenSold(\n      _msgSender(),\n      recipient,\n      address(_numeratorToken),\n      address(_denominatorToken),\n      gameTokenAmount,\n      assetTokenReturned\n    );\n\n    return assetTokenReturned;\n  }\n\n  /**\n   * @dev See {IGameTokenSwapper-exit}\n   */\n  function exit()\n    public\n    override\n    nonReentrant\n    returns (uint256 assetTokenReturned)\n  {\n    // Call ancestor\n    uint256 gameTokenAmount;\n    (gameTokenAmount, assetTokenReturned) = _exitSwapper();\n\n    // Emit event\n    emit GameTokenSold(\n      _msgSender(),\n      _msgSender(),\n      address(_numeratorToken),\n      address(_denominatorToken),\n      gameTokenAmount,\n      assetTokenReturned\n    );\n\n    return assetTokenReturned;\n  }\n}\n"
    },
    "contracts/src/token/routes/POW5StablePooler.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * This file is derived from the Ultrachess project under the Apache 2.0 license.\n * Copyright (C) 2022-2023 Ultrachess team\n *\n * SPDX-License-Identifier: GPL-3.0-or-later AND Apache-2.0\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport {IGameTokenPooler} from \"../../interfaces/token/routes/IGameTokenPooler.sol\";\n\nimport {UniV3Pooler} from \"./UniV3Pooler.sol\";\n\n/**\n * @dev Token router send to liquidity to the Uniswap V3 pool in exchange for\n *      an LP-NFT\n */\ncontract POW5StablePooler is\n  Context,\n  ReentrancyGuard,\n  UniV3Pooler,\n  IGameTokenPooler\n{\n  //////////////////////////////////////////////////////////////////////////////\n  // Initialization\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Initializes the contract\n   *\n   * @param pow5Token_ The address of the POW5 token\n   * @param stableToken_ The address of the stable token\n   * @param pow5StablePool_ The address of the Uniswap V3 pool contract\n   * @param uniswapV3NftManager_ The address of the upstream Uniswap V3 NFT\n   *        manager\n   */\n  constructor(\n    address pow5Token_,\n    address stableToken_,\n    address pow5StablePool_,\n    address uniswapV3NftManager_\n  )\n    UniV3Pooler(pow5Token_, stableToken_, pow5StablePool_, uniswapV3NftManager_)\n  {}\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IGameTokenPooler}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IGameTokenPooler-gameIsToken0}\n   */\n  function gameIsToken0() public view override returns (bool) {\n    return _numeratorIsToken0;\n  }\n\n  /**\n   * @dev See {IGameTokenPooler-mintLpNftWithGameToken}\n   */\n  function mintLpNftWithGameToken(\n    uint256 gameTokenAmount,\n    address recipient\n  ) public override nonReentrant returns (uint256 lpNftTokenId) {\n    // Call ancestor\n    uint256 gameTokenShare;\n    uint256 assetTokenShare;\n    uint128 liquidityAmount;\n    (\n      lpNftTokenId,\n      gameTokenShare,\n      assetTokenShare,\n      liquidityAmount\n    ) = _mintLpNftWithNumeratorToken(gameTokenAmount, recipient);\n\n    // Dispatch event\n    emit LpNftMinted(\n      _msgSender(),\n      recipient,\n      address(_numeratorToken),\n      address(_denominatorToken),\n      address(_uniswapV3NftManager),\n      lpNftTokenId,\n      gameTokenShare,\n      assetTokenShare,\n      liquidityAmount\n    );\n\n    return lpNftTokenId;\n  }\n\n  /**\n   * @dev See {IGameTokenPooler-mintLpNftWithAssetToken}\n   */\n  function mintLpNftWithAssetToken(\n    uint256 assetTokenAmount,\n    address recipient\n  ) public override nonReentrant returns (uint256 lpNftTokenId) {\n    // Call ancestor\n    uint256 gameTokenShare;\n    uint256 assetTokenShare;\n    uint128 liquidityAmount;\n    (\n      lpNftTokenId,\n      gameTokenShare,\n      assetTokenShare,\n      liquidityAmount\n    ) = _mintLpNftWithDenominatorToken(assetTokenAmount, recipient);\n\n    // Dispatch event\n    emit LpNftMinted(\n      _msgSender(),\n      recipient,\n      address(_numeratorToken),\n      address(_denominatorToken),\n      address(_uniswapV3NftManager),\n      lpNftTokenId,\n      gameTokenShare,\n      assetTokenShare,\n      liquidityAmount\n    );\n\n    return lpNftTokenId;\n  }\n\n  /**\n   * @dev See {IGameTokenPooler-mintLpNftImbalance}\n   */\n  function mintLpNftImbalance(\n    uint256 gameTokenAmount,\n    uint256 assetTokenAmount,\n    address recipient\n  ) public override nonReentrant returns (uint256 lpNftTokenId) {\n    // Call ancestor\n    uint256 gameTokenShare;\n    uint256 assetTokenShare;\n    uint128 liquidityAmount;\n    (\n      lpNftTokenId,\n      gameTokenShare,\n      assetTokenShare,\n      liquidityAmount\n    ) = _mintLpNftImbalance(gameTokenAmount, assetTokenAmount, recipient);\n\n    // Dispatch event\n    emit LpNftMinted(\n      _msgSender(),\n      recipient,\n      address(_numeratorToken),\n      address(_denominatorToken),\n      address(_uniswapV3NftManager),\n      lpNftTokenId,\n      gameTokenShare,\n      assetTokenShare,\n      liquidityAmount\n    );\n\n    return lpNftTokenId;\n  }\n\n  /**\n   * @dev See {IGameTokenPooler-collectFromLpNft}\n   */\n  function collectFromLpNft(\n    uint256 lpNftTokenId,\n    address recipient\n  ) public override nonReentrant returns (uint256 assetTokenReturned) {\n    // Call ancestor\n    uint128 liquidityAmount;\n    uint256 gameTokenCollected;\n    uint256 assetTokenCollected;\n    (\n      liquidityAmount,\n      gameTokenCollected,\n      assetTokenCollected,\n      assetTokenReturned\n    ) = _collectFromLpNft(lpNftTokenId, recipient);\n\n    // Dispatch event\n    emit LpNftCollected(\n      _msgSender(),\n      recipient,\n      address(_numeratorToken),\n      address(_denominatorToken),\n      address(_uniswapV3NftManager),\n      lpNftTokenId,\n      liquidityAmount,\n      gameTokenCollected,\n      assetTokenCollected,\n      assetTokenReturned\n    );\n\n    return assetTokenReturned;\n  }\n\n  /**\n   * @dev See {IGameTokenPooler-exit}\n   */\n  function exit(\n    uint256 lpNftTokenId\n  ) external override nonReentrant returns (uint256 assetTokenReturned) {\n    // Call ancestor\n    uint128 liquidityAmount;\n    uint256 gameTokenCollected;\n    uint256 assetTokenCollected;\n    (\n      liquidityAmount,\n      gameTokenCollected,\n      assetTokenCollected,\n      assetTokenReturned\n    ) = _exitPooler(lpNftTokenId);\n\n    // Dispatch event\n    emit LpNftCollected(\n      _msgSender(),\n      _msgSender(),\n      address(_numeratorToken),\n      address(_denominatorToken),\n      address(_uniswapV3NftManager),\n      lpNftTokenId,\n      liquidityAmount,\n      gameTokenCollected,\n      assetTokenCollected,\n      assetTokenReturned\n    );\n\n    return assetTokenReturned;\n  }\n}\n"
    },
    "contracts/src/token/routes/POW5StableSwapper.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * This file is derived from the Ultrachess project under the Apache 2.0 license.\n * Copyright (C) 2022-2023 Ultrachess team\n *\n * SPDX-License-Identifier: GPL-3.0-or-later AND Apache-2.0\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport {IGameTokenSwapper} from \"../../interfaces/token/routes/IGameTokenSwapper.sol\";\n\nimport {UniV3Swapper} from \"./UniV3Swapper.sol\";\n\n/**\n * @dev Token router to swap between the game token and a yielding asset token\n */\ncontract POW5StableSwapper is\n  Context,\n  ReentrancyGuard,\n  UniV3Swapper,\n  IGameTokenSwapper\n{\n  //////////////////////////////////////////////////////////////////////////////\n  // Initialization\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Initializes the contract\n   *\n   * @param pow5Token_ The address of the POW5 token\n   * @param marketToken_ The address of the market token\n   * @param pow5MarketPool_ The address of the pool contract for the token pair\n   */\n  constructor(\n    address pow5Token_,\n    address marketToken_,\n    address pow5MarketPool_\n  ) UniV3Swapper(pow5Token_, marketToken_, pow5MarketPool_) {}\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IGameTokenSwapper}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IGameTokenSwapper-gameIsToken0}\n   */\n  function gameIsToken0() public view override returns (bool) {\n    return _numeratorIsToken0;\n  }\n\n  /**\n   * @dev See {IGameTokenSwapper-buyGameToken}\n   */\n  function buyGameToken(\n    uint256 assetTokenAmount,\n    address recipient\n  ) public override nonReentrant returns (uint256 gameTokenReturned) {\n    // Call ancestor\n    gameTokenReturned = _buyNumeratorToken(assetTokenAmount, recipient);\n\n    // Emit event\n    emit GameTokenBought(\n      _msgSender(),\n      recipient,\n      address(_numeratorToken),\n      address(_denominatorToken),\n      assetTokenAmount,\n      gameTokenReturned\n    );\n\n    return gameTokenReturned;\n  }\n\n  /**\n   * @dev See {IGameTokenSwapper-sellGameToken}\n   */\n  function sellGameToken(\n    uint256 gameTokenAmount,\n    address recipient\n  ) public override nonReentrant returns (uint256 assetTokenReturned) {\n    // Call ancestor\n    assetTokenReturned = _sellNumeratorToken(gameTokenAmount, recipient);\n\n    // Emit event\n    emit GameTokenSold(\n      _msgSender(),\n      recipient,\n      address(_numeratorToken),\n      address(_denominatorToken),\n      gameTokenAmount,\n      assetTokenReturned\n    );\n\n    return assetTokenReturned;\n  }\n\n  /**\n   * @dev See {IGameTokenSwapper-exit}\n   */\n  function exit()\n    public\n    override\n    nonReentrant\n    returns (uint256 assetTokenReturned)\n  {\n    // Call ancestor\n    uint256 gameTokenAmount;\n    (gameTokenAmount, assetTokenReturned) = _exitSwapper();\n\n    // Emit event\n    emit GameTokenSold(\n      _msgSender(),\n      _msgSender(),\n      address(_numeratorToken),\n      address(_denominatorToken),\n      gameTokenAmount,\n      assetTokenReturned\n    );\n  }\n}\n"
    },
    "contracts/src/token/routes/UniV3Pooler.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * This file is derived from the Ultrachess project under the Apache 2.0 license.\n * Copyright (C) 2022-2023 Ultrachess team\n *\n * SPDX-License-Identifier: GPL-3.0-or-later AND Apache-2.0\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ERC721Holder} from \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport {INonfungiblePositionManager} from \"../../../interfaces/uniswap-v3-periphery/INonfungiblePositionManager.sol\";\n\nimport {LiquidityMath} from \"../../utils/math/LiquidityMath.sol\";\n\nimport {UniV3Swapper} from \"./UniV3Swapper.sol\";\n\n/**\n * @dev Token router send to liquidity to the Uniswap V3 pool in exchange for\n *      an LP-NFT\n */\nabstract contract UniV3Pooler is Context, ERC721Holder, UniV3Swapper {\n  using SafeERC20 for IERC20;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Constants\n  //////////////////////////////////////////////////////////////////////////////\n\n  int24 private constant TICK_LOWER = -887200;\n\n  int24 private constant TICK_UPPER = 887200;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Routes\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev The upstream Uniswap V3 NFT manager\n   */\n  INonfungiblePositionManager internal immutable _uniswapV3NftManager;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Initialization\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Initializes the contract\n   *\n   * @param numeratorToken_ The address of the numerator token of the pair\n   * @param denominatorToken_ The address of the denominator token of the pair\n   * @param uniswapV3Pool_ The address of the Uniswap V3 pool contract for the\n   *        pair\n   * @param uniswapV3NftManager_ The address of the upstream Uniswap V3 NFT\n   *        manager\n   */\n  constructor(\n    address numeratorToken_,\n    address denominatorToken_,\n    address uniswapV3Pool_,\n    address uniswapV3NftManager_\n  ) UniV3Swapper(numeratorToken_, denominatorToken_, uniswapV3Pool_) {\n    // Validate parameters\n    require(uniswapV3NftManager_ != address(0), \"Invalid NFT mgr\");\n\n    // Initialize routes\n    _uniswapV3NftManager = INonfungiblePositionManager(uniswapV3NftManager_);\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Internal interface\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Mints an LP-NFT and deposits liquidity into the pool using the\n   * numerator token\n   *\n   * A swap will occur to allow for single-sided supply.\n   *\n   * @param numeratorTokenAmount The amounts of the numerator token to deposit\n   * @param recipient The recipient of the LP-NFT\n   *\n   * @return lpNftTokenId The ID of the minted NFT\n   */\n  function _mintLpNftWithNumeratorToken(\n    uint256 numeratorTokenAmount,\n    address recipient\n  )\n    internal\n    returns (\n      uint256 lpNftTokenId,\n      uint256 numeratorTokenShare,\n      uint256 denominatorTokenShare,\n      uint128 liquidityAmount\n    )\n  {\n    // Validate parameters\n    require(numeratorTokenAmount > 0, \"No numerator token\");\n    require(recipient != address(0), \"Invalid recipient\");\n\n    // Receive numerator token\n    _receiveNumeratorToken(numeratorTokenAmount);\n\n    // Get numerator token reserve\n    uint256 numeratorTokenReserve = _numeratorToken.balanceOf(\n      address(_uniswapV3Pool)\n    );\n\n    // Get the pool fee\n    uint24 poolFee = _uniswapV3Pool.fee();\n\n    // Calculate numerator swap amount\n    uint256 numeratorSwapAmount = LiquidityMath.computeSwapAmountV2(\n      numeratorTokenReserve,\n      numeratorTokenAmount,\n      poolFee\n    );\n    require(numeratorSwapAmount <= numeratorTokenAmount, \"Bad liquidity math\");\n\n    // Swap the numerator token into the denominator token\n    uint256 denominatorTokenAmount = _swapNumeratorForDenominator(\n      numeratorSwapAmount\n    );\n\n    // Update numerator token amount\n    numeratorTokenAmount -= numeratorSwapAmount;\n\n    // Mint the LP-NFT\n    (\n      lpNftTokenId,\n      numeratorTokenShare,\n      denominatorTokenShare,\n      liquidityAmount\n    ) = _mintLpNft(numeratorTokenAmount, denominatorTokenAmount, recipient);\n\n    // Return any numerator or denominator token dust\n    _returnDust(recipient);\n\n    return (\n      lpNftTokenId,\n      numeratorTokenAmount,\n      denominatorTokenAmount,\n      liquidityAmount\n    );\n  }\n\n  /**\n   * @dev Mints an LP-NFT and deposits liquidity into the pool using the\n   * denominator token\n   *\n   * A swap will occur to allow for single-sided supply.\n   *\n   * @param denominatorTokenAmount The amount of the denominator token to\n   *        deposit\n   * @param recipient The recipient of the LP-NFT\n   *\n   * @return lpNftTokenId The ID of the minted NFT\n   */\n  function _mintLpNftWithDenominatorToken(\n    uint256 denominatorTokenAmount,\n    address recipient\n  )\n    internal\n    returns (\n      uint256 lpNftTokenId,\n      uint256 numeratorTokenShare,\n      uint256 denominatorTokenShare,\n      uint128 liquidityAmount\n    )\n  {\n    // Validate parameters\n    require(denominatorTokenAmount > 0, \"No denominator token\");\n    require(recipient != address(0), \"Invalid recipient\");\n\n    // Receive denominator token\n    _receiveDenominatorToken(denominatorTokenAmount);\n\n    // Get denominator token reserve\n    uint256 denominatorTokenReserve = _denominatorToken.balanceOf(\n      address(_uniswapV3Pool)\n    );\n\n    // Get the pool fee\n    uint24 poolFee = _uniswapV3Pool.fee();\n\n    // Calculate denominator swap amount\n    uint256 denominatorSwapAmount = LiquidityMath.computeSwapAmountV2(\n      denominatorTokenReserve,\n      denominatorTokenAmount,\n      poolFee\n    );\n    require(\n      denominatorSwapAmount <= denominatorTokenAmount,\n      \"Bad liquidity math\"\n    );\n\n    // Swap the denominator token into the numerator token\n    uint256 numeratorTokenAmount = _swapDenominatorForNumerator(\n      denominatorSwapAmount\n    );\n\n    // Update denominator token amount\n    denominatorTokenAmount -= denominatorSwapAmount;\n\n    // Mint the LP-NFT\n    (\n      lpNftTokenId,\n      numeratorTokenShare,\n      denominatorTokenShare,\n      liquidityAmount\n    ) = _mintLpNft(numeratorTokenAmount, denominatorTokenAmount, recipient);\n\n    // Return any numerator or denominator token dust\n    _returnDust(recipient);\n\n    return (\n      lpNftTokenId,\n      numeratorTokenAmount,\n      denominatorTokenAmount,\n      liquidityAmount\n    );\n  }\n\n  /**\n   * @dev Mints a Uniswap V3 LP-NFT and deposits liquidity into the pool\n   * without performing a token swap\n   *\n   * @param numeratorTokenAmount The amount of the numerator token to deposit\n   * @param denominatorTokenAmount The amount of the denominator token to deposit\n   * @param recipient The recient of the LP-NFT\n   *\n   * @return lpNftTokenId The ID of the minted NFT\n   */\n  function _mintLpNftImbalance(\n    uint256 numeratorTokenAmount,\n    uint256 denominatorTokenAmount,\n    address recipient\n  )\n    internal\n    returns (\n      uint256 lpNftTokenId,\n      uint256 numeratorTokenShare,\n      uint256 denominatorTokenShare,\n      uint128 liquidityAmount\n    )\n  {\n    // Validate parameters\n    require(\n      numeratorTokenAmount > 0 || denominatorTokenAmount > 0,\n      \"No amounts\"\n    );\n    require(recipient != address(0), \"Invalid recipient\");\n\n    // Receive the tokens\n    _receiveNumeratorToken(numeratorTokenAmount);\n    _receiveDenominatorToken(denominatorTokenAmount);\n\n    // Mint the LP-NFT\n    (\n      lpNftTokenId,\n      numeratorTokenShare,\n      denominatorTokenShare,\n      liquidityAmount\n    ) = _mintLpNft(numeratorTokenAmount, denominatorTokenAmount, recipient);\n\n    // Return any numerator or denominator token dust\n    _returnDust(recipient);\n\n    return (\n      lpNftTokenId,\n      numeratorTokenAmount,\n      denominatorTokenAmount,\n      liquidityAmount\n    );\n  }\n\n  /**\n   * @dev Collects the tokens and fees from an LP-NFT and returns the\n   * denominator token and empty LP-NFT to the recipient\n   *\n   * @param lpNftTokenId The ID of the LP-NFT\n   * @param recipient The recipient of the fees and the LP-NFT\n   *\n   * @return liquidityAmount The amount of liquidity collected\n   * @return numeratorTokenCollected The amount of the numerator token collected\n   * @return denominatorTokenCollected The amount of the denominator token collected\n   * @return denominatorTokenReturned The amount of the denominator token returned\n   */\n  function _collectFromLpNft(\n    uint256 lpNftTokenId,\n    address recipient\n  )\n    internal\n    returns (\n      uint128 liquidityAmount,\n      uint256 numeratorTokenCollected,\n      uint256 denominatorTokenCollected,\n      uint256 denominatorTokenReturned\n    )\n  {\n    // Validate parameters\n    require(recipient != address(0), \"Invalid recipient\");\n\n    // Read state\n    // slither-disable-next-line unused-return\n    (, , , , , , , liquidityAmount, , , , ) = _uniswapV3NftManager.positions(\n      lpNftTokenId\n    );\n\n    // Collect tokens and fees from the LP-NFT\n    (\n      numeratorTokenCollected,\n      denominatorTokenCollected\n    ) = _collectTokensAndFees(lpNftTokenId, liquidityAmount);\n\n    // Track token amount\n    uint256 denominatorTokenAmount = denominatorTokenCollected;\n\n    // Swap the numerator token for the denominator token\n    if (numeratorTokenCollected > 0) {\n      uint256 denominatorTokenBought = _sellNumeratorToken(\n        numeratorTokenCollected,\n        address(this)\n      );\n\n      // Update token balance\n      denominatorTokenAmount += denominatorTokenBought;\n    }\n\n    // Return the denominator token from this contract\n    _returnDenominatorToken(denominatorTokenAmount, recipient);\n\n    // Return the LP-NFT to the recipient\n    _uniswapV3NftManager.safeTransferFrom(\n      _msgSender(),\n      recipient,\n      lpNftTokenId\n    );\n\n    return (\n      liquidityAmount,\n      numeratorTokenCollected,\n      denominatorTokenCollected,\n      denominatorTokenAmount\n    );\n  }\n\n  /**\n   * @dev Liquidates everything to the denominator token in one transaction and\n   * returns the empty LP-NFT\n   *\n   * @param lpNftTokenId The ID of the LP-NFT\n   *\n   * @return liquidityAmount The amount of liquidity collected\n   * @return numeratorTokenCollected The amount of the numerator token collected\n   * @return denominatorTokenCollected The amount of the denominator token collected\n   * @return denominatorTokenReturned The amount of the denominator token returned\n   */\n  function _exitPooler(\n    uint256 lpNftTokenId\n  )\n    internal\n    returns (\n      uint128 liquidityAmount,\n      uint256 numeratorTokenCollected,\n      uint256 denominatorTokenCollected,\n      uint256 denominatorTokenReturned\n    )\n  {\n    // Collect and transfer the LP-NFT back to the sender\n    (\n      liquidityAmount,\n      numeratorTokenCollected,\n      denominatorTokenCollected,\n      denominatorTokenReturned\n    ) = _collectFromLpNft(lpNftTokenId, _msgSender());\n\n    return (\n      liquidityAmount,\n      numeratorTokenCollected,\n      denominatorTokenCollected,\n      denominatorTokenReturned\n    );\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Private interface\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Approve the NFT manager to spend the tokens\n   *\n   * @param numeratorTokenAmount The amount of the numerator token to approve\n   * @param denominatorTokenAmount The amount of the denominator token to approve\n   */\n  function _approveTokens(\n    uint256 numeratorTokenAmount,\n    uint256 denominatorTokenAmount\n  ) private {\n    // Call external contracts\n    if (numeratorTokenAmount > 0) {\n      _numeratorToken.safeIncreaseAllowance(\n        address(_uniswapV3NftManager),\n        numeratorTokenAmount\n      );\n    }\n    if (denominatorTokenAmount > 0) {\n      _denominatorToken.safeIncreaseAllowance(\n        address(_uniswapV3NftManager),\n        denominatorTokenAmount\n      );\n    }\n  }\n\n  /**\n   * @dev Mint an LP-NFT\n   *\n   * @param numeratorTokenAmount The amount of the numerator token to add to the pool\n   * @param denominatorTokenAmount The amount of the denominator token to add to the pool\n   * @param recipient The recipient of the minted LP-NFT\n   *\n   * @return lpNftTokenId The ID of the minted LP-NFT\n   * @return numeratorTokenShare The amount of the numerator token in the LP-NFT\n   * @return denominatorTokenShare The amount of the denominator token in the LP-NFT\n   * @return liquidityAmount The amount of liquidity in the LP-NFT\n   */\n  function _mintLpNft(\n    uint256 numeratorTokenAmount,\n    uint256 denominatorTokenAmount,\n    address recipient\n  )\n    private\n    returns (\n      uint256 lpNftTokenId,\n      uint256 numeratorTokenShare,\n      uint256 denominatorTokenShare,\n      uint128 liquidityAmount\n    )\n  {\n    // Approve the NFT manager to spend the numerator and denominator tokens\n    _approveTokens(numeratorTokenAmount, denominatorTokenAmount);\n\n    // Get the pool fee\n    uint24 poolFee = _uniswapV3Pool.fee();\n\n    // Mint the LP-NFT\n    uint256 amount0;\n    uint256 amount1;\n    (lpNftTokenId, liquidityAmount, amount0, amount1) = _uniswapV3NftManager\n      .mint(\n        INonfungiblePositionManager.MintParams({\n          token0: _numeratorIsToken0\n            ? address(_numeratorToken)\n            : address(_denominatorToken),\n          token1: _numeratorIsToken0\n            ? address(_denominatorToken)\n            : address(_numeratorToken),\n          fee: poolFee,\n          tickLower: TICK_LOWER,\n          tickUpper: TICK_UPPER,\n          amount0Desired: _numeratorIsToken0\n            ? numeratorTokenAmount\n            : denominatorTokenAmount,\n          amount1Desired: _numeratorIsToken0\n            ? denominatorTokenAmount\n            : numeratorTokenAmount,\n          amount0Min: 0,\n          amount1Min: 0,\n          recipient: recipient,\n          // slither-disable-next-line timestamp\n          deadline: block.timestamp\n        })\n      );\n\n    // Calculate results\n    numeratorTokenShare = _numeratorIsToken0 ? amount0 : amount1;\n    denominatorTokenShare = _numeratorIsToken0 ? amount1 : amount0;\n\n    return (\n      lpNftTokenId,\n      numeratorTokenShare,\n      denominatorTokenShare,\n      liquidityAmount\n    );\n  }\n\n  /**\n   * @dev Collect tokens and fees from an LP-NFT\n   *\n   * @param lpNftTokenId The ID of the LP-NFT\n   * @param liquidityAmount The amount of liquidity to collect\n   *\n   * @return numeratorTokenCollected The amount of the numerator token collected\n   * @return denominatorTokenCollected The amount of the denominator token collected\n   */\n  function _collectTokensAndFees(\n    uint256 lpNftTokenId,\n    uint128 liquidityAmount\n  )\n    private\n    returns (uint256 numeratorTokenCollected, uint256 denominatorTokenCollected)\n  {\n    if (liquidityAmount > 0) {\n      // Withdraw tokens from the pool\n      // slither-disable-next-line unused-return\n      _uniswapV3NftManager.decreaseLiquidity(\n        INonfungiblePositionManager.DecreaseLiquidityParams({\n          tokenId: lpNftTokenId,\n          liquidity: liquidityAmount,\n          amount0Min: 0,\n          amount1Min: 0,\n          // slither-disable-next-line timestamp\n          deadline: block.timestamp\n        })\n      );\n    }\n\n    // Collect the tokens and fees\n    (uint256 amount0, uint256 amount1) = _uniswapV3NftManager.collect(\n      INonfungiblePositionManager.CollectParams({\n        tokenId: lpNftTokenId,\n        recipient: address(this),\n        amount0Max: type(uint128).max,\n        amount1Max: type(uint128).max\n      })\n    );\n\n    // Calculate results\n    numeratorTokenCollected = _numeratorIsToken0 ? amount0 : amount1;\n    denominatorTokenCollected = _numeratorIsToken0 ? amount1 : amount0;\n\n    return (numeratorTokenCollected, denominatorTokenCollected);\n  }\n\n  /**\n   * @dev Return any numerator or denominator token dust to the recipient\n   *\n   * @param recipient The recipient of the dust\n   */\n  function _returnDust(address recipient) private {\n    // Return the denominator token dust to the recipient\n    uint256 denominatorTokenDust = _denominatorToken.balanceOf(address(this));\n    if (denominatorTokenDust > 0) {\n      _returnDenominatorToken(denominatorTokenDust, recipient);\n    }\n\n    // Return the numerator token dust to the recipient\n    uint256 numeratorTokenDust = _numeratorToken.balanceOf(address(this));\n    if (numeratorTokenDust > 0) {\n      _returnNumeratorToken(numeratorTokenDust, recipient);\n    }\n  }\n}\n"
    },
    "contracts/src/token/routes/UniV3Swapper.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * This file is derived from the Ultrachess project under the Apache 2.0 license.\n * Copyright (C) 2022-2023 Ultrachess team\n *\n * SPDX-License-Identifier: GPL-3.0-or-later AND Apache-2.0\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport {IUniswapV3SwapCallback} from \"../../../interfaces/uniswap-v3-core/callback/IUniswapV3SwapCallback.sol\";\nimport {IUniswapV3Pool} from \"../../../interfaces/uniswap-v3-core/IUniswapV3Pool.sol\";\n\n/**\n * @dev Token router to swap between the numerator token and a yielding denominator token\n */\nabstract contract UniV3Swapper is Context, IUniswapV3SwapCallback {\n  using SafeERC20 for IERC20;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Constants\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev The minimum value that can be returned from {TickMath-getSqrtRatioAtTick}\n   *\n   * Equivalent to getSqrtRatioAtTick(MIN_TICK).\n   */\n  uint160 private constant MIN_SQRT_RATIO = 4295128739;\n\n  /**\n   * @dev The maximum value that can be returned from {TickMath-getSqrtRatioAtTick}\n   *\n   * Equivalent to getSqrtRatioAtTick(MAX_TICK).\n   */\n  uint160 private constant MAX_SQRT_RATIO =\n    1461446703485210103287273052203988822378723970342;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Routes\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev The numerator token\n   */\n  IERC20 internal immutable _numeratorToken;\n\n  /**\n   * @dev The denominator token\n   */\n  IERC20 internal immutable _denominatorToken;\n\n  /**\n   * @dev The Uniswap V3 pool for the token pair\n   */\n  IUniswapV3Pool internal immutable _uniswapV3Pool;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // State\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev True if the numerator token is sorted first in the Uniswap V3 pool,\n   * false otherwise\n   */\n  bool internal immutable _numeratorIsToken0;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Initialization\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Initializes the contract\n   *\n   * @param numeratorToken_ The address of the numerator token of the pair\n   * @param denominatorToken_ The address of the denominator token of the pair\n   * @param uniswapV3Pool_ The address of the Uniswap V3 pool contract for the pair\n   */\n  constructor(\n    address numeratorToken_,\n    address denominatorToken_,\n    address uniswapV3Pool_\n  ) {\n    // Validate parameters\n    require(numeratorToken_ != address(0), \"Invalid numerator\");\n    require(denominatorToken_ != address(0), \"Invalid denominator\");\n    require(uniswapV3Pool_ != address(0), \"Invalid pool\");\n\n    // Read external contracts\n    address token0 = IUniswapV3Pool(uniswapV3Pool_).token0();\n    address token1 = IUniswapV3Pool(uniswapV3Pool_).token1();\n\n    // Validate external contracts\n    require(token0 != address(0), \"Invalid token0\");\n    require(token1 != address(0), \"Invalid token1\");\n\n    // Determine token order\n    bool numeratorIsToken0_ = numeratorToken_ == token0;\n\n    // Validate external contracts\n    if (numeratorIsToken0_) {\n      require(token0 == numeratorToken_, \"Invalid token0 for num\");\n      require(token1 == denominatorToken_, \"Invalid token1 for denom\");\n    } else {\n      require(token0 == denominatorToken_, \"Invalid token0 for denom\");\n      require(token1 == numeratorToken_, \"Invalid token1 for num\");\n    }\n\n    // Initialize routes\n    _numeratorToken = IERC20(numeratorToken_);\n    _denominatorToken = IERC20(denominatorToken_);\n    _uniswapV3Pool = IUniswapV3Pool(uniswapV3Pool_);\n\n    // Initialize state\n    _numeratorIsToken0 = numeratorIsToken0_;\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IUniswapV3SwapCallback}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IUniswapV3SwapCallback-uniswapV3SwapCallback}\n   *\n   * This function is called to the sender after a swap is executed on\n   * Uniswap V3.\n   *\n   * The pool tokens owed for the swap must be payed. The caller of this\n   * method must be checked to be a UniswapV3Pool deployed by the canonical\n   * UniswapV3Factory.\n   *\n   * amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n   */\n  function uniswapV3SwapCallback(\n    // slither-disable-next-line similar-names\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata\n  ) public override {\n    // Validate caller\n    require(_msgSender() == address(_uniswapV3Pool), \"Invalid caller\");\n\n    // Pay fees\n    if (amount0Delta > 0) {\n      IERC20(IUniswapV3Pool(_msgSender()).token0()).safeTransfer(\n        _msgSender(),\n        uint256(amount0Delta)\n      );\n    }\n    if (amount1Delta > 0) {\n      IERC20(IUniswapV3Pool(_msgSender()).token1()).safeTransfer(\n        _msgSender(),\n        uint256(amount1Delta)\n      );\n    }\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Internal market interface\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Buy the numerator token, spending the denominator token\n   *\n   * @param denominatorTokenAmount Amount of the denominator token to spend\n   * @param recipient Address to receive the numerator token\n   *\n   * @return numeratorTokenReturned Amount of the numerator token received\n   */\n  function _buyNumeratorToken(\n    uint256 denominatorTokenAmount,\n    address recipient\n  ) internal returns (uint256 numeratorTokenReturned) {\n    // Validate parameters\n    require(recipient != address(0), \"Invalid recipient\");\n\n    // Receive the denominator token\n    _receiveDenominatorToken(denominatorTokenAmount);\n\n    // Buy the numerator token\n    numeratorTokenReturned = _swapDenominatorForNumerator(\n      denominatorTokenAmount\n    );\n\n    // Return the numerator token\n    _returnNumeratorToken(numeratorTokenReturned, recipient);\n\n    return numeratorTokenReturned;\n  }\n\n  /**\n   * @dev Sell the numerator token, receiving the denominator token\n   *\n   * @param numeratorTokenAmount Amount of the numerator token to spend\n   * @param recipient Address to receive the denominator token\n   *\n   * @return denominatorTokenReturned Amount of the denominator token received\n   */\n  function _sellNumeratorToken(\n    uint256 numeratorTokenAmount,\n    address recipient\n  ) internal returns (uint256 denominatorTokenReturned) {\n    // Validate parameters\n    require(numeratorTokenAmount > 0, \"Invalid amount\");\n    require(recipient != address(0), \"Invalid recipient\");\n\n    // Receive the numerator token\n    _receiveNumeratorToken(numeratorTokenAmount);\n\n    // Sell the numerator token\n    denominatorTokenReturned = _swapNumeratorForDenominator(\n      numeratorTokenAmount\n    );\n\n    // Return the denominator token\n    _returnDenominatorToken(denominatorTokenReturned, recipient);\n\n    return denominatorTokenReturned;\n  }\n\n  /**\n   * @dev Exit the protocol, selling the numerator token for the denominator token\n   *\n   * @return numeratorTokenAmount Amount of the numerator token spent\n   * @return denominatorTokenReturned Amount of the denominator token received\n   */\n  function _exitSwapper()\n    internal\n    returns (uint256 numeratorTokenAmount, uint256 denominatorTokenReturned)\n  {\n    // Read state\n    numeratorTokenAmount = _numeratorToken.balanceOf(_msgSender());\n\n    // Swap everything\n    denominatorTokenReturned = _sellNumeratorToken(\n      numeratorTokenAmount,\n      _msgSender()\n    );\n\n    return (numeratorTokenAmount, denominatorTokenReturned);\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Internal swapping interface\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Swap the denominator token for the numerator token\n   *\n   * @param denominatorTokenAmount Amount of the denominator token to swap\n   *\n   * @return numeratorTokenReturned Amount of the numerator token received\n   */\n  function _swapDenominatorForNumerator(\n    uint256 denominatorTokenAmount\n  ) internal returns (uint256 numeratorTokenReturned) {\n    // Approve Uniswap V3 pool to spend the denominator token\n    _denominatorToken.safeIncreaseAllowance(\n      address(_uniswapV3Pool),\n      denominatorTokenAmount\n    );\n\n    //\n    // Swap the denominator token for the numerator token\n    //\n    // A note about amount0 and amount1:\n    //\n    // amount0 is the delta of the balance of token0 of the pool\n    // amount1 is the delta of the balance of token1 of the pool\n    //\n    // Amounts are exact when negative, minimum when positive.\n    //\n    bool zeroForOne = _numeratorIsToken0 ? false : true;\n    (int256 amount0, int256 amount1) = _uniswapV3Pool.swap(\n      address(this),\n      zeroForOne,\n      SafeCast.toInt256(denominatorTokenAmount),\n      _numeratorIsToken0 ? MAX_SQRT_RATIO - 1 : MIN_SQRT_RATIO + 1, // TODO\n      \"\"\n    );\n\n    // Calculate numerator token amount\n    numeratorTokenReturned = _numeratorIsToken0\n      ? SafeCast.toUint256(-amount0)\n      : SafeCast.toUint256(-amount1);\n\n    return numeratorTokenReturned;\n  }\n\n  /**\n   * @dev Swap the numerator token for the denominator token\n   *\n   * @param numeratorTokenAmount Amount of the numerator token to swap\n   *\n   * @return denominatorTokenReturned Amount of the denominator token received\n   */\n  function _swapNumeratorForDenominator(\n    uint256 numeratorTokenAmount\n  ) internal returns (uint256 denominatorTokenReturned) {\n    // Approve Uniswap V3 pool to spend the numerator token\n    _numeratorToken.safeIncreaseAllowance(\n      address(_uniswapV3Pool),\n      numeratorTokenAmount\n    );\n\n    //\n    // Swap the numerator token for the denominator token\n    //\n    // A note about amount0 and amount1:\n    //\n    // amount0 is the delta of the balance of token0 of the pool\n    // amount1 is the delta of the balance of token1 of the pool\n    //\n    // Amounts are exact when negative, minimum when positive.\n    //\n    bool zeroForOne = _numeratorIsToken0 ? true : false;\n    (int256 amount0, int256 amount1) = _uniswapV3Pool.swap(\n      address(this),\n      zeroForOne,\n      SafeCast.toInt256(numeratorTokenAmount),\n      _numeratorIsToken0 ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1, // TODO\n      \"\"\n    );\n\n    // Calculate denominator token amount\n    denominatorTokenReturned = _numeratorIsToken0\n      ? SafeCast.toUint256(-amount1)\n      : SafeCast.toUint256(-amount0);\n\n    return denominatorTokenReturned;\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Internal routing interface\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Procure the numerator token from the sender\n   *\n   * @param numeratorTokenAmount Amount of the numerator token to transfer\n   */\n  function _receiveNumeratorToken(uint256 numeratorTokenAmount) internal {\n    // Call external contracts\n    if (numeratorTokenAmount > 0) {\n      _numeratorToken.safeTransferFrom(\n        _msgSender(),\n        address(this),\n        numeratorTokenAmount\n      );\n    }\n  }\n\n  /**\n   * @dev Procure the denominator token from the sender\n   *\n   * @param denominatorTokenAmount Amount of the denominator token to transfer\n   */\n  function _receiveDenominatorToken(uint256 denominatorTokenAmount) internal {\n    // Call external contracts\n    if (denominatorTokenAmount > 0) {\n      _denominatorToken.safeTransferFrom(\n        _msgSender(),\n        address(this),\n        denominatorTokenAmount\n      );\n    }\n  }\n\n  /**\n   * @dev Return the numerator token to the recipient\n   *\n   * @param numeratorTokenAmount Amount of the numerator token to transfer\n   * @param recipient Address to transfer the numerator token to\n   */\n  function _returnNumeratorToken(\n    uint256 numeratorTokenAmount,\n    address recipient\n  ) internal {\n    // Call external contracts\n    if (numeratorTokenAmount > 0) {\n      _numeratorToken.safeTransfer(recipient, numeratorTokenAmount);\n    }\n  }\n\n  /**\n   * @dev Return the denominator token to the recipient\n   *\n   * @param denominatorTokenAmount Amount of the denominator token to transfer\n   * @param recipient Address to transfer the denominator token to\n   */\n  function _returnDenominatorToken(\n    uint256 denominatorTokenAmount,\n    address recipient\n  ) internal {\n    // Call external contracts\n    if (denominatorTokenAmount > 0) {\n      _denominatorToken.safeTransfer(recipient, denominatorTokenAmount);\n    }\n  }\n}\n"
    },
    "contracts/src/utils/auction/VRGDA.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * This file is derived from the Ultrachess project under the Apache 2.0 license.\n * Copyright (C) 2022-2023 Ultrachess team\n *\n * This file is derived from the VRGDAs project under the MIT license.\n * https://github.com/transmissions11/VRGDAs\n *\n * SPDX-License-Identifier: GPL-3.0-or-later AND Apache-2.0 AND MIT\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {wadLn, wadMul, wadExp, unsafeWadMul, toWadUnsafe} from \"solmate/src/utils/SignedWadMath.sol\";\n\n/**\n * @title Variable Rate Gradual Dutch Auction\n */\ncontract VRGDA {\n  //////////////////////////////////////////////////////////////////////////////\n  // State\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Target price for a token, to be scaled according to sales pace\n   *\n   * Represented as an 18 decimal fixed point number.\n   */\n  int256 internal immutable _targetPrice;\n\n  /**\n   * @dev Precomputed constant that allows us to rewrite pow() as an exp()\n   *\n   * Represented as an 18 decimal fixed point number.\n   */\n  int256 internal immutable _decayConstant;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Initialization\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Construct a new VRGDA\n   *\n   * @param targetPrice Target price for a token if sold on pace, scaled by 1e18\n   * @param priceDecayConstant The percent price decays per unit of time with no sales, scaled by 1e18\n   */\n  constructor(int256 targetPrice, int256 priceDecayConstant) {\n    // Initialize state\n    _targetPrice = targetPrice;\n    _decayConstant = wadLn(1e18 - priceDecayConstant);\n\n    // Validate state\n    // The decay constant must be negative for VRGDAs to work\n    require(_decayConstant < 0, \"Nonnegative decay constant\");\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Pricing logic\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Calculate the price of a token according to the VRGDA formula.\n   *\n   * @param timeSinceStart Time passed since the VRGDA began, scaled by 1e18\n   * @param sold The total number of tokens that have been sold so far\n   *\n   * @return The price of a token according to VRGDA, scaled by 1e18\n   */\n  function getVRGDAPrice(\n    int256 timeSinceStart,\n    uint256 sold\n  ) public view virtual returns (uint256) {\n    unchecked {\n      return\n        uint256(\n          wadMul(\n            _targetPrice,\n            wadExp(\n              unsafeWadMul(\n                _decayConstant,\n                // Theoretically calling toWadUnsafe with sold can silently\n                // overflow but under any reasonable circumstance it will never\n                // be large enough. We use sold + 1 as the VRGDA formula's n\n                // param represents the nth token and sold is the n-1th token.\n                timeSinceStart - getTargetSaleTime(toWadUnsafe(sold + 1))\n              )\n            )\n          )\n        );\n    }\n  }\n\n  /**\n   * @dev Given a number of tokens sold, return the target time that number of\n   * tokens should be sold by\n   *\n   * @param sold A number of tokens sold, scaled by 1e18, to get the\n   *             corresponding target sale time for\n   *\n   * @return The target time the tokens should be sold by, scaled by 1e18,\n   *         where the time is relative, such that 0 means the tokens should be\n   *         sold immediately when the VRGDA begins\n   */\n  function getTargetSaleTime(int256 sold) public view virtual returns (int256) {\n    // TODO\n    sold;\n    return 0;\n  }\n}\n"
    },
    "contracts/src/utils/guards/ERC1155EnumerableNonReentrant.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {ReentrancyLibrary} from \"./ReentrancyLibrary.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function\n *\n * Specifically for ERC1155Enumerable.\n */\nabstract contract ERC1155EnumerableNonReentrant {\n  using ReentrancyLibrary for ReentrancyLibrary.ReentrancyStatus;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Constants\n  //////////////////////////////////////////////////////////////////////////////\n\n  // Unique identifier for the ERC1155Enumerable inteface\n  bytes32 private constant ERC1155_ENUMERABLE_ID =\n    bytes32(\"ERC1155EnumerableNonReentrant\");\n\n  //////////////////////////////////////////////////////////////////////////////\n  // State\n  //////////////////////////////////////////////////////////////////////////////\n\n  // Reentrancy status\n  ReentrancyLibrary.ReentrancyStatus private _reentrancyStatus;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Modifiers\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Modifier to prevent reentrant calls to ERC1155Enumerable functions\n   */\n  modifier nonReentrantERC1155Enumerable() {\n    _reentrancyStatus.enter(ERC1155_ENUMERABLE_ID);\n    _;\n    _reentrancyStatus.exit(ERC1155_ENUMERABLE_ID);\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Accessors\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Checks if reentrancy is entered for ERC1155Enumerable\n   *\n   * @return bool True if reentrancy is entered, false otherwise\n   */\n  function _reentrancyGuardEnteredERC1155Enumerable()\n    internal\n    view\n    returns (bool)\n  {\n    return _reentrancyStatus.isEntered(ERC1155_ENUMERABLE_ID);\n  }\n}\n"
    },
    "contracts/src/utils/guards/LPNFTHolderNonReentrant.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {ReentrancyLibrary} from \"./ReentrancyLibrary.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function\n *\n * Specifically for LPNFTHolder.\n */\nabstract contract LPNFTHolderNonReentrant {\n  using ReentrancyLibrary for ReentrancyLibrary.ReentrancyStatus;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Constants\n  //////////////////////////////////////////////////////////////////////////////\n\n  // Unique identifier for the LPNFTHolder interface\n  bytes32 private constant LP_NFT_HOLDER_ID =\n    bytes32(\"LPNFTHolderNonReentrant\");\n\n  //////////////////////////////////////////////////////////////////////////////\n  // State\n  //////////////////////////////////////////////////////////////////////////////\n\n  // Reentrancy status\n  ReentrancyLibrary.ReentrancyStatus private _reentrancyStatus;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Modifiers\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Modifier to prevent reentrant calls to LPNFTHolder functions\n   */\n  modifier nonReentrantLPNFTHolder() {\n    _reentrancyStatus.enter(LP_NFT_HOLDER_ID);\n    _;\n    _reentrancyStatus.exit(LP_NFT_HOLDER_ID);\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Accessors\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Checks if reentrancy is entered for LPNFTHolder\n   *\n   * @return bool True if reentrancy is entered, false otherwise\n   */\n  function _reentrancyGuardEnteredLPNFTHolder() internal view returns (bool) {\n    return _reentrancyStatus.isEntered(LP_NFT_HOLDER_ID);\n  }\n}\n"
    },
    "contracts/src/utils/guards/LPSFTIssuableNonReentrant.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {ReentrancyLibrary} from \"./ReentrancyLibrary.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function\n *\n * Specifically for LPSFTIssuable.\n */\nabstract contract LPSFTIssuableNonReentrant {\n  using ReentrancyLibrary for ReentrancyLibrary.ReentrancyStatus;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Constants\n  //////////////////////////////////////////////////////////////////////////////\n\n  // Unique identifier for the LPSFTIssuable interface\n  bytes32 private constant LP_SFT_ISSUABLE_ID =\n    bytes32(\"LPSFTIssuableNonReentrant\");\n\n  //////////////////////////////////////////////////////////////////////////////\n  // State\n  //////////////////////////////////////////////////////////////////////////////\n\n  // Reentrancy status\n  ReentrancyLibrary.ReentrancyStatus private _reentrancyStatus;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Modifiers\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Modifier to prevent reentrant calls to LPSFTIssuable functions\n   */\n  modifier nonReentrantLPSFTIssuable() {\n    _reentrancyStatus.enter(LP_SFT_ISSUABLE_ID);\n    _;\n    _reentrancyStatus.exit(LP_SFT_ISSUABLE_ID);\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Accessors\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Checks if reentrancy is entered for LPSFTIssuable\n   *\n   * @return bool True if reentrancy is entered, false otherwise\n   */\n  function _reentrancyGuardEnteredLPSFTIssuable() internal view returns (bool) {\n    return _reentrancyStatus.isEntered(LP_SFT_ISSUABLE_ID);\n  }\n}\n"
    },
    "contracts/src/utils/guards/LPSFTNonReentrant.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {ReentrancyLibrary} from \"./ReentrancyLibrary.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function\n *\n * Specifically for LPSFT.\n */\nabstract contract LPSFTNonReentrant {\n  using ReentrancyLibrary for ReentrancyLibrary.ReentrancyStatus;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Constants\n  //////////////////////////////////////////////////////////////////////////////\n\n  // Unique identifier for the LPSFT inteface\n  bytes32 private constant LP_SFT_ID = bytes32(\"LPSFTNonReentrant\");\n\n  //////////////////////////////////////////////////////////////////////////////\n  // State\n  //////////////////////////////////////////////////////////////////////////////\n\n  // Reentrancy status\n  ReentrancyLibrary.ReentrancyStatus private _reentrancyStatus;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Modifiers\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Modifier to prevent reentrant calls to LPSFT functions\n   */\n  modifier nonReentrantLPSFT() {\n    _reentrancyStatus.enter(LP_SFT_ID);\n    _;\n    _reentrancyStatus.exit(LP_SFT_ID);\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Accessors\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Checks if reentrancy is entered for LPSFT\n   *\n   * @return bool True if reentrancy is entered, false otherwise\n   */\n  function _reentrancyGuardEnteredLPSFT() internal view returns (bool) {\n    return _reentrancyStatus.isEntered(LP_SFT_ID);\n  }\n}\n"
    },
    "contracts/src/utils/guards/ReentrancyLibrary.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {StringUtils} from \"../StringUtils.sol\";\n\n/**\n * @dev Library to manage multiple reentrancy locks using unique identifiers\n *\n * This library provides functions to handle reentrancy guards for different\n * interfaces identified by unique bytes32 identifiers. It allows contracts\n * with diamond inheritance hierarchies to implement secure and isolated\n * reentrancy protection.\n */\nlibrary ReentrancyLibrary {\n  //////////////////////////////////////////////////////////////////////////////\n  // Types\n  //////////////////////////////////////////////////////////////////////////////\n\n  // Mapping from unique interface identifier to reentrancy status\n  struct ReentrancyStatus {\n    mapping(bytes32 => uint256) status;\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Constants\n  //////////////////////////////////////////////////////////////////////////////\n\n  // Constants representing reentrancy states\n  uint256 private constant NOT_ENTERED = 1;\n  uint256 private constant ENTERED = 2;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Errors\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Error for reentrant calls\n   *\n   * @param interfaceId The unique identifier for the interface being reentered\n   */\n  error ReentrantCall(string interfaceId);\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Functions\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Checks and sets the reentrancy guard for the provided key preventing\n   * reentry\n   *\n   * @param status The ReentrancyStatus struct\n   * @param interfaceId The unique identifier for the interface\n   */\n  function enter(\n    ReentrancyStatus storage status,\n    bytes32 interfaceId\n  ) internal {\n    if (status.status[interfaceId] == ENTERED) {\n      // Convert interfaceId to human-readable string\n      string memory interfaceIdStr = StringUtils.bytes32ToString(interfaceId);\n\n      revert ReentrantCall(interfaceIdStr);\n    }\n    status.status[interfaceId] = ENTERED;\n  }\n\n  /**\n   * @dev Resets the reentrancy guard for the provided key, allowing future\n   * entry\n   *\n   * @param status The ReentrancyStatus struct\n   * @param interfaceId The unique identifier for the interface\n   */\n  function exit(ReentrancyStatus storage status, bytes32 interfaceId) internal {\n    status.status[interfaceId] = NOT_ENTERED;\n  }\n\n  /**\n   * @dev Returns true if the reentrancy guard is currently set to \"entered\",\n   * which indicates there is a non-reentrant function in the call stack\n   *\n   * @param status The ReentrancyStatus struct\n   * @param interfaceId The unique identifier for the inteface\n   */\n  function isEntered(\n    ReentrancyStatus storage status,\n    bytes32 interfaceId\n  ) internal view returns (bool) {\n    return status.status[interfaceId] == ENTERED;\n  }\n}\n"
    },
    "contracts/src/utils/helpers/UniV3PoolFactory.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * This file is derived from the Ultrachess project under the Apache 2.0 license.\n * Copyright (C) 2022-2023 Ultrachess team\n *\n * SPDX-License-Identifier: GPL-3.0-or-later AND Apache-2.0\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {IUniswapV3Factory} from \"../../../interfaces/uniswap-v3-core/IUniswapV3Factory.sol\";\nimport {IUniswapV3Pool} from \"../../../interfaces/uniswap-v3-core/IUniswapV3Pool.sol\";\n\n/**\n * @dev Helper contract to create a Uniswap V3 pool using a provided\n * IUniswapV3Factory\n *\n * This is a helper contract for the deployment of dependencies on test\n * networks. The pool is created in the constructor and stored in a member\n * variable so that it can be read back without the deployment system having\n * to store or parse transaction receipts.\n *\n * Note: Because upstream Uniswap sources are mixed with our own, a convention\n * is adopted to distinguish between the two. Uniswap sources are prefixed with\n * \"uniswapV3\" and our own are prefixed with \"uniV3\".\n */\ncontract UniV3PoolFactory {\n  /**\n   * @dev The address of the pool for this token pair\n   */\n  IUniswapV3Pool public immutable uniswapV3Pool;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Initialization\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Construct the test pool instance\n   *\n   * @param factory The contract address of the Uniswap V3 factory\n   * @param tokenA One of the two tokens in the desired pool\n   * @param tokenB The other of the two tokens in the desired pool\n   * @param swapFee The fee collected upon every swap in the pool, denominated\n   *                in hundredths of a bip\n   *\n   * The constructor creates a pool for the given two tokens and fee.\n   *\n   * tokenA and tokenB may be passed in either order: token0/token1 or\n   * token1/token0.\n   *\n   * token0 is taken to be the lower address (see UniswapV3Factory.sol).\n   */\n  constructor(address factory, address tokenA, address tokenB, uint24 swapFee) {\n    // Validate parameters\n    require(factory != address(0), \"Invalid factory\");\n    require(tokenA != address(0), \"Invalid tokenA\");\n    require(tokenB != address(0), \"Invalid tokenB\");\n\n    // Call external contracts\n    uniswapV3Pool = IUniswapV3Pool(\n      IUniswapV3Factory(factory).createPool(tokenA, tokenB, swapFee)\n    );\n  }\n}\n"
    },
    "contracts/src/utils/math/LiquidityMath.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * This file is derived from the Ultrachess project under the Apache 2.0 license.\n * Copyright (C) 2022-2023 Ultrachess team\n *\n * SPDX-License-Identifier: GPL-3.0-or-later AND Apache-2.0\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/**\n * @dev Liquidity math for computing the optimal one-sided supply to a\n * liquidity pool\n */\nlibrary LiquidityMath {\n  /**\n   * @dev Compute swap amount needed for adding liquidity to a pool in the\n   * absence of concentrated liquidity (such as a Uniswap V2 pool)\n   *\n   * The goal is to find the optimal swapA to get a corresponding amount\n   * of asset B, so that the proportion of assets the user holds is equal to\n   * the proportion of assets in reserves after swap.\n   *\n   * Calculation:\n   *\n   * The initial constant product is given by:\n   *\n   *   k = reserveA * reserveB\n   *\n   * The swap fee is deducted from the input asset amount, so the new reserveB\n   * should satisfy:\n   *\n   *   k = (reserveA + (1 - fee) * swapA) * reserveB'\n   *\n   * This means the user will receive an amount of asset B equal to:\n   *\n   *   rcvB = reserveB - reserveB'\n   *\n   *        = reserveB - k / (reserveA + (1 - fee) * swapA)\n   *\n   *        = reserveB - reserveA * reserveB / (reserveA + (1 - fee) * swapA)\n   *\n   *        = (1 - fee) * reserveB * swapA / (reserveA + (1 - fee) * swapA)\n   *\n   * The optimal swapA should satisfy the equality constraint on the\n   * user's asset ratio and the reserve's asset ratio:\n   *\n   *   (amountA - swapA) / (reserveA + swapA) = rcvB / reserveB'\n   *\n   * Substituting known variables rcvB and reserveB' and rearranging the\n   * equation yields a quadratic equation in variable swapA as follows:\n   *\n   *   (1 - fee) * (swapA)^2 + ((2 - fee) * reserveA) * swapA - amountA * reserveA = 0\n   *\n   * Solving the above equation for a non-negative root yields:\n   *\n   *   swapA =\n   *     sqrt(((2 - fee) * reserveA)^2 + 4 * (1 - fee) * amountA * reserveA) - (2 - fee) * reserveA\n   *       / (2 * (1 - fee))\n   *\n   * The fee is represented in hundredths of a bip, so we can avoid floating\n   * point numbers by multiplying both the numerator and denominator by 1E6:\n   *\n   * swapA =\n   *   sqrt((2E6 - fee)^2 * reserveA^2 + 4 * 1E6 * (1E6 - fee) * amountA * reserveA) - (2E6 - fee) * reserveA\n   *     / (2 * (1E6 - fee))\n   *\n   * Credit to Zapper Finance for the above derivation.\n   *\n   * @param reserveA The reserve of token A\n   * @param amountA The amount of token A to add\n   * @param swapfee The swap fee of the pool, denominated in hundredths of a bip\n   *\n   * @return swapA The amount of token A to swap for token B\n   */\n  function computeSwapAmountV2(\n    uint256 reserveA,\n    uint256 amountA,\n    uint24 swapfee\n  ) internal pure returns (uint256 swapA) {\n    // prettier-ignore\n    swapA = (\n      Math.sqrt(\n        (\n          (uint256(2E6) - swapfee) * (uint256(2E6) - swapfee) * reserveA * reserveA\n        ) + (\n          uint256(4) * uint256(1E6) * (uint256(1E6) - swapfee) * amountA * reserveA\n        )\n      ) - (\n        (uint256(2E6) - swapfee) * reserveA\n      )\n    ) / (\n      uint256(2) * (uint256(1E6) - swapfee)\n    );\n\n    return swapA;\n  }\n}\n"
    },
    "contracts/src/utils/math/RewardMath.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\n/**\n * @dev Library for calculating rewards for staking contracts\n */\nlibrary RewardMath {\n  uint256 private constant PRECISION = 1e18;\n\n  /**\n   * @dev Calculates the new reward per token based on the time elapsed,\n   * reward rate, and total staked\n   *\n   * Formula is:\n   *\n   *   New Reward Per Token = Reward Per Token Stored +\n   *       ((Time Elapsed * Reward Rate * Precision) / Total Staked)\n   *\n   * @param rewardPerTokenStored The accumulated reward per token up to the last update\n   * @param timeElapsed The amount of time that has elapsed since the last update\n   * @param rewardRate The rate at which rewards are generated per token per second\n   * @param totalStaked The total amount of the staked token\n   *\n   * @return The updated reward per token\n   */\n  function calculateRewardPerToken(\n    uint256 rewardPerTokenStored,\n    uint256 timeElapsed,\n    uint256 rewardRate,\n    uint256 totalStaked\n  ) internal pure returns (uint256) {\n    // Return the previously stored value if no tokens are currently staked\n    if (totalStaked == 0) {\n      return rewardPerTokenStored;\n    }\n\n    // Calculate the additional rewards accumulated per token over the\n    // elapsed time\n    uint256 additionalReward = (timeElapsed * rewardRate * PRECISION) /\n      totalStaked;\n\n    // Sum the previously stored rewards with the newly calculated additional\n    // rewards\n    return rewardPerTokenStored + additionalReward;\n  }\n\n  /**\n   * @dev Calculates the new earned rewards for a user\n   *\n   * Formula is:\n   *\n   *   Earned Rewards = Accrued Rewards +\n   *       ((Staked * (Reward Per Token - User Reward Per Token Paid)) / Precision)\n   *\n   * @param staked The amount of tokens the user has staked\n   * @param rewardPerToken The current calculated reward per token\n   * @param userRewardPerTokenPaid The reward per token value that was last\n   *                               recorded for the user\n   * @param accruedRewards The amount of rewards that have been accrued for\n   *                       the user so far\n   *\n   * @return The total earned rewards\n   */\n  function calculateEarned(\n    uint256 staked,\n    uint256 rewardPerToken,\n    uint256 userRewardPerTokenPaid,\n    uint256 accruedRewards\n  ) internal pure returns (uint256) {\n    // Calculate the reward difference per token since the last user update\n    uint256 rewardDifference = rewardPerToken - userRewardPerTokenPaid;\n\n    // Calculate the new rewards earned based on the user's staked amount and\n    // the reward difference\n    uint256 newRewards = (staked * rewardDifference) / PRECISION;\n\n    // Add the newly calculated rewards to the previously accrued rewards to\n    // get the total\n    return newRewards + accruedRewards;\n  }\n}\n"
    },
    "contracts/src/utils/math/VRGDAMath.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * This file is derived from the Ultrachess project under the Apache 2.0 license.\n * Copyright (C) 2022-2023 Ultrachess team\n *\n * This file is derived from the VRGDAs project under the MIT license.\n * https://github.com/transmissions11/VRGDAs\n *\n * SPDX-License-Identifier: GPL-3.0-or-later AND Apache-2.0 AND MIT\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {wadLn, wadMul, wadExp, unsafeWadMul, toWadUnsafe} from \"solmate/src/utils/SignedWadMath.sol\";\n\n/**\n * @title VRGDAMath\n *\n * @dev Stateless library for performing Variable Rate Gradual Dutch Auction\n * (VRGDA) calculations\n */\nlibrary VRGDAMath {\n  //////////////////////////////////////////////////////////////////////////////\n  // Constants\n  //////////////////////////////////////////////////////////////////////////////\n\n  int256 internal constant ONE_WAD = 1e18;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Pricing logic\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Calculate the price of a token according to the VRGDA formula\n   *\n   * @param targetPrice Target price for a token if sold on pace, scaled by 1e18\n   * @param priceDecayConstant The precomputed decay constant for price decay,\n   *        scaled by 1e18\n   * @param timeSinceStart Time passed since the VRGDA began, scaled by 1e18\n   * @param sold The total number of tokens that have been sold so far\n   *\n   * @return The price of a token according to VRGDA, scaled by 1e18\n   */\n  function getVRGDAPrice(\n    int256 targetPrice,\n    int256 priceDecayConstant,\n    int256 timeSinceStart,\n    uint256 sold\n  ) internal pure returns (uint256) {\n    unchecked {\n      return\n        uint256(\n          wadMul(\n            targetPrice,\n            wadExp(\n              unsafeWadMul(\n                priceDecayConstant,\n                // Theoretically calling toWadUnsafe with sold can silently\n                // overflow but under any reasonable circumstance it will never\n                // be large enough. We use sold + 1 as the VRGDA formula's n\n                // param represents the nth token and sold is the n-1th token.\n                timeSinceStart -\n                  getTargetSaleTime(toWadUnsafe(sold + 1), priceDecayConstant)\n              )\n            )\n          )\n        );\n    }\n  }\n\n  /**\n   * @dev Given a number of tokens sold, return the target time that number\n   * of tokens should be sold by\n   *\n   * @param sold A number of tokens sold, scaled by 1e18, to get the\n   *        corresponding target sale time for\n   * @param priceDecayConstant The precomputed decay constant for price decay,\n   *        scaled by 1e18\n   *\n   * @return The target time the tokens should be sold by, scaled by 1e18,\n   *         where the time is relative, such that 0 means the tokens should be sold immediately.\n   */\n  function getTargetSaleTime(\n    int256 sold,\n    int256 priceDecayConstant\n  ) internal pure returns (int256) {\n    // Example: In future, implement logic for target sale time based on\n    // VRGDA formula using the price decay constant. Return the expected\n    // target sale time for optimization. This function can be optimized\n    // further by caching intermediate values if required.\n\n    // Placeholder implementation:\n    return wadLn(sold + 1) / priceDecayConstant;\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Utility functions for initialization\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Precompute the decay constant for a given price decay rate to\n   * optimize performance\n   *\n   * @param priceDecayRate The percentage rate at which the price decays per\n   *        unit of time, scaled by 1e18\n   *\n   * @return The precomputed decay constant for use in VRGDA pricing logic.\n   */\n  function precomputeDecayConstant(\n    int256 priceDecayRate\n  ) internal pure returns (int256) {\n    // The decay constant is precomputed using the natural log to avoid\n    // recalculating during price evaluation\n    return wadLn(ONE_WAD - priceDecayRate);\n  }\n}\n"
    },
    "contracts/src/utils/StringUtils.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\n/**\n * @dev Library providing string manipulation utilities\n */\nlibrary StringUtils {\n  /**\n   * @dev Converts a bytes32 value to its ASCII string representation\n   *\n   * @param _bytes32 The bytes32 value to convert\n   *\n   * @return The string representation of the bytes32 value\n   */\n  function bytes32ToString(\n    bytes32 _bytes32\n  ) internal pure returns (string memory) {\n    uint8 i = 0;\n\n    // Find the first null byte (0x00)\n    while (i < 32 && _bytes32[i] != 0) {\n      i++;\n    }\n\n    // Create a bytes array with the determined length\n    bytes memory bytesArray = new bytes(i);\n\n    // Copy each byte to the array\n    for (uint8 j = 0; j < i; j++) {\n      bytesArray[j] = _bytes32[j];\n    }\n\n    return string(bytesArray);\n  }\n}\n"
    },
    "contracts/test/token/erc1155/extensions/TestERC1155Enumerable.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * This file is derived from the Ultrachess project under the Apache 2.0 license.\n * Copyright (C) 2022-2023 Ultrachess team\n *\n * SPDX-License-Identifier: GPL-3.0-or-later AND Apache-2.0\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {ERC1155Enumerable} from \"../../../../src/token/ERC1155/extensions/ERC1155Enumerable.sol\";\nimport {ERC1155Helpers} from \"../../../../src/token/ERC1155/utils/ERC1155Helpers.sol\";\n\n/**\n * @title ERC-1155: Multi Token Standard, mintable extension for test purposes\n *\n * @dev Extension of {ERC1155Enumerable} that allows anyone to mint NFTs to\n * arbitrary accounts.\n *\n * FOR TESTING ONLY.\n */\ncontract TestERC1155Enumerable is ERC1155Enumerable {\n  //////////////////////////////////////////////////////////////////////////////\n  // Initialization\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Constructor\n   */\n  constructor() {\n    initialize();\n  }\n\n  /**\n   * @dev Initializer\n   */\n  function initialize() public initializer {\n    __ERC1155_init(\"\");\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Minting interface\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Mints a new NFT\n   *\n   * @param account The account to mint an NFT to\n   * @param nftTokenId The token ID of the minted NFT\n   */\n  function mintNft(address account, uint256 nftTokenId) external {\n    // Call ancestor\n    _mint(account, nftTokenId, 1, \"\");\n  }\n\n  /**\n   * @dev Mints a batch of NFTs\n   *\n   * @param account The account to mint NFTs to\n   * @param nftTokenIds The token IDs of the minted NFTs\n   */\n  function batchMintNFT(\n    address account,\n    uint256[] memory nftTokenIds\n  ) external {\n    // Translate parameters\n    uint256[] memory tokenAmounts = ERC1155Helpers.getAmountArray(\n      nftTokenIds.length\n    );\n\n    // Call ancestor\n    _mintBatch(account, nftTokenIds, tokenAmounts, \"\");\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Burning interface\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Burns an existing NFT\n   *\n   * @param account The account to burn an NFT from\n   * @param nftTokenId The token ID of the NFT to burn\n   */\n  function burnNft(address account, uint256 nftTokenId) external {\n    // Call ancestor\n    _burn(account, nftTokenId, 1);\n  }\n\n  /**\n   * @dev Burns a batch of existing NFTs\n   *\n   * @param account The account to burn NFTs from\n   * @param nftTokenIds The token IDs of the NFTs to burn\n   */\n  function batchBurnNFT(\n    address account,\n    uint256[] memory nftTokenIds\n  ) external {\n    // Translate parameters\n    uint256[] memory tokenAmounts = ERC1155Helpers.getAmountArray(\n      nftTokenIds.length\n    );\n\n    // Call ancestor\n    _burnBatch(account, nftTokenIds, tokenAmounts);\n  }\n}\n"
    },
    "contracts/test/token/erc20/extensions/TestERC20Mintable.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * This file is derived from the Ultrachess project under the Apache 2.0 license.\n * Copyright (C) 2022-2023 Ultrachess team\n *\n * SPDX-License-Identifier: GPL-3.0-or-later AND Apache-2.0\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @title ERC-20: Token standard, mintable extension for test purposes\n *\n * @dev Extension of OpenZeppelin's {ERC20} that allows anyone to mint tokens\n * to arbitrary accounts.\n *\n * FOR TESTING ONLY.\n */\nabstract contract TestERC20Mintable is ERC20 {\n  //////////////////////////////////////////////////////////////////////////////\n  // Minting interface\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Creates `amount` tokens and assigns them to `account`, increasing\n   * the total supply.\n   */\n  function mint(address account, uint256 amount) external {\n    // Call ancestor\n    _mint(account, amount);\n  }\n}\n"
    },
    "contracts/test/token/erc20/USDC.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * This file is derived from the Ultrachess project under the Apache 2.0 license.\n * Copyright (C) 2022-2023 Ultrachess team\n *\n * SPDX-License-Identifier: GPL-3.0-or-later AND Apache-2.0\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport \"./extensions/TestERC20Mintable.sol\";\n\n/**\n * @title USD Coin\n *\n * @dev Used for USDC functionality in test suite\n *\n * FOR TESTING ONLY.\n */\ncontract USDC is TestERC20Mintable {\n  //////////////////////////////////////////////////////////////////////////////\n  // Constants\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev The ERC 20 token name used by wallets to identify the token\n   */\n  string private constant TOKEN_NAME = \"Funny USD Coin\";\n\n  /**\n   * @dev The ERC 20 token symbol used as an abbreviation of the token, such\n   * as BTC, ETH, AUG or SJCX.\n   */\n  string private constant TOKEN_SYMBOL = \"USDC\";\n\n  /**\n   * @dev The number of decimals, typically 18 for most ERC-20 tokens\n   */\n  uint8 private constant DECIMALS = 6;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Initialization\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Initializes the token with a name and symbol\n   */\n  // solhint-disable-next-line no-empty-blocks\n  constructor() ERC20(TOKEN_NAME, TOKEN_SYMBOL) {}\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation of {IERC20Metadata} via {TestERC20Mintable}\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev See {IERC20Metadata-decimals}\n   */\n  // slither-disable-next-line external-function\n  function decimals() public pure override returns (uint8) {\n    return DECIMALS;\n  }\n}\n"
    },
    "contracts/test/token/erc20/WETH.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * This file is derived from the Ultrachess project under the Apache 2.0 license.\n * Copyright (C) 2022-2023 Ultrachess team\n *\n * SPDX-License-Identifier: GPL-3.0-or-later AND Apache-2.0\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport \"../../../depends/canonical-weth/WETH9.sol\";\n\n/**\n * @title W-ETH\n *\n * @dev Used for WETH functionality in test suite\n *\n * FOR TESTING ONLY.\n */\ncontract WETH is WETH9 {\n  /**\n   * @dev Constructor\n   */\n  constructor() {\n    // Initialize {WETH9}\n    name = \"Funny Wrapped Ether\";\n    symbol = \"W-ETH\";\n  }\n}\n"
    },
    "contracts/test/token/routes/TestGameTokenStaker.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ERC721Holder} from \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport {IERC20Minimal} from \"../../../interfaces/uniswap-v3-core/IERC20Minimal.sol\";\nimport {IUniswapV3Pool} from \"../../../interfaces/uniswap-v3-core/IUniswapV3Pool.sol\";\nimport {INonfungiblePositionManager} from \"../../../interfaces/uniswap-v3-periphery/INonfungiblePositionManager.sol\";\nimport {IUniswapV3Staker} from \"../../../interfaces/uniswap-v3-staker/IUniswapV3Staker.sol\";\n\nimport {LPSFT} from \"../../../src/token/ERC1155/LPSFT.sol\";\n\nimport {IGameTokenPooler} from \"../../../src/interfaces/token/routes/IGameTokenPooler.sol\";\n\n/**\n * @dev Token router to stake a Uniswap V3 LP-NFT in exchange for liquidity\n * rewards and market-making fees\n */\nabstract contract TestGameTokenStaker is\n  Context,\n  Ownable,\n  ReentrancyGuard,\n  ERC721Holder\n{\n  using SafeERC20 for IERC20;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Events\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Emitted when a new incentive is created for the POW1 staker\n   *\n   * @param creator The address of the creator\n   * @param rewardToken The reward token\n   * @param rewardAmount The reward amount\n   * @param startTime The start time of the incentive\n   * @param endTime The end time of the incentive\n   * @param refundee The incentive's refundee address\n   */\n  event POW1IncentiveCreated(\n    address indexed creator,\n    address rewardToken,\n    uint256 rewardAmount,\n    uint256 startTime,\n    uint256 endTime,\n    address indexed refundee\n  );\n\n  /**\n   * @dev Emitted when a Uniswap V3 LP-NFT is staked\n   *\n   * @param sender The sender of the tokens being paid\n   * @param recipient The address of the recipient of the LP-NFT\n   * @param nftAddress The address of the NFT manager contract\n   * @param lpNftTokenId The ID of the NFT\n   */\n  event POW1LpNftStaked(\n    address indexed sender,\n    address indexed recipient,\n    address nftAddress,\n    uint256 lpNftTokenId\n  );\n\n  /**\n   * @dev Emitted when a Uniswap V3 LP-NFT is unstaked\n   *\n   * @param sender The sender of the LP-NFT\n   * @param nftAddress The address of the NFT manager contract\n   * @param lpNftTokenId The ID of the NFT\n   * @param rewardClaimed The amount of the game token claimed as a reward for\n   *                      staking the LP-NFT\n   * @param assetTokenReturned The amount of the asset token returned to the\n   *                           recipient\n   */\n  event POW1LpNftUnstaked(\n    address indexed sender,\n    address indexed recipient,\n    address nftAddress,\n    uint256 lpNftTokenId,\n    uint256 rewardClaimed,\n    uint256 assetTokenReturned\n  );\n\n  /**\n   * @dev Emitted when a new incentive is created for the POW5 staker\n   *\n   * @param creator The address of the creator\n   * @param rewardToken The reward token\n   * @param rewardAmount The reward amount\n   * @param startTime The start time of the incentive\n   * @param endTime The end time of the incentive\n   * @param refundee The incentive's refundee address\n   */\n  event POW1LpNftIncentiveCreated(\n    address indexed creator,\n    address rewardToken,\n    uint256 rewardAmount,\n    uint256 startTime,\n    uint256 endTime,\n    address indexed refundee\n  );\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Routes\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev The game token\n   */\n  IERC20 private immutable _gameToken;\n\n  /**\n   * @dev The asset token\n   */\n  IERC20 private immutable _assetToken;\n\n  /**\n   * @dev The reward token\n   */\n  IERC20 private immutable _rewardToken;\n\n  /**\n   * @dev The upstream Uniswap V3 pool for the token pair\n   */\n  IUniswapV3Pool private immutable _gameTokenPool;\n\n  /**\n   * @dev The pooler for the token pair\n   */\n  IGameTokenPooler private immutable _gameTokenPooler;\n\n  /**\n   * @dev The upstream Uniswap V3 NFT manager\n   */\n  INonfungiblePositionManager private immutable _uniswapV3NftManager;\n\n  /**\n   * @dev The upstream Uniswap V3 staker\n   */\n  IUniswapV3Staker private immutable _uniswapV3Staker;\n\n  /**\n   * @dev The Powell Nickels LP-SFT contract\n   */\n  LPSFT private immutable _lpSft;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // State\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev True if the incentive has been created, false otherwise\n   */\n  bool private _incentiveCreated = false;\n\n  /**\n   * @dev The Uniswap V3 staker incentive key, calculated when the incentive is\n   * created\n   */\n  IUniswapV3Staker.IncentiveKey private _incentiveKey;\n\n  /**\n   * @dev The Uniswap V3 staker incentive ID, calculated when the incentive is\n   * created\n   */\n  bytes32 private _incentiveId;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Initialization\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Initializes the contract\n   *\n   * @param owner_ The initial owner of the contract\n   * @param gameToken_ The address of the game token\n   * @param assetToken_ The address of the asset token\n   * @param rewardToken_ The address of the reward token\n   * @param gameTokenPool_ The address of the pool for the token pair\n   * @param gameTokenPooler_ The address of the pooler for the token pair\n   * @param uniswapV3NftManager_ The address of the upstream Uniswap V3 NFT\n   *        manager\n   * @param uniswapV3Staker_ The address of the upstream Uniswap V3 staker\n   * @param lpSft_ The address of the LP-SFT contract\n   */\n  constructor(\n    address owner_,\n    address gameToken_,\n    address assetToken_,\n    address rewardToken_,\n    address gameTokenPool_,\n    address gameTokenPooler_,\n    address uniswapV3NftManager_,\n    address uniswapV3Staker_,\n    address lpSft_\n  ) Ownable(owner_) {\n    // Validate parameters\n    require(gameToken_ != address(0), \"Invalid game token\");\n    require(assetToken_ != address(0), \"Invalid asset token\");\n    require(rewardToken_ != address(0), \"Invalid reward token\");\n    require(gameTokenPool_ != address(0), \"Invalid game token pool\");\n    require(gameTokenPooler_ != address(0), \"Invalid game token pooler\");\n    require(uniswapV3NftManager_ != address(0), \"Invalid NFT manager\");\n    require(uniswapV3Staker_ != address(0), \"Invalid staker\");\n    require(lpSft_ != address(0), \"Invalid LPSFT\");\n\n    // Initialize routes\n    _gameToken = IERC20(gameToken_);\n    _assetToken = IERC20(assetToken_);\n    _rewardToken = IERC20(rewardToken_);\n    _gameTokenPool = IUniswapV3Pool(gameTokenPool_);\n    _gameTokenPooler = IGameTokenPooler(gameTokenPooler_);\n    _uniswapV3NftManager = INonfungiblePositionManager(uniswapV3NftManager_);\n    _uniswapV3Staker = IUniswapV3Staker(uniswapV3Staker_);\n    _lpSft = LPSFT(lpSft_);\n  }\n\n  /**\n   * @dev Initializes the staker incentive\n   *\n   * @param rewardAmount The reward to distribute in the incentive\n   *\n   * TODO: Allow creating multiple incentives?\n   */\n  function createIncentive(uint256 rewardAmount) public onlyOwner {\n    // Validate state\n    require(!_incentiveCreated, \"Incentive already created\");\n\n    // Calculate the incentive key\n    IUniswapV3Staker.IncentiveKey memory incentiveKey = _createIncentiveKey();\n\n    // Update state\n    _incentiveCreated = true;\n    _incentiveKey = incentiveKey;\n\n    // See IncentiveId.sol in the Uniswap V3 staker dependency\n    _incentiveId = keccak256(abi.encode(incentiveKey));\n\n    // Transfer the reward to this contract\n    _rewardToken.safeTransferFrom(_msgSender(), address(this), rewardAmount);\n\n    // Approve the Uniswap V3 staker to spend the reward\n    _rewardToken.safeIncreaseAllowance(address(_uniswapV3Staker), rewardAmount);\n\n    // Create the incentive\n    _uniswapV3Staker.createIncentive(incentiveKey, rewardAmount);\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // External interface for staking LP-NFTs\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Mints and stakes a Uniswap V3 LP-NFT, depositing the game token\n   *\n   * @param gameTokenAmount The amount of the game token to deposit\n   * @param recipient The recient of the LP-NFT\n   *\n   * @return lpNftTokenId The ID of the minted LP-NFT\n   */\n  function stakeLpNftWithGameToken(\n    uint256 gameTokenAmount,\n    address recipient\n  ) public nonReentrant returns (uint256 lpNftTokenId) {\n    // Validate parameters\n    require(recipient != address(0), \"Invalid recipient\");\n\n    // Receive the game token from the caller\n    _receiveTokens(gameTokenAmount, 0);\n\n    // Mint the LP-NFT\n    lpNftTokenId = _gameTokenPooler.mintLpNftWithGameToken(\n      gameTokenAmount,\n      address(this)\n    );\n\n    // Return the LP-SFT and the game token dust\n    _returnSftAndDust(lpNftTokenId, recipient);\n\n    return lpNftTokenId;\n  }\n\n  /**\n   * @dev Mints and stakes a Uniswap V3 LP-NFT, depositing the asset token\n   *\n   * @param assetTokenAmount The amounts of the asset token to deposit\n   * @param recipient The recient of the LP-NFT\n   *\n   * @return lpNftTokenId The ID of the minted LP-NFT\n   */\n  function stakeLpNftWithAssetToken(\n    uint256 assetTokenAmount,\n    address recipient\n  ) public nonReentrant returns (uint256 lpNftTokenId) {\n    // Validate parameters\n    require(recipient != address(0), \"Invalid recipient\");\n\n    // Receive the asset token from the caller\n    _receiveTokens(0, assetTokenAmount);\n\n    // Mint the LP-NFT\n    lpNftTokenId = _gameTokenPooler.mintLpNftWithAssetToken(\n      assetTokenAmount,\n      address(this)\n    );\n\n    // Return the LP-SFT and the game token dust\n    _returnSftAndDust(lpNftTokenId, recipient);\n\n    return lpNftTokenId;\n  }\n\n  /**\n   * @dev Mints and stakes a Uniswap V3 LP-NFT without performing a token swap\n   *\n   * @param gameTokenAmount The amount of the game token to deposit\n   * @param assetTokenAmount The amounts of the asset token to deposit\n   * @param recipient The recient of the LP-NFT\n   *\n   * @return lpNftTokenId The ID of the minted LP-NFT\n   */\n  function stakeLpNftImbalance(\n    uint256 gameTokenAmount,\n    uint256 assetTokenAmount,\n    address recipient\n  ) public nonReentrant returns (uint256 lpNftTokenId) {\n    // Validate parameters\n    require(recipient != address(0), \"Invalid recipient\");\n\n    // Receive tokens from the caller\n    _receiveTokens(gameTokenAmount, assetTokenAmount);\n\n    // Mint the LP-NFT\n    lpNftTokenId = _gameTokenPooler.mintLpNftImbalance(\n      gameTokenAmount,\n      assetTokenAmount,\n      address(this)\n    );\n\n    // Return the LP-SFT and the game token dust\n    _returnSftAndDust(lpNftTokenId, recipient);\n\n    return lpNftTokenId;\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // External interface for unstaking LP-NFTs\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Unstakes an LP-NFT and returns the underlying liquidity as the asset\n   * token\n   *\n   * Instead of burning the empty NFT, it is transfered to the recipient as a\n   * keepsake.\n   *\n   * @param lpNftTokenId The ID of the LP-NFT\n   * @param recipient The recipient of the asset token and empty LP-NFT\n   *\n   * @return assetTokenReturned The total amount of the asset token\n   *                            to the recipient\n   */\n  function unstakeLpNft(\n    uint256 lpNftTokenId,\n    address recipient\n  ) public nonReentrant returns (uint256 assetTokenReturned) {\n    // Validate parameters\n    require(recipient != address(0), \"Invalid recipient\");\n\n    // Validate ownership\n    require(\n      _lpSft.balanceOf(_msgSender(), lpNftTokenId) == 1,\n      \"Must own voucher\"\n    );\n\n    // Burn the voucher for the LP-NFT\n    _lpSft.burn(_msgSender(), lpNftTokenId);\n\n    // Read state\n    uint256 rewardBefore = _uniswapV3Staker.rewards(\n      _incentiveKey.rewardToken,\n      address(this)\n    );\n\n    // Unstake the LP-NFT\n    _uniswapV3Staker.unstakeToken(_incentiveKey, lpNftTokenId);\n\n    // Read state\n    uint256 rewardAfter = _uniswapV3Staker.rewards(\n      _incentiveKey.rewardToken,\n      address(this)\n    );\n\n    // Claim the reward\n    // slither-disable-next-line unused-return\n    _uniswapV3Staker.claimReward(\n      _incentiveKey.rewardToken,\n      address(this),\n      rewardAfter - rewardBefore\n    );\n\n    // Withdraw the LP-NFT to the pooler so that it can collect the liquidity\n    _uniswapV3Staker.withdrawToken(lpNftTokenId, address(_gameTokenPooler), \"\");\n\n    // Withdraw the liquidity. This returns the LP-NFT to the staker.\n    assetTokenReturned = _gameTokenPooler.collectFromLpNft(\n      lpNftTokenId,\n      address(this)\n    );\n\n    // Transfer the empty LP-NFT to the recipient as a keepsake\n    _uniswapV3NftManager.safeTransferFrom(\n      address(this),\n      recipient,\n      lpNftTokenId\n    );\n\n    // Return the asset token to the recipient\n    _returnAssetToken(recipient, assetTokenReturned);\n\n    return assetTokenReturned;\n  }\n\n  /**\n   * @dev Collects everything and returns the empty LP-NFT in one transaction\n   *\n   * @param lpNftTokenId The ID of the LP-NFT\n   *\n   * @return assetTokenReturned The total amount of the asset token returned\n   *                            to the recipient\n   */\n  function exit(\n    uint256 lpNftTokenId\n  ) public returns (uint256 assetTokenReturned) {\n    // Unstake and transfer the LP-NFT\n    assetTokenReturned = unstakeLpNft(lpNftTokenId, _msgSender());\n\n    return assetTokenReturned;\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Public accessors\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Get the staking incentive\n   *\n   * @return totalRewardUnclaimed The amount of reward token not yet claimed by\n   *                              users\n   * @return totalSecondsClaimedX128 Total liquidity-seconds claimed,\n   *                                 represented as a UQ32.128\n   * @return numberOfStakes The count of deposits that are currently staked for\n   *                        the incentive\n   */\n  function getIncentive()\n    public\n    view\n    returns (\n      uint256 totalRewardUnclaimed,\n      uint160 totalSecondsClaimedX128,\n      uint96 numberOfStakes\n    )\n  {\n    // Validate state\n    require(_incentiveCreated, \"Incentive not created\");\n\n    // Call external contract\n    // slither-disable-next-line unused-return\n    return _uniswapV3Staker.incentives(_incentiveId);\n  }\n\n  /**\n   * @dev Get information about a deposited LP-NFT\n   *\n   * @return owner_ The owner of the deposited LP-NFT\n   * @return numberOfStakes Counter of how many incentives for which the\n   *                        liquidity is staked\n   * @return tickLower The lower tick of the range\n   * @return tickUpper The upper tick of the range\n   */\n  function getDeposit(\n    uint256 tokenId\n  )\n    public\n    view\n    returns (\n      address owner_,\n      uint48 numberOfStakes,\n      int24 tickLower,\n      int24 tickUpper\n    )\n  {\n    // Call external contract\n    (owner_, numberOfStakes, tickLower, tickUpper) = _uniswapV3Staker.deposits(\n      tokenId\n    );\n\n    // Validate result\n    require(owner_ == address(this), \"Invalid owner\");\n\n    // Translate result\n    owner_ = _lpSft.ownerOf(tokenId);\n\n    return (owner_, numberOfStakes, tickLower, tickUpper);\n  }\n\n  /**\n   * @dev Get information about a staked liquidity NFT\n   *\n   * @param tokenId The ID of the staked token\n   *\n   * @return secondsPerLiquidityInsideInitialX128 secondsPerLiquidity\n   *                                              represented as a UQ32.128\n   * @return liquidity The amount of liquidity in the NFT as of the last time\n   *                   the rewards were computed\n   */\n  function getStake(\n    uint256 tokenId\n  )\n    public\n    view\n    returns (uint160 secondsPerLiquidityInsideInitialX128, uint128 liquidity)\n  {\n    // Validate state\n    require(_incentiveCreated, \"Incentive not created\");\n\n    // Call external contract\n    // slither-disable-next-line unused-return\n    return _uniswapV3Staker.stakes(tokenId, _incentiveId);\n  }\n\n  /**\n   * @dev Returns amounts of reward tokens owed to a given address according\n   * to the last time all stakes were updated\n   *\n   * @param owner_ The owner for which the rewards owed are checked\n   *\n   * @return rewardsOwed The amount of the reward token claimable by the owner\n   */\n  function getRewardsOwed(\n    address owner_\n  ) public view returns (uint256 rewardsOwed) {\n    // Validate state\n    require(_incentiveCreated, \"Incentive not created\");\n\n    // Call external contract\n    return _uniswapV3Staker.rewards(_incentiveKey.rewardToken, owner_);\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Public mutators\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Calculates the reward amount that will be received for the given stake\n   *\n   * @param tokenId The ID of the token\n   *\n   * @return reward The reward accrued to the NFT for the given incentive thus\n   *                far\n   */\n  function getRewardInfo(\n    uint256 tokenId\n  ) public returns (uint256 reward, uint160 secondsInsideX128) {\n    // Validate state\n    require(_incentiveCreated, \"Incentive not created\");\n\n    // Call external contract\n    // slither-disable-next-line unused-return\n    return _uniswapV3Staker.getRewardInfo(_incentiveKey, tokenId);\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Private interface\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Transfer tokens to this contract and approve the UniV3 Pooler to\n   * spend tokens\n   *\n   * @param gameTokenAmount The amount of the game token to transfer\n   * @param assetTokenAmount The amount of the asset token to transfer\n   */\n  function _receiveTokens(\n    uint256 gameTokenAmount,\n    uint256 assetTokenAmount\n  ) private {\n    // Call external contracts\n    if (gameTokenAmount > 0) {\n      _gameToken.safeTransferFrom(_msgSender(), address(this), gameTokenAmount);\n      _gameToken.safeIncreaseAllowance(\n        address(_gameTokenPooler),\n        gameTokenAmount\n      );\n    }\n    if (assetTokenAmount > 0) {\n      _assetToken.safeTransferFrom(\n        _msgSender(),\n        address(this),\n        assetTokenAmount\n      );\n      _assetToken.safeIncreaseAllowance(\n        address(_gameTokenPooler),\n        assetTokenAmount\n      );\n    }\n  }\n\n  /**\n   * @dev Return the LP-SFT, along with the dust, to the recipient\n   *\n   * @param lpNftTokenId The ID of the LP-NFT\n   * @param recipient The recipient of the LP-SFT and dust\n   */\n  function _returnSftAndDust(uint256 lpNftTokenId, address recipient) private {\n    // Mint the recipient a voucher for the LP-NFT. This must be held by the\n    // sender when unstaking the NFT.\n    _lpSft.mint(recipient, lpNftTokenId, \"\");\n\n    // Send the LP-NFT to the Uniswap V3 staker contract and automatically\n    // stake it\n    _uniswapV3NftManager.safeTransferFrom(\n      address(this),\n      address(_uniswapV3Staker),\n      lpNftTokenId,\n      abi.encode(_incentiveKey)\n    );\n\n    // Return dust to the recipient\n    uint256 gameTokenDust = _gameToken.balanceOf(address(this));\n    if (gameTokenDust > 0) {\n      _gameToken.safeTransfer(recipient, gameTokenDust);\n    }\n  }\n\n  /**\n   * @dev Return the asset token to the recipient\n   *\n   * @param recipient The recipient of the asset token\n   * @param assetTokenAmount The amount of the asset token to return\n   */\n  function _returnAssetToken(\n    address recipient,\n    uint256 assetTokenAmount\n  ) private {\n    // Call external contracts\n    if (assetTokenAmount > 0)\n      _assetToken.safeTransfer(recipient, assetTokenAmount);\n  }\n\n  /**\n   * @dev Returns the incentive key for the Uniswap V3 staker\n   */\n  function _createIncentiveKey()\n    private\n    view\n    returns (IUniswapV3Staker.IncentiveKey memory)\n  {\n    return\n      IUniswapV3Staker.IncentiveKey({\n        rewardToken: IERC20Minimal(address(_rewardToken)),\n        pool: _gameTokenPool,\n        startTime: block.timestamp,\n        endTime: block.timestamp + 1 weeks, // TODO\n        refundee: address(this)\n      });\n  }\n}\n"
    },
    "contracts/test/token/routes/TestPOW1MarketStaker.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * This file is derived from the Ultrachess project under the Apache 2.0 license.\n * Copyright (C) 2022-2023 Ultrachess team\n *\n * SPDX-License-Identifier: GPL-3.0-or-later AND Apache-2.0\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {TestGameTokenStaker} from \"./TestGameTokenStaker.sol\";\n\n/**\n * @dev Token router send to liquidity to the POW1 pool in exchange for an\n *      LP-SFT\n */\ncontract TestPOW1MarketStaker is TestGameTokenStaker {\n  //////////////////////////////////////////////////////////////////////////////\n  // Initialization\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Initializes the contract\n   *\n   * @param owner_ The initial owner of the contract\n   * @param pow1Token_ The address of the POW1 token\n   * @param marketToken_ The address of the market token\n   * @param rewardToken_ The address of the reward token\n   * @param pow1MarketPool_ The address of the pool for the token pair\n   * @param pow1MarketPooler_ The address of the pooler for the token pair\n   * @param uniswapV3NftManager_ The address of the upstream Uniswap V3 NFT\n   *        manager\n   * @param uniswapV3Staker_ The address of the upstream Uniswap V3 staker\n   * @param lpSft_ The address of the LP-SFT contract\n   */\n  constructor(\n    address owner_,\n    address pow1Token_,\n    address marketToken_,\n    address rewardToken_,\n    address pow1MarketPool_,\n    address pow1MarketPooler_,\n    address uniswapV3NftManager_,\n    address uniswapV3Staker_,\n    address lpSft_\n  )\n    TestGameTokenStaker(\n      owner_,\n      pow1Token_,\n      marketToken_,\n      rewardToken_,\n      pow1MarketPool_,\n      pow1MarketPooler_,\n      uniswapV3NftManager_,\n      uniswapV3Staker_,\n      lpSft_\n    )\n  {}\n}\n"
    },
    "contracts/test/token/routes/TestPOW5StableStaker.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * This file is derived from the Ultrachess project under the Apache 2.0 license.\n * Copyright (C) 2022-2023 Ultrachess team\n *\n * SPDX-License-Identifier: GPL-3.0-or-later AND Apache-2.0\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {TestGameTokenStaker} from \"./TestGameTokenStaker.sol\";\n\n/**\n * @dev Token router send to liquidity to the POW5 pool in exchange for an\n * LP-SFT\n */\ncontract TestPOW5StableStaker is TestGameTokenStaker {\n  //////////////////////////////////////////////////////////////////////////////\n  // Initialization\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @dev Initializes the contract\n   *\n   * @param owner_ The initial owner of the contract\n   * @param pow5Token_ The address of the POW5 token\n   * @param stableToken_ The address of the stable token\n   * @param rewardToken_ The address of the reward token\n   * @param pow5StablePool_ The address of the pool for the token pair\n   * @param pow5StablePooler_ The address of the pooler for the token pair\n   * @param uniswapV3NftManager_ The address of the upstream Uniswap V3 NFT\n   *        manager\n   * @param uniswapV3Staker_ The address of the upstream Uniswap V3 staker\n   * @param lpSft_ The address of the LP-SFT contract\n   */\n  constructor(\n    address owner_,\n    address pow5Token_,\n    address stableToken_,\n    address rewardToken_,\n    address pow5StablePool_,\n    address pow5StablePooler_,\n    address uniswapV3NftManager_,\n    address uniswapV3Staker_,\n    address lpSft_\n  )\n    TestGameTokenStaker(\n      owner_,\n      pow5Token_,\n      stableToken_,\n      rewardToken_,\n      pow5StablePool_,\n      pow5StablePooler_,\n      uniswapV3NftManager_,\n      uniswapV3Staker_,\n      lpSft_\n    )\n  {}\n}\n"
    },
    "contracts/test/utils/math/TestLiquidityMath.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * This file is derived from the Ultrachess project under the Apache 2.0 license.\n * Copyright (C) 2022-2023 Ultrachess team\n *\n * SPDX-License-Identifier: GPL-3.0-or-later AND Apache-2.0\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport \"../../../src/utils/math/LiquidityMath.sol\";\n\n/**\n * @dev Contract wrapper for testing liquidity math\n */\ncontract TestLiquidityMath {\n  /**\n   * @dev See {LiquidityMath-computeSwapAmountV2}\n   */\n  function computeSwapAmountV2(\n    uint256 reserveA,\n    uint256 amountA,\n    uint24 swapFee\n  ) external pure returns (uint256) {\n    return LiquidityMath.computeSwapAmountV2(reserveA, amountA, swapFee);\n  }\n}\n"
    },
    "contracts/test/utils/math/TestRewardMath.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {RewardMath} from \"../../../src/utils/math/RewardMath.sol\";\n\n/**\n * @dev Helper contract for RewardMath library testing\n */\ncontract TestRewardMath {\n  /**\n   * @dev See {RewardMath-calculateRewardPerToken}\n   */\n  function calculateRewardPerToken(\n    uint256 rewardPerTokenStored,\n    uint256 lastUpdateTime,\n    uint256 rewardRate,\n    uint256 totalStaked\n  ) external pure returns (uint256) {\n    return\n      RewardMath.calculateRewardPerToken(\n        rewardPerTokenStored,\n        lastUpdateTime,\n        rewardRate,\n        totalStaked\n      );\n  }\n\n  /**\n   * @dev See {RewardMath-calculateEarned}\n   */\n  function calculateEarned(\n    uint256 staked,\n    uint256 rewardPerToken,\n    uint256 userRewardPerTokenPaid,\n    uint256 accruedRewards\n  ) external pure returns (uint256) {\n    return\n      RewardMath.calculateEarned(\n        staked,\n        rewardPerToken,\n        userRewardPerTokenPaid,\n        accruedRewards\n      );\n  }\n}\n"
    },
    "contracts/test/utils/math/TestTickMath.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * This file is derived from the Uniswap V3 project after the BSL lapsed\n * into the GPL v2 license on 2023/04/01.\n *\n * SPDX-License-Identifier: GPL-3.0-or-later AND GPL-2.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {TickMath} from \"../../../depends/uniswap-v3-core/libraries/TickMath.sol\";\n\n/**\n * @dev Helper contract for testing Uniswap V3 tick math computation\n */\ncontract TestTickMath {\n  /**\n   * @dev The minimum tick that may be passed to {getSqrtRatioAtTick}\n   *\n   * Computed from log base 1.0001 of 2**-128.\n   */\n  int24 public constant MIN_TICK = TickMath.MIN_TICK;\n\n  /**\n   * @dev The maximum tick that may be passed to {getSqrtRatioAtTick}\n   *\n   * Computed from log base 1.0001 of 2**128.\n   */\n  int24 public constant MAX_TICK = TickMath.MAX_TICK;\n\n  /**\n   * @dev The minimum value that can be returned from {getSqrtRatioAtTick}\n   *\n   * Equivalent to getSqrtRatioAtTick(MIN_TICK).\n   */\n  uint160 public constant MIN_SQRT_RATIO = TickMath.MIN_SQRT_RATIO;\n\n  /**\n   * @dev The maximum value that can be returned from {getSqrtRatioAtTick}\n   *\n   * Equivalent to getSqrtRatioAtTick(MAX_TICK).\n   */\n  uint160 public constant MAX_SQRT_RATIO = TickMath.MAX_SQRT_RATIO;\n\n  /**\n   * @dev Get the square root ratio at a tick\n   *\n   * Calculates sqrt(1.0001^tick) * 2^96.\n   *\n   * Throws if |tick| > max tick.\n   *\n   * @param tick The input tick for the above formula\n   *\n   * @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt\n   * of the ratio of the two assets (token1/token0)\n   */\n  function getSqrtRatioAtTick(\n    int24 tick\n  ) external pure returns (uint160 sqrtPriceX96) {\n    sqrtPriceX96 = TickMath.getSqrtRatioAtTick(tick);\n    return sqrtPriceX96;\n  }\n\n  /**\n   * @dev Get the tick at a square root ratio\n   *\n   * Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio.\n   *\n   * Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the\n   * lowest value getRatioAtTick may ever return.\n   *\n   * @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n   *\n   * @return tick The greatest tick for which the ratio is less than or equal\n   *              to the input ratio\n   */\n  function getTickAtSqrtRatio(\n    uint160 sqrtPriceX96\n  ) external pure returns (int24 tick) {\n    tick = TickMath.getTickAtSqrtRatio(sqrtPriceX96);\n    return tick;\n  }\n}\n"
    },
    "contracts/test/utils/math/TestVRGDAMath.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport {VRGDAMath} from \"../../../src/utils/math/VRGDAMath.sol\";\n\n/**\n * @dev Helper contract for VRGDAMath library testing\n */\ncontract TestVRGDAMath {\n  // TODO\n}\n"
    },
    "contracts/test/utils/TestStringUtils.sol": {
      "content": "/*\n * Copyright (C) 2024 Powell Nickels\n * https://github.com/PowellNickels/pow5-contracts\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n * See the file LICENSE.txt for more information.\n */\n\npragma solidity 0.8.28;\n\nimport \"../../src/utils/StringUtils.sol\";\n\n/**\n * @dev Contract to test StringUtils library\n */\ncontract TestStringUtils {\n  /**\n   * @dev See {StringUtils-stringToBytes32}\n   */\n  function testBytes32ToString(\n    bytes32 input\n  ) external pure returns (string memory) {\n    return StringUtils.bytes32ToString(input);\n  }\n}\n"
    },
    "solmate/src/utils/SignedWadMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Signed 18 decimal fixed point (wad) arithmetic library.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SignedWadMath.sol)\n/// @author Modified from Remco Bloemen (https://xn--2-umb.com/22/exp-ln/index.html)\n\n/// @dev Will not revert on overflow, only use where overflow is not possible.\nfunction toWadUnsafe(uint256 x) pure returns (int256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Multiply x by 1e18.\n        r := mul(x, 1000000000000000000)\n    }\n}\n\n/// @dev Takes an integer amount of seconds and converts it to a wad amount of days.\n/// @dev Will not revert on overflow, only use where overflow is not possible.\n/// @dev Not meant for negative second amounts, it assumes x is positive.\nfunction toDaysWadUnsafe(uint256 x) pure returns (int256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Multiply x by 1e18 and then divide it by 86400.\n        r := div(mul(x, 1000000000000000000), 86400)\n    }\n}\n\n/// @dev Takes a wad amount of days and converts it to an integer amount of seconds.\n/// @dev Will not revert on overflow, only use where overflow is not possible.\n/// @dev Not meant for negative day amounts, it assumes x is positive.\nfunction fromDaysWadUnsafe(int256 x) pure returns (uint256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Multiply x by 86400 and then divide it by 1e18.\n        r := div(mul(x, 86400), 1000000000000000000)\n    }\n}\n\n/// @dev Will not revert on overflow, only use where overflow is not possible.\nfunction unsafeWadMul(int256 x, int256 y) pure returns (int256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Multiply x by y and divide by 1e18.\n        r := sdiv(mul(x, y), 1000000000000000000)\n    }\n}\n\n/// @dev Will return 0 instead of reverting if y is zero and will\n/// not revert on overflow, only use where overflow is not possible.\nfunction unsafeWadDiv(int256 x, int256 y) pure returns (int256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Multiply x by 1e18 and divide it by y.\n        r := sdiv(mul(x, 1000000000000000000), y)\n    }\n}\n\nfunction wadMul(int256 x, int256 y) pure returns (int256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Store x * y in r for now.\n        r := mul(x, y)\n\n        // Combined overflow check (`x == 0 || (x * y) / x == y`) and edge case check\n        // where x == -1 and y == type(int256).min, for y == -1 and x == min int256,\n        // the second overflow check will catch this.\n        // See: https://secure-contracts.com/learn_evm/arithmetic-checks.html#arithmetic-checks-for-int256-multiplication\n        // Combining into 1 expression saves gas as resulting bytecode will only have 1 `JUMPI`\n        // rather than 2.\n        if iszero(\n            and(\n                or(iszero(x), eq(sdiv(r, x), y)),\n                or(lt(x, not(0)), sgt(y, 0x8000000000000000000000000000000000000000000000000000000000000000))\n            )\n        ) {\n            revert(0, 0)\n        }\n\n        // Scale the result down by 1e18.\n        r := sdiv(r, 1000000000000000000)\n    }\n}\n\nfunction wadDiv(int256 x, int256 y) pure returns (int256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Store x * 1e18 in r for now.\n        r := mul(x, 1000000000000000000)\n\n        // Equivalent to require(y != 0 && ((x * 1e18) / 1e18 == x))\n        if iszero(and(iszero(iszero(y)), eq(sdiv(r, 1000000000000000000), x))) {\n            revert(0, 0)\n        }\n\n        // Divide r by y.\n        r := sdiv(r, y)\n    }\n}\n\n/// @dev Will not work with negative bases, only use when x is positive.\nfunction wadPow(int256 x, int256 y) pure returns (int256) {\n    // Equivalent to x to the power of y because x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)\n    return wadExp((wadLn(x) * y) / 1e18); // Using ln(x) means x must be greater than 0.\n}\n\nfunction wadExp(int256 x) pure returns (int256 r) {\n    unchecked {\n        // When the result is < 0.5 we return zero. This happens when\n        // x <= floor(log(0.5e18) * 1e18) ~ -42e18\n        if (x <= -42139678854452767551) return 0;\n\n        // When the result is > (2**255 - 1) / 1e18 we can not represent it as an\n        // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.\n        if (x >= 135305999368893231589) revert(\"EXP_OVERFLOW\");\n\n        // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\n        // for more intermediate precision and a binary basis. This base conversion\n        // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\n        x = (x << 78) / 5**18;\n\n        // Reduce range of x to (-½ ln 2, ½ ln 2) * 2**96 by factoring out powers\n        // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\n        // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\n        int256 k = ((x << 96) / 54916777467707473351141471128 + 2**95) >> 96;\n        x = x - k * 54916777467707473351141471128;\n\n        // k is in the range [-61, 195].\n\n        // Evaluate using a (6, 7)-term rational approximation.\n        // p is made monic, we'll multiply by a scale factor later.\n        int256 y = x + 1346386616545796478920950773328;\n        y = ((y * x) >> 96) + 57155421227552351082224309758442;\n        int256 p = y + x - 94201549194550492254356042504812;\n        p = ((p * y) >> 96) + 28719021644029726153956944680412240;\n        p = p * x + (4385272521454847904659076985693276 << 96);\n\n        // We leave p in 2**192 basis so we don't need to scale it back up for the division.\n        int256 q = x - 2855989394907223263936484059900;\n        q = ((q * x) >> 96) + 50020603652535783019961831881945;\n        q = ((q * x) >> 96) - 533845033583426703283633433725380;\n        q = ((q * x) >> 96) + 3604857256930695427073651918091429;\n        q = ((q * x) >> 96) - 14423608567350463180887372962807573;\n        q = ((q * x) >> 96) + 26449188498355588339934803723976023;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Div in assembly because solidity adds a zero check despite the unchecked.\n            // The q polynomial won't have zeros in the domain as all its roots are complex.\n            // No scaling is necessary because p is already 2**96 too large.\n            r := sdiv(p, q)\n        }\n\n        // r should be in the range (0.09, 0.25) * 2**96.\n\n        // We now need to multiply r by:\n        // * the scale factor s = ~6.031367120.\n        // * the 2**k factor from the range reduction.\n        // * the 1e18 / 2**96 factor for base conversion.\n        // We do this all at once, with an intermediate result in 2**213\n        // basis, so the final right shift is always by a positive amount.\n        r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));\n    }\n}\n\nfunction wadLn(int256 x) pure returns (int256 r) {\n    unchecked {\n        require(x > 0, \"UNDEFINED\");\n\n        // We want to convert x from 10**18 fixed point to 2**96 fixed point.\n        // We do this by multiplying by 2**96 / 10**18. But since\n        // ln(x * C) = ln(x) + ln(C), we can simply do nothing here\n        // and add ln(2**96 / 10**18) at the end.\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            r := or(r, shl(2, lt(0xf, shr(r, x))))\n            r := or(r, shl(1, lt(0x3, shr(r, x))))\n            r := or(r, lt(0x1, shr(r, x)))\n        }\n\n        // Reduce range of x to (1, 2) * 2**96\n        // ln(2^k * x) = k * ln(2) + ln(x)\n        int256 k = r - 96;\n        x <<= uint256(159 - k);\n        x = int256(uint256(x) >> 159);\n\n        // Evaluate using a (8, 8)-term rational approximation.\n        // p is made monic, we will multiply by a scale factor later.\n        int256 p = x + 3273285459638523848632254066296;\n        p = ((p * x) >> 96) + 24828157081833163892658089445524;\n        p = ((p * x) >> 96) + 43456485725739037958740375743393;\n        p = ((p * x) >> 96) - 11111509109440967052023855526967;\n        p = ((p * x) >> 96) - 45023709667254063763336534515857;\n        p = ((p * x) >> 96) - 14706773417378608786704636184526;\n        p = p * x - (795164235651350426258249787498 << 96);\n\n        // We leave p in 2**192 basis so we don't need to scale it back up for the division.\n        // q is monic by convention.\n        int256 q = x + 5573035233440673466300451813936;\n        q = ((q * x) >> 96) + 71694874799317883764090561454958;\n        q = ((q * x) >> 96) + 283447036172924575727196451306956;\n        q = ((q * x) >> 96) + 401686690394027663651624208769553;\n        q = ((q * x) >> 96) + 204048457590392012362485061816622;\n        q = ((q * x) >> 96) + 31853899698501571402653359427138;\n        q = ((q * x) >> 96) + 909429971244387300277376558375;\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Div in assembly because solidity adds a zero check despite the unchecked.\n            // The q polynomial is known not to have zeros in the domain.\n            // No scaling required because p is already 2**96 too large.\n            r := sdiv(p, q)\n        }\n\n        // r is in the range (0, 0.125) * 2**96\n\n        // Finalization, we need to:\n        // * multiply by the scale factor s = 5.549…\n        // * add ln(2**96 / 10**18)\n        // * add k * ln(2)\n        // * multiply by 10**18 / 2**96 = 5**18 >> 78\n\n        // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\n        r *= 1677202110996718588342820967067443963516166;\n        // add ln(2) * k * 5e18 * 2**192\n        r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\n        // add ln(2**96 / 10**18) * 5e18 * 2**192\n        r += 600920179829731861736702779321621459595472258049074101567377883020018308;\n        // base conversion: mul 2**18 / 2**192\n        r >>= 174;\n    }\n}\n\n/// @dev Will return 0 instead of reverting if y is zero.\nfunction unsafeDiv(int256 x, int256 y) pure returns (int256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Divide x by y.\n        r := sdiv(x, y)\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}